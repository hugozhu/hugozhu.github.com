<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Java - Hugo Zhu's Blog</title>
<script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"All about Raspberry Pi","url":"https:\/\/blog.hugozhu.site\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/blog.hugozhu.site\/"}</script><meta property="og:title" content="Java"><meta property="og:image" content="https://blog.hugozhu.site/img/pi.png"><meta property="og:url" content="https://blog.hugozhu.site/tags/java/"><meta property="og:type" content="website"><meta property="og:site_name" content="All about Raspberry Pi"><meta name=twitter:title content="Java"><meta name=twitter:image content="https://blog.hugozhu.site/img/pi.png"><meta name=twitter:card content="summary_large_image"><link href=https://blog.hugozhu.site/img/pi.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.145.0"><link rel=alternate href=https://blog.hugozhu.site/index.xml type=application/rss+xml title="All about Raspberry Pi"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v6.6.0/css/all.css integrity=sha384-h/hnnw1Bi4nbpD6kE7nYfCXzovi622sY5WBxww8ARKwpdLj5kUWjRuyiXaD1U2JT crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://blog.hugozhu.site/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://blog.hugozhu.site/css/highlight.min.css><link rel=stylesheet href=https://blog.hugozhu.site/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-W88HDMN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","GTM-W88HDMN")}</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://blog.hugozhu.site/>All about Raspberry Pi</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li class=navlinks-container><a class=navlinks-parent role=button tabindex=0>Tools</a><div class=navlinks-children><a href=https://nddapp.com/json-encoder.html>HTML Tools</a>
<a href=https://www.birme.net/>Imaeg Resizing</a>
<a href=https://jwt.io/>JWT Token Tool</a></div></li><li><a title=About href=/page/about/>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li><a href=#modalSearch data-toggle=modal data-target=#modalSearch style=outline:none><span class="hidden-sm hidden-md hidden-lg">Search</span> <span id=searchGlyph class="glyphicon glyphicon-search"></span></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="All about Raspberry Pi" href=https://blog.hugozhu.site/><img class=avatar-img src=https://blog.hugozhu.site/img/pi.png alt="All about Raspberry Pi"></a></div></div></div></nav><div id=modalSearch class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><button type=button class=close data-dismiss=modal>&#215;</button><h4 class=modal-title>Search All about Raspberry Pi</h4></div><div class=modal-body><gcse:search></gcse:search></div><div class=modal-footer><button type=button class="btn btn-default" data-dismiss=modal>Close</button></div></div></div></div><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=tags-heading><h1>Java</h1><hr class=small></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=posts-list><article class=post-preview><a href=https://blog.hugozhu.site/post/2013/22-memory-barriers-or-fences/><h2 class=post-title>并发编程之内存屏障</h2></a><p class=post-meta><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on March 28, 2013
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;149&nbsp;words</span></p><div class=post-entry><p>原文地址：<a href=http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html><code>http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html</code></a> 或 <a href=http://ifeve.com/memory-barriersfences/><code>http://ifeve.com/memory-barriersfences/</code></a></p><p>关键词：Load Barrier, Store Barrier, Full Barrier</p><p>本文我将和大家讨论并发编程中最基础的一项技术：内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p><p>CPU使用了很多优化技术来达成一个事实：CPU执行单元的速度要远超主存访问速度。在我上一篇文章 &ldquo;Write Combing - 合并写"中我已经介绍了其中的一项技术。CPU避免内存访问延迟最常见的技术是将指令管道化，然后尽量重排这些管道的执行以最大利用缓存而把因为缓存未命中引起的延迟降到最小。</p><p>当一个程序执行时指令是否被重排并不重要，只要最终的结果是一样的。例如，在一个循环里，如果循环体内没用到这个计数器，循环的计数器什么时候更新（在循环开始，中间还是最后）并不重要。编译器和CPU可以自由的重排指令以最佳的利用CPU，只要下一次循环前更新该计数器即可。并且在循环执行中，这个变量可能一直存在寄存器上，并没有被推到缓存或主存，这样这个变量对其他CPU来说一直都是不可见的。</p><p>CPU核内部包含了多个执行单元。例如，现代Intel CPU包含了6个执行单元，可以组合进行算术运算，逻辑条件判断及内存操作。每个执行单元可以执行上述任务的某种组合。这些执行单元是并行执行的，这样指令也就是在并行执行。但如果站在另一个CPU角度看，这也就产生了程序顺序的另一种不确定性。</p><p>最后，当一个缓存失效发生时，现代CPU可以先假设一个内存载入的值并根据这个假设值继续执行，直到内存载入返回确切的值。</p><img src=http://ifeve.com/wp-content/uploads/2013/03/cpu.png><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CPU核
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  V
</span></span><span class=line><span class=cl>寄存器
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  V
</span></span><span class=line><span class=cl>执行单元 -&gt; Load/Store缓冲区-&gt;L1 Cache ---&gt;L3 Cache--&gt;内存控制器--&gt;主存
</span></span><span class=line><span class=cl>       |                                   |
</span></span><span class=line><span class=cl>       +-&gt; Write Combine缓冲区-&gt;L2 Cache ---+
</span></span></code></pre></div><p>代码顺序并不是真正的执行顺序，CPU和编译器可以各种优化只要有空间提高性能。缓存和主存的读取会利用load, store和write-combining缓冲区来缓冲和重排。这些缓冲区是查找速度很快的关联队列，当一个后来发生的load需要读取上一个store的值，而该值还没有到达缓存，查找是必需的，上图描绘的是一个简化的现代多核CPU，从上图可以看出执行单元可以利用本地寄存器和缓冲区来管理和缓存子系统的交互。</p><p>在多线程环境里需要使用技术来使得程序结果尽快可见。这篇文章里我不会涉及到 Cache Conherence 的概念。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为内存屏障或内存栅栏。</p><p>内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。</p><p>大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。相对来说Intel CPU的强内存模型比DEC Alpha的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。因为x86处理器是在多线程编程中最常见的，下面我尽量用x86的架构来阐述。</p><h1 id=store-barrier>Store Barrier</h1><p>Store屏障，是x86的&rdquo;<strong>sfence</strong>&ldquo;指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。一个实际的好例子是Disruptor中的<a href=http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchEventProcessor.java>BatchEventProcessor</a>。当序列Sequence被一个消费者更新时，其它消费者(Consumers)和生产者（Producers）知道该消费者的进度，因此可以采取合适的动作。所以屏障之前发生的内存更新都可见了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>private volatile long sequence = RingBuffer.INITIAL_CURSOR_VALUE;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>// from inside the run() method
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>T event = null;
</span></span><span class=line><span class=cl>long nextSequence = sequence.get() + 1L;
</span></span><span class=line><span class=cl>while (running)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    try
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        final long availableSequence = barrier.waitFor(nextSequence);
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        while (nextSequence &lt;= availableSequence)
</span></span><span class=line><span class=cl>        {
</span></span><span class=line><span class=cl>            event = ringBuffer.get(nextSequence);
</span></span><span class=line><span class=cl>            boolean endOfBatch = nextSequence == availableSequence;
</span></span><span class=line><span class=cl>            eventHandler.onEvent(event, nextSequence, endOfBatch);
</span></span><span class=line><span class=cl>            nextSequence++;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        sequence.set(nextSequence - 1L); 
</span></span><span class=line><span class=cl>        // store barrier inserted here !!!
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    catch (final Exception ex)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        exceptionHandler.handle(ex, nextSequence, event);
</span></span><span class=line><span class=cl>        sequence.set(nextSequence);
</span></span><span class=line><span class=cl>        // store barrier inserted here !!!
</span></span><span class=line><span class=cl>        nextSequence++;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h1 id=load-barrier>Load Barrier</h1><p>Load屏障，是x86上的&rdquo;<strong>ifence</strong>&ldquo;指令，强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。这使得从其它CPU暴露出来的程序状态对该CPU可见，这之后CPU可以进行后续处理。一个好例子是上面的BatchEventProcessor的sequence对象是放在屏障后被生产者或消费者使用。</p><a href=https://blog.hugozhu.site/post/2013/22-memory-barriers-or-fences/ class=post-read-more>[Read More]</a></div><div class=blog-tags><a href=https://blog.hugozhu.site/tags/java/>Java</a>&nbsp;
<a href=https://blog.hugozhu.site/tags/concurrent-programming/>Concurrent Programming</a>&nbsp;
<a href=https://blog.hugozhu.site/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>&nbsp;</div></article><article class=post-preview><a href=https://blog.hugozhu.site/post/2013/java-synchronousqueue-notes/><h2 class=post-title>Java并发包中的同步队列SynchronousQueue实现原理</h2></a><p class=post-meta><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on March 5, 2013
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;4&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;834&nbsp;words</span></p><div class=post-entry><h2 id=介绍>介绍</h2><p>Java 6的并发编程包中的<a href=http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html>SynchronousQueue</a>是一个没有数据缓冲的<a href=http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/BlockingQueue.html>BlockingQueue</a>，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。</p><p>不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的<strong>线程</strong>，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后<strong>一起</strong>离开。</p><p>SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p><h2 id=实现原理>实现原理</h2><p>同步队列的实现方法有许多：</p><h3 id=阻塞算法实现>阻塞算法实现</h3><p>阻塞算法实现通常在内部采用一个锁来保证多个线程中的put()和take()方法是串行执行的。采用锁的开销是比较大的，还会存在一种情况是线程A持有线程B需要的锁，B必须一直等待A释放锁，即使A可能一段时间内因为B的优先级比较高而得不到时间片运行。所以在高性能的应用中我们常常希望规避锁的使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>public class NativeSynchronousQueue&lt;E&gt; {
</span></span><span class=line><span class=cl>    boolean putting = false;
</span></span><span class=line><span class=cl>    E item = null;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public synchronized E take() throws InterruptedException {
</span></span><span class=line><span class=cl>        while (item == null)
</span></span><span class=line><span class=cl>            wait();
</span></span><span class=line><span class=cl>        E e = item;
</span></span><span class=line><span class=cl>        item = null;
</span></span><span class=line><span class=cl>        notifyAll();
</span></span><span class=line><span class=cl>        return e;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    public synchronized void put(E e) throws InterruptedException {
</span></span><span class=line><span class=cl>        if (e==null) return;
</span></span><span class=line><span class=cl>        while (putting)
</span></span><span class=line><span class=cl>            wait();
</span></span><span class=line><span class=cl>        putting = true;
</span></span><span class=line><span class=cl>        item = e;
</span></span><span class=line><span class=cl>        notifyAll();
</span></span><span class=line><span class=cl>        while (item!=null)
</span></span><span class=line><span class=cl>            wait();
</span></span><span class=line><span class=cl>        putting = false;
</span></span><span class=line><span class=cl>        notifyAll();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h3 id=信号量实现>信号量实现</h3><p>经典同步队列实现采用了三个信号量，代码很简单，比较容易理解：</p><a href=https://blog.hugozhu.site/post/2013/java-synchronousqueue-notes/ class=post-read-more>[Read More]</a></div><div class=blog-tags><a href=https://blog.hugozhu.site/tags/java/>Java</a>&nbsp;
<a href=https://blog.hugozhu.site/tags/concurrent-programming/>Concurrent Programming</a>&nbsp;</div></article><article class=post-preview><a href=https://blog.hugozhu.site/post/2013/resource-management-in-java/><h2 class=post-title>Java的资源管理</h2></a><p class=post-meta><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on March 1, 2013
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;2&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;323&nbsp;words</span></p><div class=post-entry><h2 id=overview>Overview</h2><p>Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。</p><h2 id=try-catch-finally>try-catch-finally</h2><p>Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如<a href=http://findbugs.sourceforge.net><strong>FindBugs</strong></a>可以帮助发现此类问题。</p><p>首先我们来看一段文件操作代码：</p><pre><code>private void copy(String from, String to) throws IOException {
    FileInputStream in = null;  
    FileOutputStream out = null;  
    in = new FileInputStream(from);  
    out = new FileOutputStream(to);  
    int c;  
    while ((c = in.read()) != -1)
        out.write(c);  
    in.close();
    out.close();
}
</code></pre><p>一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-<a href=http://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6>文件描述符</a>，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。</p><h4 id=file-descriptor><a href=http://en.wikipedia.org/wiki/File_descriptor>File descriptor</a></h4><p>Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。</p><img src=https://pbs.twimg.com/media/BEUt3v3CEAAeP-m.jpg:large><p>较为正确的代码应该是：</p><pre><code>private void copy(String src, String dest) throws IOException {
    FileInputStream in = null;  
    FileOutputStream out = null;  
    try {
        in = new FileInputStream(src);  
        out = new FileOutputStream(dest);  
        int c;  
        while ((c = in.read()) != -1)
            out.write(c);
    } finally {
         try {
             if (in!=null) {
                in.close();
             }
         } finally {
             if (out!=null) {
                out.close();
             }
         }
    }
}
</code></pre><p>但是这样的代码写起来是不是让人有点沮丧？这样写代码犯错的可能性确实比较大。
改良过后的代码阅读性好一些：</p><a href=https://blog.hugozhu.site/post/2013/resource-management-in-java/ class=post-read-more>[Read More]</a></div><div class=blog-tags><a href=https://blog.hugozhu.site/tags/java/>Java</a>&nbsp;
<a href=https://blog.hugozhu.site/tags/%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E/>代码之美</a>&nbsp;</div></article><article class=post-preview><a href=https://blog.hugozhu.site/post/2013/logging-in-java/><h2 class=post-title>Java程序的日志</h2></a><p class=post-meta><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on February 28, 2013
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;2&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;265&nbsp;words</span></p><div class=post-entry><h2 id=overview>Overview</h2><p>一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。</p><p>一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：</p><ol><li>对程序运行情况的记录和监控；</li><li>在必要时可详细了解程序内部的运行状态；</li><li>对系统性能的影响尽量小；</li></ol><h2 id=日志规范>日志规范</h2><p>程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。
首先我们有必要了解一下Linux普遍使用的<a href=http://en.wikipedia.org/wiki/Syslog>Syslog</a>标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。</p><p>下面是部分常见的Syslog模块类型：</p><table><thead><tr><th><strong>模块ID</strong></th><th><strong>关键词</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>kern</td><td>内核消息</td></tr><tr><td>1</td><td>user</td><td>用户级别消息</td></tr><tr><td>2</td><td>mail</td><td>邮件系统</td></tr><tr><td>3</td><td>daemon</td><td>系统后台守护程序</td></tr><tr><td>4</td><td>auth</td><td>安全/鉴权消息</td></tr><tr><td>5</td><td>syslog</td><td>syslogd内部产生的日志消息</td></tr><tr><td>…</td><td></td><td></td></tr></tbody></table><p>以及Syslog严重程度划分：</p><table><thead><tr><th><strong>代码</strong></th><th><strong>严重程度</strong></th><th><strong>关键词</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>0</td><td>Emergency</td><td>emerg(panic)</td><td>紧急，系统已经不稳定了</td></tr><tr><td>1</td><td>Alert</td><td>alert</td><td>需要立刻采取措施</td></tr><tr><td>2</td><td>Critical</td><td>crit</td><td>严重情况</td></tr><tr><td>3</td><td>Error</td><td>err (error)</td><td>系统出错</td></tr><tr><td>4</td><td>Warning</td><td>warning(warn)</td><td>系统警告</td></tr><tr><td>5</td><td>Notice</td><td>notice</td><td>系统仍然正常，但值得注意</td></tr><tr><td>6</td><td>Informational</td><td>info</td><td>正常系统通告</td></tr><tr><td>7</td><td>Debug</td><td>debug</td><td>系统调试信息</td></tr></tbody></table><p>在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。</p><a href=https://blog.hugozhu.site/post/2013/logging-in-java/ class=post-read-more>[Read More]</a></div><div class=blog-tags><a href=https://blog.hugozhu.site/tags/java/>Java</a>&nbsp;
<a href=https://blog.hugozhu.site/tags/%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E/>代码之美</a>&nbsp;</div></article><article class=post-preview><a href=https://blog.hugozhu.site/post/2013/java-properties-to-enviorment-variables/><h2 class=post-title>将Java的Properties文件转换成环境变量</h2></a><p class=post-meta><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on February 25, 2013
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;71&nbsp;words</span></p><div class=post-entry><h2 id=overview>Overview</h2><p>在Java程序中使用properties文件很方便，但有时候需要和脚本配合使用时，需要把properties文件内的多个变量转换成环境变量，本文提供一个转换脚本示范：</p><p>比如env.properties如下（=附近可以有空格，也可以有空行）</p><pre><code>MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=gbk
MYSQL_USER = root
MYSQL_PASS = 
</code></pre><p>执行下面的脚本后就相当于</p><pre><code>export MYSQL_URL=&quot;//localhost:3306/test?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=gbk&quot;
export MYSQL_USER=&quot;root&quot;
export MYSQL_PASS=&quot;&quot; 
</code></pre><p>env.sh脚本代码</p><pre><code>#!/bin/bash

property_file=env.properties

get_prop(){
    propfile=$1
    key=$2
    grep  &quot;^${2}=&quot; ${1}| sed &quot;s%${2}=\(.*\)%\1%&quot;
}

trim() {
    trimmed=$1
    trimmed=${trimmed%% }
    trimmed=${trimmed## }
    echo &quot;$trimmed&quot;
}

`grep -v &quot;^#&quot; $property_file | sed -e '/^$/d' | while read line
do
    key=$(echo $line | awk -F &quot;=&quot; '{print $1}')
    trimmed_key=$(trim $key)
    trimmed_val=$(trim $(get_prop $property_file &quot;$key&quot;)
    echo &quot;export $trimmed_key=\&quot;$trimmed_val\&quot;)&quot;
done`
</code></pre></div><div class=blog-tags><a href=https://blog.hugozhu.site/tags/java/>Java</a>&nbsp;</div></article></div></div></div></div><footer><div class=container><div class=row><div class=disclaimer><b>Disclaimer:</b> The opinions expressed herein are my own personal opinions and do not represent my company’s view in any way.</div></div><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=/tags/java/index.xml title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2025
&nbsp;&bull;&nbsp;
<a href=https://blog.hugozhu.site/>All about Raspberry Pi</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.145.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://blog.hugozhu.site/js/main.js></script><script src=https://blog.hugozhu.site/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://blog.hugozhu.site/js/load-photoswipe.js></script><script>(function(){var t,n="617d351a633194d48",e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://cse.google.com/cse.js?cx="+n,t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>$(function(){$("#show-comments").on("click",function(){var e="hugozhu";(function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="//"+e+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)})(),$(this).hide()})})</script><script id=dsq-count-scr src=//hugozhu.disqus.com/count.js async></script></body></html>