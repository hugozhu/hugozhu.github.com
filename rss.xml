<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Hugo Zhu</title>
    <link>http://hugozhu.myalert.info</link>
    <pubDate>2013-03-02 09:29:15 +0800</pubDate>
    <item>
      <title>OpenVPN使用多个端口</title>
      <link>http://hugozhu.myalert.info/2013/03/02/openvpn-multiple-ports.html</link>
      <pubDate>2013-03-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Openvpn本身不能设置多个端口，使用iptables可以解决这个问题 （假设openvpn本来56788端口）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for port in {56780..56787}&#xA;do &#xA;    iptables -t nat -A PREROUTING -p tcp -d &amp;lt;your_external_ip&amp;gt; --dport $port -j REDIRECT --to-port 56788&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在Ubuntu上配置L2TP，PPTP和OpenVPN服务</title>
      <link>http://hugozhu.myalert.info/2013/03/01/setup-l2tp-pptp-openvpn-on-ubuntu.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;MacOS, Windows, iOS都内置支持PPTP，L2TP；OpenVPN需要安装客户端，手机上一般不支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先打开内核的IP转发，修改 /etc/sysctl.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面命令以生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;PPTP&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装pptpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install pptpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/pptpd.conf，下面两行取消注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这行注释掉&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#logwtmp &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从文件 /etc/pptpd.conf 中找到配置选项文件，如下为：/etc/ppp/pptpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;grep options /etc/pptpd.conf&#xA;#       Specifies the location of the PPP options file.&#xA;#       By default PPP looks in &#39;/etc/ppp/options&#39;&#xA;option /etc/ppp/pptpd-options&#xA;#       option in the pppd options file, or run bcrelay.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/ppp/pptpd-options，增加以下内容，最后两项为推给VPN客户端的DNS服务器IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mtu 1492&#xA;name pptpd&#xA;refuse-pap&#xA;refuse-chap&#xA;refuse-mschap&#xA;require-mschap-v2&#xA;require-mppe-128&#xA;proxyarp&#xA;lock&#xA;nobsdcomp&#xA;novj&#xA;novjccomp&#xA;nologfd &#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    pptpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE&#xA;iptables -A INPUT -i lo -j ACCEPT&#xA;iptables -A INPUT -i tap+ -j ACCEPT&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tap+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -P FORWARD ACCEPT    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;L2TP Over IPSec&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;假设你的服务器IP是：&lt;strong&gt;1.2.3.4&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先更新一下源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装openswan&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openswan&#xA;&#xA;sudo cp /etc/ipsec.d/examples/l2tp-psk.conf /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件 /etc/ipsec.d/l2tp-psk.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;left=1.2.3.4 #机器的外部IP&#xA;leftnexthop=1.2.3.1 #机器的Gateway&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.conf，在文件最后增加：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;include /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.secrets&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.2.3.4 %any: &amp;quot;yourSharedPSK!&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装 xl2tpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install xl2tpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/xl2tpd/xl2tpd.conf , 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[global]&#xA;ipsec saref = yes&#xA;listen-addr = 1.2.3.4&#xA;&#xA;[lns default]&#xA;ip range = 192.168.1.10-192.168.1.20&#xA;local ip = 192.168.1.1&#xA;;require chap = yes&#xA;refuse chap = yes&#xA;refuse pap = yes&#xA;require authentication = yes&#xA;ppp debug = yes&#xA;pppoptfile = /etc/ppp/xl2tpd-options&#xA;length bit = yes    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cp /etc/ppp/options /etc/ppp/xl2tpd-options&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;asyncmap 0&#xA;auth&#xA;crtscts&#xA;lock&#xA;hide-password&#xA;modem&#xA;mru 1280&#xA;netmask 255.255.255.0&#xA;mtu 1280&#xA;name l2tpd&#xA;proxyarp&#xA;lcp-echo-interval 30&#xA;lcp-echo-failure 4&#xA;noipx&#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    l2tpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）, 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -A INPUT -p 50 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 500 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 4500 -j ACCEPT&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;OpenVPN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装Openvpn&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openvpn    &#xA;&#xA;cp -r /usr/share/doc/openvpn/examples/easy-rsa/ /etc/openvpn/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成CA证书&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/openvpn/easy-rsa/2.0&#xA;source vars&#xA;./clean-all&#xA;./build-ca&#xA;./build-key-server server&#xA;./build-key client&#xA;./build-dh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑/etc/openvpn/server.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;local 116.251.211.71    &#xA;port 56788    &#xA;proto tcp    &#xA;dev tun&#xA;ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt&#xA;cert /etc/openvpn/easy-rsa/2.0/keys/server.crt&#xA;key /etc/openvpn/easy-rsa/2.0/keys/server.key      &#xA;dh  /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem    &#xA;server 10.8.0.0 255.255.255.0    &#xA;ifconfig-pool-persist ipp.txt&#xA;push &amp;quot;redirect-gateway def1&amp;quot;    &#xA;push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;    &#xA;client-to-client&#xA;keepalive 10 120&#xA;comp-lzo    &#xA;max-clients 50    &#xA;user nobody&#xA;group nogroup    &#xA;persist-key&#xA;persist-tun    &#xA;status openvpn-status.log    &#xA;log-append  openvpn.log    &#xA;verb 3    &#xA;mute 20    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;设置iptable，其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE&#xA;&#xA;iptables -A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT&#xA;iptables -t nat -A PREROUTING -p udp -m udp --dport 53 -j DNAT --to-destination 8.8.8.8&#xA;&#xA;iptables -A INPUT -p udp --dport 1194 -j ACCEPT&#xA;iptables -A INPUT -s 10.8.0.0/24 -p all -j ACCEPT&#xA;iptables -A FORWARD -d 10.8.0.0/24 -j ACCEPT&#xA;&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to-source 1.2.3.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java的资源管理</title>
      <link>http://hugozhu.myalert.info/2013/03/01/resource-management-in-java.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;try-catch-finally&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &amp;ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如&lt;a href=&#34;http://findbugs.sourceforge.net&#34;&gt;&lt;strong&gt;FindBugs&lt;/strong&gt;&lt;/a&gt;可以帮助发现此类问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先我们来看一段文件操作代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String from, String to) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    in = new FileInputStream(from);  &#xA;    out = new FileOutputStream(to);  &#xA;    int c;  &#xA;    while ((c = in.read()) != -1)&#xA;        out.write(c);  &#xA;    in.close();&#xA;    out.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-&lt;a href=&#34;http://zh.wikipedia.org/wiki/文件描述符&#34;&gt;文件描述符&lt;/a&gt;，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/File_descriptor&#34;&gt;File descriptor&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://pbs.twimg.com/media/BEUt3v3CEAAeP-m.jpg:large&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;较为正确的代码应该是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);&#xA;    } finally {&#xA;         try {&#xA;             if (in!=null) {&#xA;                in.close();&#xA;             }&#xA;         } finally {&#xA;             if (out!=null) {&#xA;                out.close();&#xA;             }&#xA;         }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是这样的代码写起来是不是让人有点沮丧？这样写代码犯错的可能性确实比较大。&#xA;改良过后的代码阅读性好一些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;    } finally {&#xA;        FileUtils.close(in);&#xA;        FileUtils.close(out);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让我们也看看在其他语言里是怎么实现的：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Ruby：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def copy(src, dest)&#xA;    File.open(dest, &#39;w&#39;) do |f|  &#xA;        f.write(File.read(src))&#xA;    end  &#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Ruby的File.open 方法接受一个函数作为参数，执行该函数后，会保证打开的文件被关闭，即使在执行函数过程中有异常。相比之下这种代码优美多了有没有？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Golang：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func copy(src string, dest string) {&#xA;    src_file, err := os.Open(src)&#xA;    if err != nil { panic(err) }&#xA;    defer src_file.Close()&#xA;&#xA;    dest_file, err := os.Open(dest)&#xA;    if err != nil { panic(err) }&#xA;    defer dest_file.Close() &#xA;&#xA;    buf := make([]byte,1024)&#xA;&#xA;    for {&#xA;        n, err := src_file.Read(buf)&#xA;        if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;        if n == 0 {break}&#xA;&#xA;        if _, err:= dest_file.Write(buf[:n]); err != nil {&#xA;           panic(err)&#xA;        } &#xA;    }       &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Go语言通过defer关键词来保证程序结束时相应的方法会被调用，嗯，你还是要显示的写Close()方法，但有一点改进就是你可以在打开后立刻写关闭语句，只要加上defer关键词。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Clojure：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defn copy[src dest] ( &#xA;   (with-open [rdr (reader src)&#xA;               wrtr (writer dest)]&#xA;      (doseq [line (line-seq rdr)]&#xA;          (.write wrtr line))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Clojure通过with-open函数来保证打开的文件在异常情况下也会被关闭&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 7：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try (FileInputStream in = new FileInputStream(src);  &#xA;         FileOutputStream out = new FileOutputStream(dest)) {            &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;终于Java 7通过自动资源管理较好的解决了这个问题，try()代码块内的变量在离开时候会自动调用AutoCloseable接口必须实现的close()方法。java.lang.AutoCloseable接口是在Java 7内新增的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;独占资源和并发访问&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;锁&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;读写锁&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;信号量&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;连接池&lt;/h3&gt;&#xA;&#xA;&lt;h2&gt;作业&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考链接&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/trywithresources-401775.html&#34;&gt;Better Resource Management with Java SE 7: Beyond Syntactic Sugar&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Java程序的日志</title>
      <link>http://hugozhu.myalert.info/2013/02/28/logging-in-java.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对程序运行情况的记录和监控；&lt;/li&gt;&#xA;&lt;li&gt;在必要时可详细了解程序内部的运行状态；&lt;/li&gt;&#xA;&lt;li&gt;对系统性能的影响尽量小；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;日志规范&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。&#xA;首先我们有必要了解一下Linux普遍使用的&lt;a href=&#34;http://en.wikipedia.org/wiki/Syslog&#34;&gt;Syslog&lt;/a&gt;标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是部分常见的Syslog模块类型：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;模块ID&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;kern&lt;/td&gt;&#xA;&lt;td&gt;内核消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;user&lt;/td&gt;&#xA;&lt;td&gt;用户级别消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;mail&lt;/td&gt;&#xA;&lt;td&gt;邮件系统&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;daemon&lt;/td&gt;&#xA;&lt;td&gt;系统后台守护程序&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;auth&lt;/td&gt;&#xA;&lt;td&gt;安全/鉴权消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;syslog&lt;/td&gt;&#xA;&lt;td&gt;syslogd内部产生的日志消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;…&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;以及Syslog严重程度划分：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;严重程度&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;Emergency&lt;/td&gt;&#xA;&lt;td&gt;emerg(panic)&lt;/td&gt;&#xA;&lt;td&gt;紧急，系统已经不稳定了&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;Alert&lt;/td&gt;&#xA;&lt;td&gt;alert&lt;/td&gt;&#xA;&lt;td&gt;需要立刻采取措施&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;Critical&lt;/td&gt;&#xA;&lt;td&gt;crit&lt;/td&gt;&#xA;&lt;td&gt;严重情况&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;Error&lt;/td&gt;&#xA;&lt;td&gt;err (error)&lt;/td&gt;&#xA;&lt;td&gt;系统出错&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;Warning&lt;/td&gt;&#xA;&lt;td&gt;warning(warn)&lt;/td&gt;&#xA;&lt;td&gt;系统警告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;Notice&lt;/td&gt;&#xA;&lt;td&gt;notice&lt;/td&gt;&#xA;&lt;td&gt;系统仍然正常，但值得注意&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;Informational&lt;/td&gt;&#xA;&lt;td&gt;info&lt;/td&gt;&#xA;&lt;td&gt;正常系统通告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;Debug&lt;/td&gt;&#xA;&lt;td&gt;debug&lt;/td&gt;&#xA;&lt;td&gt;系统调试信息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Java日志框架&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架太多了。。。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logging.apache.org&#34;&gt;&lt;strong&gt;Log4j&lt;/strong&gt;&lt;/a&gt; 或 &lt;a href=&#34;http://logging.apache.org/log4j/2.x/&#34;&gt;&lt;strong&gt;Log4j 2&lt;/strong&gt;&lt;/a&gt; - Apache的开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个配置文件（XML或Properties文件）来灵活地进行配置，而不需要修改程序代码。Log4j 2则是前任的一个升级，参考了Logback的许多特性；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logback.qos.ch&#34;&gt;&lt;strong&gt;Logback&lt;/strong&gt;&lt;/a&gt; - Logback是由log4j创始人设计的又一个开源日记组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/logging/package-summary.html&#34;&gt;&lt;strong&gt;java.util.logging&lt;/strong&gt;&lt;/a&gt; - JDK内置的日志接口和实现，功能比较简单&amp;hellip;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org&#34;&gt;&lt;strong&gt;Slf4j&lt;/strong&gt;&lt;/a&gt; - SLF4J是为各种Logging API提供一个简单统一的接口），从而使用户能够在部署的时候配置自己希望的Logging API实现；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging/&#34;&gt;&lt;strong&gt;Apache Commons Logging&lt;/strong&gt;&lt;/a&gt; - Apache Commons Logging （JCL）希望解决的问题和Slf4j类似。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;选项太多了的后果就是选择困难症，我的看法是没有最好的，只有最合适的。在比较关注性能的地方，选择Logback或自己实现高性能Logging API可能更合适；在已经使用了Log4j的项目中，如果没有发现问题，继续使用可能是更合适的方式；我一般会在项目里选择使用Slf4j, 如果不想有依赖则使用java.util.logging或框架容器已经提供的日志接口。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Java日志最佳实践&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;定义日志变量&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;需要定义成final static&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志分级&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架一般会提供以下日志级别，缺省打开info级别，也就是debug，trace级别的日志在生产环境不会输出，在开发和测试环境可以通过不同的日志配置文件打开debug级别。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;fatal&lt;/strong&gt; - 严重的，造成服务中断的错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;error&lt;/strong&gt; - 其他错误运行期错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;warn&lt;/strong&gt; -  警告信息，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;info&lt;/strong&gt; -  有意义的事件信息，如程序启动，关闭事件，收到请求事件等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;debug&lt;/strong&gt; - 调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;trace&lt;/strong&gt; - 更详细的跟踪信息；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在程序里要合理使用日志分级:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//调试的时候可以知道进入了方法&#xA;logger.debug(&amp;quot;entering getting content&amp;quot;);&#xA;String content = CacheManager.getCachedContent();&#xA;if (content == null) {&#xA;&#xA;    //使用warn，因为程序还可以继续执行，但类似警告太多可能说明缓存服务不可用了，值得引起注意&#xA;    logger.warn(&amp;quot;Got empty content from cache, need perform database lookup&amp;quot;); &#xA;&#xA;    Connection conn = ConnectionFactory.getConnection();&#xA;    if (conn == null) {&#xA;        logger.error(&amp;quot;Can&#39;t get database connection, failed to return content&amp;quot;); //尽量提供详细的信息，知道错误的原因，而不能简单的写logger.error(&amp;quot;failed&amp;quot;)&#xA;    } else {&#xA;        try {&#xA;            content = conn.query(...);&#xA;        } catch (IOException e) {&#xA;            //异常要记录错误堆栈&#xA;            logger.error(&amp;quot;Failed to perform database lookup&amp;quot;, e);&#xA;        } finally {&#xA;            ConnectionFactory.releaseConnection(conn);&#xA;        }&#xA;    }&#xA;}&#xA;//调试的时候可以知道方法返回了&#xA;logger.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;return content;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这段示范代码演示了各种级别的使用，但其中有个问题是debug日志太多后可能会影响性能？有一种改进方法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (logger.isDebugEnabled()) {&#xA;    logger.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但更好的方法是Slf4j提供的&lt;a href=&#34;http://www.slf4j.org/faq.html#logging_performance&#34;&gt;最佳实践&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;logger.debug(&amp;quot;returning content: {}&amp;quot;, content);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一方面可以减少参数构造的开销，另一方面也不用多写两行代码；&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;有意义的日志&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通常情况下在程序日志里记录一些比较有意义的状态数据：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序启动，退出的时间点；&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;程序运行消耗时间；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;long startTime = System.currentTime();          &#xA;// business logical          &#xA;logger.info(&amp;quot;execution cost : &amp;quot; + (System.currentTime() - startTime) + &amp;quot;ms&amp;quot;);　      &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;耗时程序的执行进度，不然程序开始运行后半天没一点输出挺让人着急啊~&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;重要变量的状态变化。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;日志安全&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;日志中尽量不要包含敏感信息，对于敏感信息如用户身份证号码，密码可以加密后存储；以防止日志文件不慎外泄时保全用户的数据安全；日志通常不允许修改，必要时还可以通过校验位来鉴别日志是否正确。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志可靠性&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志监控方法&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;作业&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;参考链接&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org/manual.html&#34;&gt;http://www.slf4j.org/manual.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&#34;&gt;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wikipedia.org/wiki/syslog&#34;&gt;http://wikipedia.org/wiki/syslog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Pi和Github上搭建自己的个人博客</title>
      <link>http://hugozhu.myalert.info/2013/02/27/%E5%9C%A8Pi%E5%92%8CGithub%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;方法如下：&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;本站同时托管在家里的&lt;a href=&#34;http://www.raspberrypi.org&#34;&gt;Raspberry Pi&lt;/a&gt;和&lt;a href=&#34;http://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上，并同步保持更新，海外用户会访问Github，国内用户则会访问Pi，不同线路解析域名&lt;strong&gt;hugozhu.myalert.info&lt;/strong&gt;到不同的服务器是通过&lt;a href=&#34;http://dnspod.cn&#34;&gt;DnsPod&lt;/a&gt;的服务实现的，这么好的服务还是免费的，这里推荐一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为Github Pages只能支持静态网页，你需要一个能生成静态网页的博客生成引擎。我使用的是&lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor&lt;/a&gt; ， 也可以使用&lt;a href=&#34;http://ruhoh.com&#34;&gt;ruhoh&lt;/a&gt;，&lt;a href=&#34;https://www.google.com/search?q=static+blog+generator&amp;amp;hl=en&amp;amp;newwindow=1&amp;amp;client=safari&amp;amp;rls=en&amp;amp;biw=1238&amp;amp;bih=868&amp;amp;ei=msAuUY-vDMKO2AWQ7IHoBQ&amp;amp;sqi=2&amp;amp;start=10&amp;amp;sa=N&#34;&gt;Google一下还有很多&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;静态页面博客的好处：&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;性能是最好的，很合适用Raspberry Pi来做服务器，节省资源；&lt;/li&gt;&#xA;&lt;li&gt;文章可以用Markdown格式来编写，采用Github来做版本控制，我的Blog仓库在 &lt;a href=&#34;http://github.com/hugozhu/blog&#34;&gt;http://github.com/hugozhu/blog&lt;/a&gt; ，数据安全很好，误删除也不担心了；&lt;/li&gt;&#xA;&lt;li&gt;很容易找到托管环境，方便迁移；&lt;/li&gt;&#xA;&lt;li&gt;用Gor在Pi上生成速度很快；再用Nginx提供Web服务，可以直接在Pi上写Blog；&lt;/li&gt;&#xA;&lt;li&gt;大繁至简&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Github设置&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在你的仓库里增加一个your_github_id.github.com，比如我的github ID是hugozhu，相应的仓库名就是&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com&#34;&gt;hugozhu.github.com&lt;/a&gt;，这个仓库也就是网站的根目录了，在这里放生成好的静态文件&lt;/li&gt;&#xA;&lt;li&gt;如果你需要用自己的域名，而不是Github提供的，可以在根目录下增加一个&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com/blob/master/CNAME&#34;&gt;CNAME&lt;/a&gt;文件,文件内容则是你的域名，在DnsPod上需要建一个CNAME记录，将你的域名指向your_github_id.github.com. 也就是github原来分配给你的，完成这个设置后，访问your_github_id.github.com会跳转到你的域名；&lt;/li&gt;&#xA;&lt;li&gt;每次更新后，Github会在10分钟内生效。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;更新博客&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Gor的使用详细说明可见 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;我的整个网站的内容也通过Github开源了: &lt;a href=&#34;https://github.com/hugozhu/blog&#34;&gt;https://github.com/hugozhu/blog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;以我的网站为例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/hugozhu/blog&#xA;    Cloning into &#39;blog&#39;...&#xA;    remote: Counting objects: 190, done.&#xA;    remote: Compressing objects: 100% (146/146), done.&#xA;    remote: Total 190 (delta 81), reused 132 (delta 23)&#xA;    Receiving objects: 100% (190/190), 155.48 KiB | 171 KiB/s, done.&#xA;    Resolving deltas: 100% (81/81), done.&#xA;cd blog&#xA;gor compile&#xA;    2013/02/27 13:17:19 gor.go:21: gor ver 2.1&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : default&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : page&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : post&#xA;    2013/02/27 13:17:19 config.go:61: Look lile a Json, try it&#xA;    2013/02/27 13:17:19 config.go:64: It is Json Map&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/analytics/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/comments/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/google_prettify/config.yml&#xA;    2013/02/27 13:17:19 compile.go:125: Done&#xA;cd compiled&#xA;git init&#xA;git add -A &#xA;git commit -m &amp;quot;update website&amp;quot; .&#xA;git remote add origin hugozhu@github.com:hugozhu/hugozhu.github.com&#xA;git push -u origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后等待10分钟，再打开 &lt;a href=&#34;http://hugozhu.github.com&#34;&gt;http://hugozhu.github.com&lt;/a&gt; 就好了。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Raspberry Pi设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装nginx&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件：/etc/nginx/sites-enabled/default，增加下面内容&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;server {&#xA;    server_name hugozhu.myalert.info;&#xA;&#xA;    root /home/pi/blog/compiled;&#xA;&#xA;    location / {&#xA;        ssi on;&#xA;    }     &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;重新启动nginx，这样在Pi上也有一个你的个人博客了，方便自己访问，这里有个小小的技巧是可以通过server side include给静态页面增加动态内容，上面的配置在首页上打开了此功能，这样我可以在页底加上如下代码来显示访问者的IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--# echo var=&amp;quot;remote_addr&amp;quot; default=&amp;quot;no&amp;quot; --&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后重启Nginx生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/nginx restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;TODO:&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现一个简单的Web界面，可以通个Web界面来保存Blog，并重现编译和更新到Github；&lt;/li&gt;&#xA;&lt;li&gt;微博到博客的快速发布；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Github合作开发项目</title>
      <link>http://hugozhu.myalert.info/2013/02/27/collaborating-development-with-github.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文大部分内容来自： &lt;a href=&#34;https://help.github.com/categories/63/articles&#34;&gt;https://help.github.com/categories/63/articles&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Github上合作开发最好的方式是“&lt;strong&gt;Fork + Pull Request&lt;/strong&gt;”。比如我最近需要一个静态Blog生成器，市面上有很多Ruby实现的，但我想要一个Go语言的实现，Github上找到了一个 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt; ，测试了一下已有的功能基本能满足了，就用上了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但实际使用过程中发现了一个问题，如果在URL中有中文，生成的URL如下没有做URL安全编码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还有一种情况是如果URL中有空格，如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info//2013//02/25/Java properties to enviorment variables.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;浏览器遇到这种URL时，会主动进行编码，但这里有两个问题：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;遇到中文时，浏览器是用GBK还是UTF-8还是其它字符集编码后再发送给服务器呢？&lt;/li&gt;&#xA;&lt;li&gt;遇到空格时，编码成+还是%20呢？&#xA;不同浏览器实现可能不一样，在不同操作系统上也可能不一样（可能和用户设置的缺省语言有关），这样有些用户可能会遭遇404错误了，实际上我在服务器的错误日志上的确看到这样的错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;日志：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;2013/02/27 20:41:33 [error] 7791#0: *3285 open() &amp;quot;.../2013/02/25/Java+properties+to+enviorment+variables.html&amp;quot; failed (2: No such file or directory), client: 221.179.193.78, server: hugozhu.myalert.info, request: &amp;quot;GET /2013/02/25/Java+properties+to+enviorment+variables.html HTTP/1.1&amp;quot;, host: &amp;quot;hugozhu.myalert.info&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;于是我需要动手修改代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先需要做的就是Fork一下原项目到自己的代码仓库： &lt;a href=&#34;https://github.com/hugozhu/gor&#34;&gt;https://github.com/hugozhu/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;修改好代码并提交到自己的仓库： &lt;a href=&#34;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&#34;&gt;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;在你的代码仓库页面上点Pull Request:&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BEH7V0vCYAAMgcl.jpg:large&#34;/&gt;&lt;/li&gt;&#xA;&lt;li&gt;选择好你刚提交好的Commits，然后点发送;&lt;/li&gt;&#xA;&lt;li&gt;原项目的维护者就会收到这个Pull Request: &lt;a href=&#34;https://github.com/wendal/gor/pull/14&#34;&gt;https://github.com/wendal/gor/pull/14&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果你提交的代码足够好，维护者可以合并到项目主干上；&lt;/li&gt;&#xA;&lt;li&gt;记住下一次本地修改代码前要先Merge一下原作者新提交的改动;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote add upstream https://github.com/wendal/gor&#xA;git fetch upstream&#xA;git checkout master&#xA;git merge upstream/master &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;到此为止就完成了一次合作开发。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;==&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;我们日常的项目开发中也可以采用这种思路，代码Review也可以增加Pull Request，对项目的迭代速度会有很大帮助。&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>动态DNS程序</title>
      <link>http://hugozhu.myalert.info/2013/02/26/dynamic-dns-script.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;动态根据宽带public ip更新dnspod登记的域名&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;按照 &lt;a href=&#34;https://gist.github.com/833369&#34;&gt;https://gist.github.com/833369&lt;/a&gt; 逻辑重新用Go实现了，用更少的内存开销在Raspberry Pi上跑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;替换上你的Email，密码，域名ID，记录ID等参数，就可以运行了。 会在后台一直运行，每隔30秒检查一遍IP，如果修改了就更新IP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获得domain_id可以用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl curl -k https://dnsapi.cn/Domain.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;获得record_id：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -k https://dnsapi.cn/Record.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;  &amp;quot;io/ioutil&amp;quot;&#xA;  &amp;quot;log&amp;quot;&#xA;  &amp;quot;net&amp;quot;&#xA;  &amp;quot;net/http&amp;quot;&#xA;  &amp;quot;net/url&amp;quot;&#xA;  &amp;quot;strings&amp;quot;&#xA;  &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;var (&#xA;    body = url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {&amp;quot;email&amp;quot;},&#xA;        &amp;quot;login_password&amp;quot;: {&amp;quot;password&amp;quot;},&#xA;        &amp;quot;format&amp;quot;:         {&amp;quot;json&amp;quot;},&#xA;        &amp;quot;domain_id&amp;quot;:      {&amp;quot;0&amp;quot;},&#xA;        &amp;quot;record_id&amp;quot;:      {&amp;quot;0&amp;quot;},&#xA;        &amp;quot;sub_domain&amp;quot;:     {&amp;quot;www&amp;quot;},&#xA;        &amp;quot;record_line&amp;quot;:    {&amp;quot;默认&amp;quot;},&#xA;    }&#xA;    current_ip     = &amp;quot;&amp;quot;&#xA;    check_interval = 30 * time.Second&#xA;)&#xA;&#xA;var current_ip = &amp;quot;&amp;quot;&#xA;&#xA;func get_public_ip() (string, error) {&#xA;    conn, err := net.DialTimeout(&amp;quot;tcp&amp;quot;, &amp;quot;ns1.dnspod.net:6666&amp;quot;, timeout*time.Second)&#xA;    defer func() {&#xA;        if x := recover(); x != nil {&#xA;            log.Println(&amp;quot;Can&#39;t get public ip&amp;quot;, x)&#xA;        }&#xA;        if conn!=nil {&#xA;            conn.Close()&#xA;        }&#xA;    }()&#xA;&#xA;    if err == nil {&#xA;        var bytes []byte&#xA;        deadline := time.Now().Add(timeout*time.Second)&#xA;        err = conn.SetDeadline(deadline)&#xA;        if err!=nil {&#xA;            return &amp;quot;&amp;quot;, err&#xA;        }&#xA;        bytes, err = ioutil.ReadAll(conn)&#xA;        if err == nil {&#xA;            return string(bytes), nil&#xA;        }&#xA;    }&#xA;    return &amp;quot;&amp;quot;, err&#xA;}&#xA;&#xA;func timeoutDialler(timeout time.Duration) func(net, addr string) (c net.Conn, err error) {&#xA;    return func(netw, addr string) (net.Conn, error) {&#xA;        c, err := net.DialTimeout(netw, addr, timeout)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        deadline := time.Now().Add(timeout)&#xA;        err = c.SetDeadline(deadline)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        return c, nil&#xA;    }&#xA;}&#xA;&#xA;func update_dnspod(ip string) bool {&#xA;    client := &amp;amp;http.Client{&#xA;        Transport: &amp;amp;http.Transport{&#xA;            Dial: timeoutDialler(timeout * time.Second),&#xA;        },&#xA;    }&#xA;    body := url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {login_email},&#xA;        &amp;quot;login_password&amp;quot;: {login_password},&#xA;        &amp;quot;format&amp;quot;:         {format},&#xA;        &amp;quot;domain_id&amp;quot;:      {domain_id},&#xA;        &amp;quot;record_id&amp;quot;:      {record_id},&#xA;        &amp;quot;sub_domain&amp;quot;:     {sub_domain},&#xA;        &amp;quot;record_line&amp;quot;:    {record_line},&#xA;        &amp;quot;value&amp;quot;:          {ip},&#xA;    }&#xA;&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, &amp;quot;https://dnsapi.cn/Record.Ddns&amp;quot;, strings.NewReader(body.Encode()))&#xA;    req.Header.Set(&amp;quot;Accept&amp;quot;, &amp;quot;text/json&amp;quot;)&#xA;    req.Header.Set(&amp;quot;Content-type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)&#xA;&#xA;    resp, err := client.Do(req)&#xA;&#xA;    defer resp.Body.Close()&#xA;&#xA;    if err != nil {&#xA;        return false&#xA;    }&#xA;    bytes, _ := ioutil.ReadAll(resp.Body)&#xA;    log.Println(string(bytes))&#xA;    return resp.StatusCode == 200&#xA;}&#xA;&#xA;func init() {&#xA;}&#xA;&#xA;func main() {&#xA;    for {&#xA;        ip, err := get_public_ip()&#xA;        if ip != &amp;quot;&amp;quot; &amp;amp;&amp;amp; err == nil {&#xA;            log.Println(&amp;quot;got ip:&amp;quot; + ip)&#xA;            if ip != current_ip {&#xA;                log.Println(&amp;quot;update dnspod with new ip:&amp;quot; + ip)&#xA;                if update_dnspod(ip) {&#xA;                    current_ip = ip&#xA;                }&#xA;            }&#xA;        } else {&#xA;            log.Println(&amp;quot;error:&amp;quot;, err)&#xA;        }&#xA;        time.Sleep(interval * time.Second)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>系统调试和分析工具</title>
      <link>http://hugozhu.myalert.info/2013/02/26/linux_perf_tools.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux下的调试和分析工具集&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/tools.jpg&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Java properties to enviorment variables</title>
      <link>http://hugozhu.myalert.info/2013/02/25/Java%20properties%20to%20enviorment%20variables.html</link>
      <pubDate>2013-02-25 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;将Java的Properties文件导出成环境变量&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;比如env.properties如下（=附近可以有空格，也可以有空行）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&#xA;MYSQL_USER = root&#xA;MYSQL_PASS = &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面的脚本后就相当于&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export MYSQL_URL=&amp;quot;//localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;quot;&#xA;export MYSQL_USER=&amp;quot;root&amp;quot;&#xA;export MYSQL_PASS=&amp;quot;&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;env.sh脚本代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;property_file=env.properties&#xA;&#xA;get_prop(){&#xA;    propfile=$1&#xA;    key=$2&#xA;    grep  &amp;quot;^${2}=&amp;quot; ${1}| sed &amp;quot;s%${2}=\(.*\)%\1%&amp;quot;&#xA;}&#xA;&#xA;trim() {&#xA;    trimmed=$1&#xA;    trimmed=${trimmed%% }&#xA;    trimmed=${trimmed## }&#xA;    echo &amp;quot;$trimmed&amp;quot;&#xA;}&#xA;&#xA;`grep -v &amp;quot;^#&amp;quot; $property_file | sed -e &#39;/^$/d&#39; | while read line&#xA;do&#xA;    key=$(echo $line | awk -F &amp;quot;=&amp;quot; &#39;{print $1}&#39;)&#xA;    trimmed_key=$(trim $key)&#xA;    trimmed_val=$(trim $(get_prop $property_file &amp;quot;$key&amp;quot;)&#xA;    echo &amp;quot;export $trimmed_key=\&amp;quot;$trimmed_val\&amp;quot;)&amp;quot;&#xA;done`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>http://hugozhu.myalert.info/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>