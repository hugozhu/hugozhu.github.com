<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Hugo Zhu</title>
    <link>http://hugozhu.myalert.info</link>
    <pubDate>2013-03-07 10:12:57 +0800</pubDate>
    <item>
      <title>Raspberry Pi做BT下载机+高清播放器</title>
      <link>http://hugozhu.myalert.info/2013/03/06/raspberry-pi-with-xmbc.html</link>
      <pubDate>2013-03-06 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先高清播放器功能只是Raspberry Pi的一个小功能，如果你只需要高清播放功能又不想折腾，那还是买个&lt;a href=&#34;http://s.taobao.com/search?q=%B8%DF%C7%E5%B2%A5%B7%C5%C6%F7&amp;amp;commend=all&amp;amp;ssid=s5-e&amp;amp;search_type=item&amp;amp;sourceId=tb.index&amp;amp;initiative_id=tbindexz_20130306&#34;&gt;山寨的&lt;/a&gt;的更简单。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Raspberry Pi的图形处理器规格：Broadcom VideoCore IV, OpenGL ES 2.0, 1080p 30 h.264/MPEG-4 AVC 高清解码器，内存和CPU共享（可设置成256M），性能还是很强劲的。HDMI支持640x350和1920×1200（1080P）的分辨率。安装了&lt;a href=&#34;http://xbmc.org&#34;&gt;XBMC&lt;/a&gt;，基本上可以实现包括Airplay在内的Apple TV上的大部分功能，但价格只有其一半不到，可以播放下载的视频或观看在线视频，如&lt;a href=&#34;http://yisou.com&#34;&gt;一搜&lt;/a&gt;，优酷，搜狐视频，奇艺等。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;外设&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;除了Pi单片机外，你还需要以下外设附件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;5V-1A左右的电源，可以用iPhone或iPad的充电电源，或手机的充电器，电流最少要800毫安&lt;/li&gt;&#xA;&lt;li&gt;micro USB线一根，和Kindle以及大多数android手机充电USB线一样&lt;/li&gt;&#xA;&lt;li&gt;HDMI线一根，接电视机&lt;/li&gt;&#xA;&lt;li&gt;SD卡一张，最少2G&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Raspbmc&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.raspbmc.com/&#34;&gt;Raspbmc&lt;/a&gt; 是专为在Raspberry Pi上运行&lt;a href=&#34;http://xbmc.org&#34;&gt;XBMC&lt;/a&gt;的定制Linux。最小化的安装，减少了不必要的软件和资源占用，简化了安装和配置，没有Linux知识也可以上手。这个版本的维护者是一个19岁的小朋友Sam Nazarko。有时间折腾的同学可以自己编译XMBC安装。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;特点：&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;免费，开源&lt;/li&gt;&#xA;&lt;li&gt;支持多语言&lt;/li&gt;&#xA;&lt;li&gt;支持1080P回放&lt;/li&gt;&#xA;&lt;li&gt;支持直接播放NFS，SMB，FTP,HTTP或USB硬盘的有视频文件，支持大多数格式&lt;/li&gt;&#xA;&lt;li&gt;支持AirPlay或AirTune功能，可以把iPhone/iPad上的视频或音乐通过Pi投放到电视上，这点和Apple TV功能一样&lt;/li&gt;&#xA;&lt;li&gt;支持GPIO&lt;/li&gt;&#xA;&lt;li&gt;基于Debian，可以从Debian的软件源安装其它软件&lt;/li&gt;&#xA;&lt;li&gt;支持1080P DTS软解，这个不少播放器是不支持的，需要额外License&lt;/li&gt;&#xA;&lt;li&gt;内置了以下服务:&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Samba&lt;/li&gt;&#xA;&lt;li&gt;TVHeadend Server&lt;/li&gt;&#xA;&lt;li&gt;FTP Server&lt;/li&gt;&#xA;&lt;li&gt;SSH Server&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;安装&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Windows下载&lt;a href=&#34;http://download.raspbmc.com/downloads/bin/installers/raspbmc-win32.zip&#34;&gt;安装程序&lt;/a&gt;，运行即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.raspbmc.com/wp-content/uploads/2012/06/ins-300x165.jpg&#34; alt=&#34;image&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Linux/Mac:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -O http://svn.stmlabs.com/svn/raspbmc/testing/installers/python/install.py&#xA;chmod +x install.py&#xA;sudo python install.py&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.raspbmc.com/wp-content/uploads/2012/06/installPython.png&#34; alt=&#34;image&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;或直接下载&lt;a href=&#34;http://download.raspbmc.com/downloads/bin/ramdistribution/installer.img.gz&#34;&gt;安装包&lt;/a&gt;安装&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;下载&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;你可以在Pi上外接一个USB移动硬盘，但要注意硬盘要有自己电源，也可以mount网络上的硬盘分区。然后运行transmission软件下载视频。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Transmission&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install transmission-daemon&#xA;sudo /etc/init.d/transmission-daemon stop&#xA;sudo nano /etc/transmission-daemon/settings.json&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    “rpc-whitelist”: “127.0.0.1″, to “rpc-whitelist”: “*.*.*.*”,&#xA;    “rpc-password”: “password”, to “rpc-password”: “替换成管理密码“,&#xA;    “rpc-username”: “username”, to “rpc-username”: “替换成管理用户“,   &#xA;    “download-dir”：“\/home\/xbmc\/Videos\/Downloads”,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    sudo chmod g+rw /home/xbmc/Videos/Downloads&#xA;    sudo chgrp -R debian-transmission /home/xbmc/Videos/Downloads   &#xA;    sudo /etc/init.d/transmission-daemon start&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;24x7开始下载，耗电量很低的，这是下载界面：&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BErnJ-6CcAEVYsV.jpg:large&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;遥控和播放&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;遥控方案有两种：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;红外接收器 + 电视/DVD/VCD/EVD等已有遥控器，&lt;a href=&#34;http://forum.stmlabs.com/showthread.php?tid=5549&#34;&gt;这里&lt;/a&gt;有一个实现方案&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;通过网络用手机来遥控，其实就是用任何一个xmbc的客户端&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;iPhone: &lt;a href=&#34;https://itunes.apple.com/us/app/unofficial-official-xbmc-remote/id520480364?ls=1&amp;amp;mt=8&#34;&gt;Offical XBMC Remote&lt;/a&gt; 免费的&lt;/li&gt;&#xA;&lt;li&gt;Android: &lt;a href=&#34;http://code.google.com/p/android-xbmcremote/&#34;&gt;Android XBMC Remote&lt;/a&gt; 免费的&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;参考文章:&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.raspbmc.com/about/&#34;&gt;http://www.raspbmc.com/about/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Java并发包中的同步队列SynchronousQueue实现原理</title>
      <link>http://hugozhu.myalert.info/2013/03/05/java-SynchronousQueue-notes.html</link>
      <pubDate>2013-03-05 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java 6的并发编程包中的&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html&#34;&gt;SynchronousQueue&lt;/a&gt;是一个没有数据缓冲的&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/BlockingQueue.html&#34;&gt;BlockingQueue&lt;/a&gt;，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的&lt;strong&gt;线程&lt;/strong&gt;，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后&lt;strong&gt;一起&lt;/strong&gt;离开。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;实现原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;同步队列的实现方法有许多：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;阻塞算法实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;阻塞算法实现通常在内部采用一个锁来保证多个线程中的put()和take()方法是串行执行的。采用锁的开销是比较大的，还会存在一种情况是线程A持有线程B需要的锁，B必须一直等待A释放锁，即使A可能一段时间内因为B的优先级比较高而得不到时间片运行。所以在高性能的应用中我们常常希望规避锁的使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class NativeSynchronousQueue&amp;lt;E&amp;gt; {&#xA;    boolean putting = false;&#xA;    E item = null;&#xA;&#xA;    public synchronized E take() throws InterruptedException {&#xA;        while (item == null)&#xA;            wait();&#xA;        E e = item;&#xA;        item = null;&#xA;        notifyAll();&#xA;        return e;&#xA;    }&#xA;&#xA;    public synchronized void put(E e) throws InterruptedException {&#xA;        if (e==null) return;&#xA;        while (putting)&#xA;            wait();&#xA;        putting = true;&#xA;        item = e;&#xA;        notifyAll();&#xA;        while (item!=null)&#xA;            wait();&#xA;        putting = false;&#xA;        notifyAll();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;信号量实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;经典同步队列实现采用了三个信号量，代码很简单，比较容易理解：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class SemaphoreSynchronousQueue&amp;lt;E&amp;gt; {&#xA;    E item = null;&#xA;    Semaphore sync = new Semaphore(0);&#xA;    Semaphore send = new Semaphore(1);&#xA;    Semaphore recv = new Semaphore(0);&#xA;&#xA;    public E take() throws InterruptedException {&#xA;        recv.acquire();&#xA;        E x = item;&#xA;        sync.release();&#xA;        send.release();&#xA;        return x;&#xA;    }&#xA;&#xA;    public void put (E x) throws InterruptedException{&#xA;        send.acquire();&#xA;        item = x;&#xA;        recv.release();&#xA;        sync.acquire();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在多核机器上，上面方法的同步代价仍然较高，操作系统调度器需要上千个时间片来阻塞或唤醒线程，而上面的实现即使在生产者put()时已经有一个消费者在等待的情况下，阻塞和唤醒的调用仍然需要。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 5实现&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Java5SynchronousQueue&amp;lt;E&amp;gt; {&#xA;    ReentrantLock qlock = new ReentrantLock();&#xA;    Queue waitingProducers = new Queue();&#xA;    Queue waitingConsumers = new Queue();&#xA;    &#xA;    static class Node extends AbstractQueuedSynchronizer {&#xA;        E item;&#xA;        Node next;&#xA;        &#xA;        Node(Object x) { item = x; }&#xA;        void waitForTake() { /* (uses AQS) */ }&#xA;           E waitForPut() { /* (uses AQS) */ }&#xA;    }&#xA;    &#xA;    public E take() {&#xA;        Node node;&#xA;        boolean mustWait;&#xA;        qlock.lock();&#xA;        node = waitingProducers.pop();&#xA;        if(mustWait = (node == null))&#xA;           node = waitingConsumers.push(null);&#xA;         qlock.unlock();&#xA;    &#xA;        if (mustWait)&#xA;           return node.waitForPut();&#xA;        else&#xA;            return node.item;&#xA;    }&#xA;    &#xA;    public void put(E e) {&#xA;         Node node;&#xA;         boolean mustWait;&#xA;         qlock.lock();&#xA;         node = waitingConsumers.pop();&#xA;         if (mustWait = (node == null))&#xA;             node = waitingProducers.push(e);&#xA;         qlock.unlock();&#xA;        &#xA;         if (mustWait)&#xA;             node.waitForTake();&#xA;         else&#xA;            node.item = e;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Java 5的实现相对来说做了一些优化，只使用了一个锁，使用队列代替信号量也可以允许发布者直接发布数据，而不是要首先从阻塞在信号量处被唤醒。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java6实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java 6的SynchronousQueue的实现采用了一种性能更好的&lt;strong&gt;无锁算法&lt;/strong&gt; &amp;ndash; 扩展的“&lt;a href=&#34;http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html&#34;&gt;Dual stack and Dual queue&lt;/a&gt;”算法。性能比Java5的实现有较大提升。竞争机制支持公平和非公平两种：非公平竞争模式使用的数据结构是后进先出栈(Lifo Stack)；公平竞争模式则使用先进先出队列（Fifo Queue），性能上两者是相当的，一般情况下，Fifo通常可以支持更大的吞吐量，但Lifo可以更大程度的保持线程的本地化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码实现里的Dual Queue或Stack内部是用链表(LinkedList)来实现的，其节点状态为以下三种情况：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;持有数据 - put()方法的元素&lt;/li&gt;&#xA;&lt;li&gt;持有请求 - take()方法&lt;/li&gt;&#xA;&lt;li&gt;空&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;这个算法的特点就是任何操作都可以根据节点的状态判断执行，而不需要用到锁。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其核心接口是Transfer，生产者的put或消费者的take都使用这个接口，根据第一个参数来区别是入列（栈）还是出列（栈）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    /**&#xA;     * Shared internal API for dual stacks and queues.&#xA;     */&#xA;    static abstract class Transferer {&#xA;        /**&#xA;         * Performs a put or take.&#xA;         *&#xA;         * @param e if non-null, the item to be handed to a consumer;&#xA;         *          if null, requests that transfer return an item&#xA;         *          offered by producer.&#xA;         * @param timed if this operation should timeout&#xA;         * @param nanos the timeout, in nanoseconds&#xA;         * @return if non-null, the item provided or received; if null,&#xA;         *         the operation failed due to timeout or interrupt --&#xA;         *         the caller can distinguish which of these occurred&#xA;         *         by checking Thread.interrupted.&#xA;         */&#xA;        abstract Object transfer(Object e, boolean timed, long nanos);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;TransferQueue实现如下(摘自Java 6源代码)，入列和出列都基于Spin和CAS方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        /**&#xA;         * Puts or takes an item.&#xA;         */&#xA;        Object transfer(Object e, boolean timed, long nanos) {&#xA;            /* Basic algorithm is to loop trying to take either of&#xA;             * two actions:&#xA;             *&#xA;             * 1. If queue apparently empty or holding same-mode nodes,&#xA;             *    try to add node to queue of waiters, wait to be&#xA;             *    fulfilled (or cancelled) and return matching item.&#xA;             *&#xA;             * 2. If queue apparently contains waiting items, and this&#xA;             *    call is of complementary mode, try to fulfill by CAS&#39;ing&#xA;             *    item field of waiting node and dequeuing it, and then&#xA;             *    returning matching item.&#xA;             *&#xA;             * In each case, along the way, check for and try to help&#xA;             * advance head and tail on behalf of other stalled/slow&#xA;             * threads.&#xA;             *&#xA;             * The loop starts off with a null check guarding against&#xA;             * seeing uninitialized head or tail values. This never&#xA;             * happens in current SynchronousQueue, but could if&#xA;             * callers held non-volatile/final ref to the&#xA;             * transferer. The check is here anyway because it places&#xA;             * null checks at top of loop, which is usually faster&#xA;             * than having them implicitly interspersed.&#xA;             */&#xA;&#xA;            QNode s = null; // constructed/reused as needed&#xA;            boolean isData = (e != null);&#xA;&#xA;            for (;;) {&#xA;                QNode t = tail;&#xA;                QNode h = head;&#xA;                if (t == null || h == null)         // saw uninitialized value&#xA;                    continue;                       // spin&#xA;&#xA;                if (h == t || t.isData == isData) { // empty or same-mode&#xA;                    QNode tn = t.next;&#xA;                    if (t != tail)                  // inconsistent read&#xA;                        continue;&#xA;                    if (tn != null) {               // lagging tail&#xA;                        advanceTail(t, tn);&#xA;                        continue;&#xA;                    }&#xA;                    if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0)        // can&#39;t wait&#xA;                        return null;&#xA;                    if (s == null)&#xA;                        s = new QNode(e, isData);&#xA;                    if (!t.casNext(null, s))        // failed to link in&#xA;                        continue;&#xA;&#xA;                    advanceTail(t, s);              // swing tail and wait&#xA;                    Object x = awaitFulfill(s, e, timed, nanos);&#xA;                    if (x == s) {                   // wait was cancelled&#xA;                        clean(t, s);&#xA;                        return null;&#xA;                    }&#xA;&#xA;                    if (!s.isOffList()) {           // not already unlinked&#xA;                        advanceHead(t, s);          // unlink if head&#xA;                        if (x != null)              // and forget fields&#xA;                            s.item = s;&#xA;                        s.waiter = null;&#xA;                    }&#xA;                    return (x != null)? x : e;&#xA;&#xA;                } else {                            // complementary-mode&#xA;                    QNode m = h.next;               // node to fulfill&#xA;                    if (t != tail || m == null || h != head)&#xA;                        continue;                   // inconsistent read&#xA;&#xA;                    Object x = m.item;&#xA;                    if (isData == (x != null) ||    // m already fulfilled&#xA;                        x == m ||                   // m cancelled&#xA;                        !m.casItem(x, e)) {         // lost CAS&#xA;                        advanceHead(h, m);          // dequeue and retry&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    advanceHead(h, m);              // successfully fulfilled&#xA;                    LockSupport.unpark(m.waiter);&#xA;                    return (x != null)? x : e;&#xA;                }&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;参考文章&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html&#34;&gt;Javadoc of SynchronousQueue&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf&#34;&gt;Scalable Synchronous Queues&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html&#34;&gt;Nonblocking Concurrent Data Structures with Condition Synchronization&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN使用多个端口</title>
      <link>http://hugozhu.myalert.info/2013/03/02/openvpn-multiple-ports.html</link>
      <pubDate>2013-03-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Openvpn本身不能设置多个端口，使用iptables可以解决这个问题 （假设openvpn本来56788端口）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for port in {56780..56787}&#xA;do &#xA;    iptables -t nat -A PREROUTING -p tcp -d &amp;lt;your_external_ip&amp;gt; --dport $port -j REDIRECT --to-port 56788&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java的资源管理</title>
      <link>http://hugozhu.myalert.info/2013/03/01/resource-management-in-java.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;try-catch-finally&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &amp;ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如&lt;a href=&#34;http://findbugs.sourceforge.net&#34;&gt;&lt;strong&gt;FindBugs&lt;/strong&gt;&lt;/a&gt;可以帮助发现此类问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先我们来看一段文件操作代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String from, String to) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    in = new FileInputStream(from);  &#xA;    out = new FileOutputStream(to);  &#xA;    int c;  &#xA;    while ((c = in.read()) != -1)&#xA;        out.write(c);  &#xA;    in.close();&#xA;    out.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-&lt;a href=&#34;http://zh.wikipedia.org/wiki/文件描述符&#34;&gt;文件描述符&lt;/a&gt;，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/File_descriptor&#34;&gt;File descriptor&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://pbs.twimg.com/media/BEUt3v3CEAAeP-m.jpg:large&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;较为正确的代码应该是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);&#xA;    } finally {&#xA;         try {&#xA;             if (in!=null) {&#xA;                in.close();&#xA;             }&#xA;         } finally {&#xA;             if (out!=null) {&#xA;                out.close();&#xA;             }&#xA;         }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是这样的代码写起来是不是让人有点沮丧？这样写代码犯错的可能性确实比较大。&#xA;改良过后的代码阅读性好一些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;    } finally {&#xA;        FileUtils.close(in);&#xA;        FileUtils.close(out);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让我们也看看在其他语言里是怎么实现的：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Ruby：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def copy(src, dest)&#xA;    File.open(dest, &#39;w&#39;) do |f|  &#xA;        f.write(File.read(src))&#xA;    end  &#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Ruby的File.open 方法接受一个函数作为参数，执行该函数后，会保证打开的文件被关闭，即使在执行函数过程中有异常。相比之下这种代码优美多了有没有？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Golang：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func copy(src string, dest string) {&#xA;    src_file, err := os.Open(src)&#xA;    if err != nil { panic(err) }&#xA;    defer src_file.Close()&#xA;&#xA;    dest_file, err := os.Open(dest)&#xA;    if err != nil { panic(err) }&#xA;    defer dest_file.Close() &#xA;&#xA;    buf := make([]byte,1024)&#xA;&#xA;    for {&#xA;        n, err := src_file.Read(buf)&#xA;        if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;        if n == 0 {break}&#xA;&#xA;        if _, err:= dest_file.Write(buf[:n]); err != nil {&#xA;           panic(err)&#xA;        } &#xA;    }       &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Go语言通过defer关键词来保证程序结束时相应的方法会被调用，嗯，你还是要显示的写Close()方法，但有一点改进就是你可以在打开后立刻写关闭语句，只要加上defer关键词。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Clojure：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defn copy[src dest] ( &#xA;   (with-open [rdr (reader src)&#xA;               wrtr (writer dest)]&#xA;      (doseq [line (line-seq rdr)]&#xA;          (.write wrtr line))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Clojure通过with-open函数来保证打开的文件在异常情况下也会被关闭&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 7：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try (FileInputStream in = new FileInputStream(src);  &#xA;         FileOutputStream out = new FileOutputStream(dest)) {            &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;终于Java 7通过自动资源管理较好的解决了这个问题，try()代码块内的变量在离开时候会自动调用AutoCloseable接口必须实现的close()方法。java.lang.AutoCloseable接口是在Java 7内新增的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;独占资源和并发访问&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;锁&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;读写锁&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;信号量&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;连接池&lt;/h3&gt;&#xA;&#xA;&lt;h2&gt;作业&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考链接&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/trywithresources-401775.html&#34;&gt;Better Resource Management with Java SE 7: Beyond Syntactic Sugar&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在Ubuntu上配置L2TP，PPTP和OpenVPN服务</title>
      <link>http://hugozhu.myalert.info/2013/03/01/setup-l2tp-pptp-openvpn-on-ubuntu.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;MacOS, Windows, iOS都内置支持PPTP，L2TP；OpenVPN需要安装客户端，手机上一般不支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先打开内核的IP转发，修改 /etc/sysctl.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面命令以生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;PPTP&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装pptpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install pptpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/pptpd.conf，下面两行取消注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这行注释掉&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#logwtmp &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从文件 /etc/pptpd.conf 中找到配置选项文件，如下为：/etc/ppp/pptpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;grep options /etc/pptpd.conf&#xA;#       Specifies the location of the PPP options file.&#xA;#       By default PPP looks in &#39;/etc/ppp/options&#39;&#xA;option /etc/ppp/pptpd-options&#xA;#       option in the pppd options file, or run bcrelay.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/ppp/pptpd-options，增加以下内容，最后两项为推给VPN客户端的DNS服务器IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mtu 1492&#xA;name pptpd&#xA;refuse-pap&#xA;refuse-chap&#xA;refuse-mschap&#xA;require-mschap-v2&#xA;require-mppe-128&#xA;proxyarp&#xA;lock&#xA;nobsdcomp&#xA;novj&#xA;novjccomp&#xA;nologfd &#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    pptpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE&#xA;iptables -A INPUT -i lo -j ACCEPT&#xA;iptables -A INPUT -i tap+ -j ACCEPT&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tap+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -P FORWARD ACCEPT    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;L2TP Over IPSec&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;假设你的服务器IP是：&lt;strong&gt;1.2.3.4&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先更新一下源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装openswan&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openswan&#xA;&#xA;sudo cp /etc/ipsec.d/examples/l2tp-psk.conf /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件 /etc/ipsec.d/l2tp-psk.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;left=1.2.3.4 #机器的外部IP&#xA;leftnexthop=1.2.3.1 #机器的Gateway&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.conf，在文件最后增加：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;include /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.secrets&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.2.3.4 %any: &amp;quot;yourSharedPSK!&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装 xl2tpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install xl2tpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/xl2tpd/xl2tpd.conf , 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[global]&#xA;ipsec saref = yes&#xA;listen-addr = 1.2.3.4&#xA;&#xA;[lns default]&#xA;ip range = 192.168.1.10-192.168.1.20&#xA;local ip = 192.168.1.1&#xA;;require chap = yes&#xA;refuse chap = yes&#xA;refuse pap = yes&#xA;require authentication = yes&#xA;ppp debug = yes&#xA;pppoptfile = /etc/ppp/xl2tpd-options&#xA;length bit = yes    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cp /etc/ppp/options /etc/ppp/xl2tpd-options&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;asyncmap 0&#xA;auth&#xA;crtscts&#xA;lock&#xA;hide-password&#xA;modem&#xA;mru 1280&#xA;netmask 255.255.255.0&#xA;mtu 1280&#xA;name l2tpd&#xA;proxyarp&#xA;lcp-echo-interval 30&#xA;lcp-echo-failure 4&#xA;noipx&#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    l2tpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）, 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -A INPUT -p 50 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 500 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 4500 -j ACCEPT&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;OpenVPN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装Openvpn&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openvpn    &#xA;&#xA;cp -r /usr/share/doc/openvpn/examples/easy-rsa/ /etc/openvpn/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成CA证书&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/openvpn/easy-rsa/2.0&#xA;source vars&#xA;./clean-all&#xA;./build-ca&#xA;./build-key-server server&#xA;./build-key client&#xA;./build-dh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑/etc/openvpn/server.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;local 116.251.211.71    &#xA;port 56788    &#xA;proto tcp    &#xA;dev tun&#xA;ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt&#xA;cert /etc/openvpn/easy-rsa/2.0/keys/server.crt&#xA;key /etc/openvpn/easy-rsa/2.0/keys/server.key      &#xA;dh  /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem    &#xA;server 10.8.0.0 255.255.255.0    &#xA;ifconfig-pool-persist ipp.txt&#xA;push &amp;quot;redirect-gateway def1&amp;quot;    &#xA;push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;    &#xA;client-to-client&#xA;keepalive 10 120&#xA;comp-lzo    &#xA;max-clients 50    &#xA;user nobody&#xA;group nogroup    &#xA;persist-key&#xA;persist-tun    &#xA;status openvpn-status.log    &#xA;log-append  openvpn.log    &#xA;verb 3    &#xA;mute 20    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;设置iptable，其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE&#xA;&#xA;iptables -A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT&#xA;iptables -t nat -A PREROUTING -p udp -m udp --dport 53 -j DNAT --to-destination 8.8.8.8&#xA;&#xA;iptables -A INPUT -p udp --dport 1194 -j ACCEPT&#xA;iptables -A INPUT -s 10.8.0.0/24 -p all -j ACCEPT&#xA;iptables -A FORWARD -d 10.8.0.0/24 -j ACCEPT&#xA;&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to-source 1.2.3.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在线广告系统架构变迁</title>
      <link>http://hugozhu.myalert.info/2013/02/28/the-evolution-of-online-advertsing-system.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;（未完）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;广告按业务划分有以下几类：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;展示广告（Banner广告）&lt;/li&gt;&#xA;&lt;li&gt;搜索广告（关键词广告）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;按计费模式有：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;CPT: 按有效广告展示天数计费，可定价或竞价；&lt;/li&gt;&#xA;&lt;li&gt;CPM: 按有效广告展现次数计费，可定价或竞价；&lt;/li&gt;&#xA;&lt;li&gt;CPC: 按有效点击次数计费；&lt;/li&gt;&#xA;&lt;li&gt;CPS: 按效果计费，如，按成交订单额，按流量带来的有效下载或安装次数计费；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;广告系统按结构可划分为以下子系统：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;广告投送服务器&lt;/li&gt;&#xA;&lt;li&gt;广告数据库及业务系统&lt;/li&gt;&#xA;&lt;li&gt;用户行为跟踪系统&lt;/li&gt;&#xA;&lt;li&gt;日志传输系统&lt;/li&gt;&#xA;&lt;li&gt;流式数据分析和计算平台&lt;/li&gt;&#xA;&lt;li&gt;离线数据分析和计算平台&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;从展示广告到搜索广告再到社会化广告&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;早期的互联网广告以展示广告为主，业务模式和在报纸，期刊上刊登广告相似，广告主按其广告的展现次数或时长来付费。直到1998年有个叫GoTo的公司（后公司改名为Overture，2005年被Yahoo收购）开始提供关键词广告，这是一种简单高效的定向广告，广告主可以按与其业务相关的关键词购买搜索流量，按访客的点击计费，和早期的展示广告相比这无疑是一个巨大的进步，通过关键词将用户和广告关联起来，而不是在广告位上一直展现同样的广告或随机的展现。随后Google迅速的采用了这个方法将自身的搜索流量变现，并不断优化和壮大，最终形成了Google的Adword产品，早期Google并不为搜索用户建立个性化数据，因此可用于定向的数据比较有限，于是Google又推出了AdSense产品，将触角伸向了全网，通过AdSense的合作网站，Google可以采集到访客在这些网站的访问足迹，并利用这些数据提高其广告的相关性；随着以Facebook为代表的社交网络的兴起，这些网站有个特点就是自身就具备了比较完善的用户个性化数据，利用这些数据，网站可以将定向技术使用到展示广告，这使展示广告迎来了第二春，广告产业对数据的应用价值有了极大的兴趣，也催化了大数据的技术广泛应用。近年来一种新的广告业务模式&amp;ndash;“实时竞价广告交易系统”也逐渐被网站主和广告主接受，其核心目的是让每次广告展现都创造出尽可能多的回报，以自动化的方式系统使用实时数据和竞价信息将广告空间分配给那一时刻出价最高的销售渠道。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;广告系统的架构变迁&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;早期的展示广告系统因为业务数据量不大，广告位按时长售卖。系统架构上比较简单。系统核心为关系数据库，广告主通过业务系统管理广告数据：账户设置，广告计划，预算，推广单元，广告创意等；通过审核后可以投放的数据进入广告投放服务器。简单的广告系统可以完全围绕数据库来实现。投放服务器直接访问数据库获取需要投放的广告数据，并通过缓存来提高性能，减少对数据库的压力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图[简单的广告系统架构]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当广告系统里的广告主越来越多，广告位的流量越来越大，直接访问数据库的做法不能满足性能和扩展性的要求，主要原因是传统的关系数据库的设计目标是通用的需求。这种情况下广告系统可以定时将广告数据从数据库中导出，生成的数据文件通过网络传到投放服务器，投放服务器将数据文件载入内存供快速访问，当用户打开网站页面时候，部署在广告位的代码（可部署在客户端或服务器端）将参数传给广告投放服务器，投放服务器按一定策略和逻辑取出需要展现给用户的广告数据，按接口规范直接返回给用户浏览器渲染，或返回给调用广告引擎的服务器端程序，再由服务器端程序将广告嵌入内容页面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图[改进后的简单的广告系统架构]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于中小以内容或服务吸引访客的网站来说，广告是作为其运营收入的一部分，&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;接入大型广告网络&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;Google AdSense&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;淘宝联盟&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;部署开源广告系统&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;OpenX&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;使用第三方广告托管系统&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;百度广告管家&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;淘宝TanX&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;自主开发&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;广告系统模块&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;广告投放服务器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告投放服务器的规模是和流量以及广告数据量成正比的。当广告数据规模较小时，一台服务器的内存就能放下所有数据，如果同时这台服务器也能承担所有广告请求流量，那投放系统就能简化到一台机器；如果一台服务器不能承担所有流量，那么可以复制出同样的多台服务器共同承担广告请求流量，并在这个集群前使用负载均衡设备将流量均匀的分配给集群内的服务器；如果数据量太大以致于单机存不下所有数据，那么可以将广告数据按一定维度分区，存在一组服务器上，这组服务器提供不同分区的访问，对外则通过统一的接口供访问，调用者首先根据分区维度的参数值确定该分区的服务器，再向该服务器直接调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;随着软硬件的不断升级和优化，现代的普通商用服务器单台每秒可处理几千次的广告请求。在实现上选用高性能的Web服务器，如Nginx或Lighttpd，可以支撑大量并发连接，降低处理每个广告请求的系统消耗。如果对性能的有极端的要求，有些广告系统甚至会自主开发Web服务器（如采用Erlang，C语言等），或裁剪通用开源Web服务器不需要的功能，而只保留核心功能。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;K/V内存数据库&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告投放服务器对性能要求非常高，从收到广告请求到返回广告数据只有十几毫秒的时间完成决策和数据封装，而数据在内存中的读取速度相对最快，所以在广告投放服务器中，需要投放的广告数据都会保存在基于K/V的内存数据库中供快速读取。内存数据库和关系数据库中的数据通过消息队列保持同步，开源的K/V数据库有Memcache和Redis等。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;关系数据库&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告系统需要采用关系数据库来存储结构化的数据，如：广告计划，推广单元，创意等。这些是至关重要的核心数据，对数据安全性要求很高，要求即使在出现硬件损坏的情况下，客户的数据仍然能保证完整。业界一般采用两种方法存储这些核心数据：采用商业关系数据库如：Oracle，或采用开源数据库如：Mysql或Postgresql。商业数据库功能完善，但价格往往不菲，当广告系统规模变大后，成比例上升的软件成本不可小觑，所以会逐渐转向采用开源的Mysql，其高可用性则通过多个集群及实时复制技术来保证。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在广告系统中对广告数据的管理会通过一个或多个基于Web的应用来实现。通常采用J2EE或LAMP开发框架来开发。随着互联网广告的广泛和深入使用，广告的业务系统功能也越来越多且复杂，从架构上广告业务系统也朝着服务化和开放方向发展。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;消息中间件&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告数据在关系数据库的更新需要反应到投放服务器中的内存数据库，从而更新访客看到的广告。一般来说广告主对数据同步的延迟是有一定要求的，现代的广告系统也越来越往实时同步方向发展。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;CDN&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对于带有图片或视频等富媒体内容的广告创意，为了让访客的浏览器能较快的下载广告内容，需要将这些内容文件放在离访客地理位置较近的服务器上，这正是CDN系统的优势，广告系统往往需要租用或自己搭建CDN系统。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;RPC框架&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;大型广告系统在实现服务化后，需要进行分布式通信的服务器越来越多，采用较好的RPC框架，可使得系统各个模块之间的通信方法标准化, 简化业务开发。这里介绍一下Facebook开源的Thrift框架。Thrift是一种高效的、支持多种编程语言的远程服务调用的框架。互联网上比较流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。Thrift则采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;流式分布式计算平台&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Storm是Twitter开源出来的实时计算框架。可用于广告的防作弊，过滤无效展现PV和点击，也可用于实时广告费用结算等业务。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;离线分布式计算平台&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;大型广告平台的数据量非常大，受众用户和网页都在亿级，广告量级在百万，而且数据之间还有各种关联关系，必须能通过一个分布式计算平台才能处理。Hadoop是Apache开源组织的一个大数据分布式计算框架，在很多大型网站上都已经得到了广泛的应用：如Amazon，Facebook和Yahoo，国内的阿里巴巴也建有节点超过千台的Hadoop集群，用于淘宝，支付宝，阿里金融等业务数据的分析。广告系统可以利用Hadoop分析广告展现日志和点击日志，计算每个广告在一定时间跨度内的展现量，点击量，有效展现，有效点击，平均点击消耗费用，转化率等广告主报表数据；有很多的算法计算都可以采用Hadoop平台来实现。Hadoop的核心思想是Map/Reduce模型，其计算流程类似于Unix的Pipe:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;input | map | shuffle &amp;amp; sort | reduce | output&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Hadoop之上有Hive，Pig等简易数据分析接口，还有类Google Bigtable的开源实现HBase&amp;ndash;高可靠、高性能、面向列、可伸缩的分布式存储系统。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Java程序的日志</title>
      <link>http://hugozhu.myalert.info/2013/02/28/logging-in-java.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对程序运行情况的记录和监控；&lt;/li&gt;&#xA;&lt;li&gt;在必要时可详细了解程序内部的运行状态；&lt;/li&gt;&#xA;&lt;li&gt;对系统性能的影响尽量小；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;日志规范&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。&#xA;首先我们有必要了解一下Linux普遍使用的&lt;a href=&#34;http://en.wikipedia.org/wiki/Syslog&#34;&gt;Syslog&lt;/a&gt;标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是部分常见的Syslog模块类型：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;模块ID&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;kern&lt;/td&gt;&#xA;&lt;td&gt;内核消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;user&lt;/td&gt;&#xA;&lt;td&gt;用户级别消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;mail&lt;/td&gt;&#xA;&lt;td&gt;邮件系统&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;daemon&lt;/td&gt;&#xA;&lt;td&gt;系统后台守护程序&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;auth&lt;/td&gt;&#xA;&lt;td&gt;安全/鉴权消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;syslog&lt;/td&gt;&#xA;&lt;td&gt;syslogd内部产生的日志消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;…&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;以及Syslog严重程度划分：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;严重程度&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;Emergency&lt;/td&gt;&#xA;&lt;td&gt;emerg(panic)&lt;/td&gt;&#xA;&lt;td&gt;紧急，系统已经不稳定了&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;Alert&lt;/td&gt;&#xA;&lt;td&gt;alert&lt;/td&gt;&#xA;&lt;td&gt;需要立刻采取措施&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;Critical&lt;/td&gt;&#xA;&lt;td&gt;crit&lt;/td&gt;&#xA;&lt;td&gt;严重情况&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;Error&lt;/td&gt;&#xA;&lt;td&gt;err (error)&lt;/td&gt;&#xA;&lt;td&gt;系统出错&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;Warning&lt;/td&gt;&#xA;&lt;td&gt;warning(warn)&lt;/td&gt;&#xA;&lt;td&gt;系统警告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;Notice&lt;/td&gt;&#xA;&lt;td&gt;notice&lt;/td&gt;&#xA;&lt;td&gt;系统仍然正常，但值得注意&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;Informational&lt;/td&gt;&#xA;&lt;td&gt;info&lt;/td&gt;&#xA;&lt;td&gt;正常系统通告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;Debug&lt;/td&gt;&#xA;&lt;td&gt;debug&lt;/td&gt;&#xA;&lt;td&gt;系统调试信息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Java日志框架&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架太多了。。。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logging.apache.org&#34;&gt;&lt;strong&gt;Log4j&lt;/strong&gt;&lt;/a&gt; 或 &lt;a href=&#34;http://logging.apache.org/log4j/2.x/&#34;&gt;&lt;strong&gt;Log4j 2&lt;/strong&gt;&lt;/a&gt; - Apache的开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个配置文件（XML或Properties文件）来灵活地进行配置，而不需要修改程序代码。Log4j 2则是前任的一个升级，参考了Logback的许多特性；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logback.qos.ch&#34;&gt;&lt;strong&gt;Logback&lt;/strong&gt;&lt;/a&gt; - Logback是由log4j创始人设计的又一个开源日记组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/logging/package-summary.html&#34;&gt;&lt;strong&gt;java.util.logging&lt;/strong&gt;&lt;/a&gt; - JDK内置的日志接口和实现，功能比较简单&amp;hellip;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org&#34;&gt;&lt;strong&gt;Slf4j&lt;/strong&gt;&lt;/a&gt; - SLF4J是为各种Logging API提供一个简单统一的接口），从而使用户能够在部署的时候配置自己希望的Logging API实现；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging/&#34;&gt;&lt;strong&gt;Apache Commons Logging&lt;/strong&gt;&lt;/a&gt; - Apache Commons Logging （JCL）希望解决的问题和Slf4j类似。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;选项太多了的后果就是选择困难症，我的看法是没有最好的，只有最合适的。在比较关注性能的地方，选择Logback或自己实现高性能Logging API可能更合适；在已经使用了Log4j的项目中，如果没有发现问题，继续使用可能是更合适的方式；我一般会在项目里选择使用Slf4j, 如果不想有依赖则使用java.util.logging或框架容器已经提供的日志接口。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Java日志最佳实践&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;定义日志变量&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;需要定义成final static&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志分级&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架一般会提供以下日志级别，缺省打开info级别，也就是debug，trace级别的日志在生产环境不会输出，在开发和测试环境可以通过不同的日志配置文件打开debug级别。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;fatal&lt;/strong&gt; - 严重的，造成服务中断的错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;error&lt;/strong&gt; - 其他错误运行期错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;warn&lt;/strong&gt; -  警告信息，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;info&lt;/strong&gt; -  有意义的事件信息，如程序启动，关闭事件，收到请求事件等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;debug&lt;/strong&gt; - 调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;trace&lt;/strong&gt; - 更详细的跟踪信息；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在程序里要合理使用日志分级:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//调试的时候可以知道进入了方法&#xA;logger.debug(&amp;quot;entering getting content&amp;quot;);&#xA;String content = CacheManager.getCachedContent();&#xA;if (content == null) {&#xA;&#xA;    //使用warn，因为程序还可以继续执行，但类似警告太多可能说明缓存服务不可用了，值得引起注意&#xA;    logger.warn(&amp;quot;Got empty content from cache, need perform database lookup&amp;quot;); &#xA;&#xA;    Connection conn = ConnectionFactory.getConnection();&#xA;    if (conn == null) {&#xA;        logger.error(&amp;quot;Can&#39;t get database connection, failed to return content&amp;quot;); //尽量提供详细的信息，知道错误的原因，而不能简单的写logger.error(&amp;quot;failed&amp;quot;)&#xA;    } else {&#xA;        try {&#xA;            content = conn.query(...);&#xA;        } catch (IOException e) {&#xA;            //异常要记录错误堆栈&#xA;            logger.error(&amp;quot;Failed to perform database lookup&amp;quot;, e);&#xA;        } finally {&#xA;            ConnectionFactory.releaseConnection(conn);&#xA;        }&#xA;    }&#xA;}&#xA;//调试的时候可以知道方法返回了&#xA;logger.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;return content;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这段示范代码演示了各种级别的使用，但其中有个问题是debug日志太多后可能会影响性能？有一种改进方法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (logger.isDebugEnabled()) {&#xA;    logger.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但更好的方法是Slf4j提供的&lt;a href=&#34;http://www.slf4j.org/faq.html#logging_performance&#34;&gt;最佳实践&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;logger.debug(&amp;quot;returning content: {}&amp;quot;, content);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一方面可以减少参数构造的开销，另一方面也不用多写两行代码；&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;有意义的日志&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通常情况下在程序日志里记录一些比较有意义的状态数据：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序启动，退出的时间点；&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;程序运行消耗时间；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;long startTime = System.currentTime();          &#xA;// business logical          &#xA;logger.info(&amp;quot;execution cost : &amp;quot; + (System.currentTime() - startTime) + &amp;quot;ms&amp;quot;);　      &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;耗时程序的执行进度，不然程序开始运行后半天没一点输出挺让人着急啊~&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;重要变量的状态变化。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;日志安全&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;日志中尽量不要包含敏感信息，对于敏感信息如用户身份证号码，密码可以加密后存储；以防止日志文件不慎外泄时保全用户的数据安全；日志通常不允许修改，必要时还可以通过校验位来鉴别日志是否正确。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志可靠性&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志监控方法&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;作业&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;参考链接&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org/manual.html&#34;&gt;http://www.slf4j.org/manual.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&#34;&gt;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wikipedia.org/wiki/syslog&#34;&gt;http://wikipedia.org/wiki/syslog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Github合作开发项目</title>
      <link>http://hugozhu.myalert.info/2013/02/27/collaborating-development-with-github.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文大部分内容来自： &lt;a href=&#34;https://help.github.com/categories/63/articles&#34;&gt;https://help.github.com/categories/63/articles&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Github上合作开发最好的方式是“&lt;strong&gt;Fork + Pull Request&lt;/strong&gt;”。比如我最近需要一个静态Blog生成器，市面上有很多Ruby实现的，但我想要一个Go语言的实现，Github上找到了一个 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt; ，测试了一下已有的功能基本能满足了，就用上了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但实际使用过程中发现了一个问题，如果在URL中有中文，生成的URL如下没有做URL安全编码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还有一种情况是如果URL中有空格，如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info//2013//02/25/Java properties to enviorment variables.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;浏览器遇到这种URL时，会主动进行编码，但这里有两个问题：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;遇到中文时，浏览器是用GBK还是UTF-8还是其它字符集编码后再发送给服务器呢？&lt;/li&gt;&#xA;&lt;li&gt;遇到空格时，编码成+还是%20呢？&#xA;不同浏览器实现可能不一样，在不同操作系统上也可能不一样（可能和用户设置的缺省语言有关），这样有些用户可能会遭遇404错误了，实际上我在服务器的错误日志上的确看到这样的错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;日志：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;2013/02/27 20:41:33 [error] 7791#0: *3285 open() &amp;quot;.../2013/02/25/Java+properties+to+enviorment+variables.html&amp;quot; failed (2: No such file or directory), client: 221.179.193.78, server: hugozhu.myalert.info, request: &amp;quot;GET /2013/02/25/Java+properties+to+enviorment+variables.html HTTP/1.1&amp;quot;, host: &amp;quot;hugozhu.myalert.info&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;于是我需要动手修改代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先需要做的就是Fork一下原项目到自己的代码仓库： &lt;a href=&#34;https://github.com/hugozhu/gor&#34;&gt;https://github.com/hugozhu/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;修改好代码并提交到自己的仓库： &lt;a href=&#34;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&#34;&gt;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;在你的代码仓库页面上点Pull Request:&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BEH7V0vCYAAMgcl.jpg:large&#34;/&gt;&lt;/li&gt;&#xA;&lt;li&gt;选择好你刚提交好的Commits，然后点发送;&lt;/li&gt;&#xA;&lt;li&gt;原项目的维护者就会收到这个Pull Request: &lt;a href=&#34;https://github.com/wendal/gor/pull/14&#34;&gt;https://github.com/wendal/gor/pull/14&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果你提交的代码足够好，维护者可以合并到项目主干上；&lt;/li&gt;&#xA;&lt;li&gt;记住下一次本地修改代码前要先Merge一下原作者新提交的改动;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote add upstream https://github.com/wendal/gor&#xA;git fetch upstream&#xA;git checkout master&#xA;git merge upstream/master &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;到此为止就完成了一次合作开发。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;==&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;我们日常的项目开发中也可以采用这种思路，代码Review也可以增加Pull Request，对项目的迭代速度会有很大帮助。&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>在Pi和Github上搭建自己的个人博客</title>
      <link>http://hugozhu.myalert.info/2013/02/27/%E5%9C%A8Pi%E5%92%8CGithub%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;方法如下：&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;本站同时托管在家里的&lt;a href=&#34;http://www.raspberrypi.org&#34;&gt;Raspberry Pi&lt;/a&gt;和&lt;a href=&#34;http://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上，并同步保持更新，海外用户会访问Github，国内用户则会访问Pi，不同线路解析域名&lt;strong&gt;hugozhu.myalert.info&lt;/strong&gt;到不同的服务器是通过&lt;a href=&#34;http://dnspod.cn&#34;&gt;DnsPod&lt;/a&gt;的服务实现的，这么好的服务还是免费的，这里推荐一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为Github Pages只能支持静态网页，你需要一个能生成静态网页的博客生成引擎。我使用的是&lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor&lt;/a&gt; ， 也可以使用&lt;a href=&#34;http://ruhoh.com&#34;&gt;ruhoh&lt;/a&gt;，&lt;a href=&#34;https://www.google.com/search?q=static+blog+generator&amp;amp;hl=en&amp;amp;newwindow=1&amp;amp;client=safari&amp;amp;rls=en&amp;amp;biw=1238&amp;amp;bih=868&amp;amp;ei=msAuUY-vDMKO2AWQ7IHoBQ&amp;amp;sqi=2&amp;amp;start=10&amp;amp;sa=N&#34;&gt;Google一下还有很多&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;静态页面博客的好处：&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;性能是最好的，很合适用Raspberry Pi来做服务器，节省资源；&lt;/li&gt;&#xA;&lt;li&gt;文章可以用Markdown格式来编写，采用Github来做版本控制，我的Blog仓库在 &lt;a href=&#34;http://github.com/hugozhu/blog&#34;&gt;http://github.com/hugozhu/blog&lt;/a&gt; ，数据安全很好，误删除也不担心了；&lt;/li&gt;&#xA;&lt;li&gt;很容易找到托管环境，方便迁移；&lt;/li&gt;&#xA;&lt;li&gt;用Gor在Pi上生成速度很快；再用Nginx提供Web服务，可以直接在Pi上写Blog；&lt;/li&gt;&#xA;&lt;li&gt;大繁至简&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Github设置&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在你的仓库里增加一个your_github_id.github.com，比如我的github ID是hugozhu，相应的仓库名就是&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com&#34;&gt;hugozhu.github.com&lt;/a&gt;，这个仓库也就是网站的根目录了，在这里放生成好的静态文件&lt;/li&gt;&#xA;&lt;li&gt;如果你需要用自己的域名，而不是Github提供的，可以在根目录下增加一个&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com/blob/master/CNAME&#34;&gt;CNAME&lt;/a&gt;文件,文件内容则是你的域名，在DnsPod上需要建一个CNAME记录，将你的域名指向your_github_id.github.com. 也就是github原来分配给你的，完成这个设置后，访问your_github_id.github.com会跳转到你的域名；&lt;/li&gt;&#xA;&lt;li&gt;每次更新后，Github会在10分钟内生效。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;更新博客&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Gor的使用详细说明可见 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;我的整个网站的内容也通过Github开源了: &lt;a href=&#34;https://github.com/hugozhu/blog&#34;&gt;https://github.com/hugozhu/blog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;以我的网站为例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/hugozhu/blog&#xA;    Cloning into &#39;blog&#39;...&#xA;    remote: Counting objects: 190, done.&#xA;    remote: Compressing objects: 100% (146/146), done.&#xA;    remote: Total 190 (delta 81), reused 132 (delta 23)&#xA;    Receiving objects: 100% (190/190), 155.48 KiB | 171 KiB/s, done.&#xA;    Resolving deltas: 100% (81/81), done.&#xA;cd blog&#xA;gor compile&#xA;    2013/02/27 13:17:19 gor.go:21: gor ver 2.1&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : default&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : page&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : post&#xA;    2013/02/27 13:17:19 config.go:61: Look lile a Json, try it&#xA;    2013/02/27 13:17:19 config.go:64: It is Json Map&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/analytics/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/comments/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/google_prettify/config.yml&#xA;    2013/02/27 13:17:19 compile.go:125: Done&#xA;cd compiled&#xA;git init&#xA;git add -A &#xA;git commit -m &amp;quot;update website&amp;quot; .&#xA;git remote add origin hugozhu@github.com:hugozhu/hugozhu.github.com&#xA;git push -u origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后等待10分钟，再打开 &lt;a href=&#34;http://hugozhu.github.com&#34;&gt;http://hugozhu.github.com&lt;/a&gt; 就好了。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Raspberry Pi设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装nginx&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件：/etc/nginx/sites-enabled/default，增加下面内容&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;server {&#xA;    server_name hugozhu.myalert.info;&#xA;&#xA;    root /home/pi/blog/compiled;&#xA;&#xA;    location / {&#xA;        ssi on;&#xA;    }     &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;重新启动nginx，这样在Pi上也有一个你的个人博客了，方便自己访问，这里有个小小的技巧是可以通过server side include给静态页面增加动态内容，上面的配置在首页上打开了此功能，这样我可以在页底加上如下代码来显示访问者的IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--# echo var=&amp;quot;remote_addr&amp;quot; default=&amp;quot;no&amp;quot; --&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后重启Nginx生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/nginx restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;TODO:&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现一个简单的Web界面，可以通个Web界面来保存Blog，并重现编译和更新到Github；&#xA;&amp;gt; 已部分实现：在Github的博客仓库里可以直接创建或修改文件，用Go写了一个HTTP接口，curl一下后可更新，&lt;/li&gt;&#xA;&lt;li&gt;微博到博客的快速发布；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>动态DNS程序</title>
      <link>http://hugozhu.myalert.info/2013/02/26/dynamic-dns-script.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;动态根据宽带public ip更新dnspod登记的域名&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;按照 &lt;a href=&#34;https://gist.github.com/833369&#34;&gt;https://gist.github.com/833369&lt;/a&gt; 逻辑重新用Go实现了，用更少的内存开销在Raspberry Pi上跑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;替换上你的Email，密码，域名ID，记录ID等参数，就可以运行了。 会在后台一直运行，每隔30秒检查一遍IP，如果修改了就更新IP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获得domain_id可以用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl curl -k https://dnsapi.cn/Domain.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;获得record_id：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -k https://dnsapi.cn/Record.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;  &amp;quot;io/ioutil&amp;quot;&#xA;  &amp;quot;log&amp;quot;&#xA;  &amp;quot;net&amp;quot;&#xA;  &amp;quot;net/http&amp;quot;&#xA;  &amp;quot;net/url&amp;quot;&#xA;  &amp;quot;strings&amp;quot;&#xA;  &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;var (&#xA;    body = url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {&amp;quot;email&amp;quot;},&#xA;        &amp;quot;login_password&amp;quot;: {&amp;quot;password&amp;quot;},&#xA;        &amp;quot;format&amp;quot;:         {&amp;quot;json&amp;quot;},&#xA;        &amp;quot;domain_id&amp;quot;:      {&amp;quot;0&amp;quot;},&#xA;        &amp;quot;record_id&amp;quot;:      {&amp;quot;0&amp;quot;},&#xA;        &amp;quot;sub_domain&amp;quot;:     {&amp;quot;www&amp;quot;},&#xA;        &amp;quot;record_line&amp;quot;:    {&amp;quot;默认&amp;quot;},&#xA;    }&#xA;    current_ip     = &amp;quot;&amp;quot;&#xA;    check_interval = 30 * time.Second&#xA;)&#xA;&#xA;var current_ip = &amp;quot;&amp;quot;&#xA;&#xA;func get_public_ip() (string, error) {&#xA;    conn, err := net.DialTimeout(&amp;quot;tcp&amp;quot;, &amp;quot;ns1.dnspod.net:6666&amp;quot;, timeout*time.Second)&#xA;    defer func() {&#xA;        if x := recover(); x != nil {&#xA;            log.Println(&amp;quot;Can&#39;t get public ip&amp;quot;, x)&#xA;        }&#xA;        if conn!=nil {&#xA;            conn.Close()&#xA;        }&#xA;    }()&#xA;&#xA;    if err == nil {&#xA;        var bytes []byte&#xA;        deadline := time.Now().Add(timeout*time.Second)&#xA;        err = conn.SetDeadline(deadline)&#xA;        if err!=nil {&#xA;            return &amp;quot;&amp;quot;, err&#xA;        }&#xA;        bytes, err = ioutil.ReadAll(conn)&#xA;        if err == nil {&#xA;            return string(bytes), nil&#xA;        }&#xA;    }&#xA;    return &amp;quot;&amp;quot;, err&#xA;}&#xA;&#xA;func timeoutDialler(timeout time.Duration) func(net, addr string) (c net.Conn, err error) {&#xA;    return func(netw, addr string) (net.Conn, error) {&#xA;        c, err := net.DialTimeout(netw, addr, timeout)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        deadline := time.Now().Add(timeout)&#xA;        err = c.SetDeadline(deadline)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        return c, nil&#xA;    }&#xA;}&#xA;&#xA;func update_dnspod(ip string) bool {&#xA;    client := &amp;amp;http.Client{&#xA;        Transport: &amp;amp;http.Transport{&#xA;            Dial: timeoutDialler(timeout * time.Second),&#xA;        },&#xA;    }&#xA;    body := url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {login_email},&#xA;        &amp;quot;login_password&amp;quot;: {login_password},&#xA;        &amp;quot;format&amp;quot;:         {format},&#xA;        &amp;quot;domain_id&amp;quot;:      {domain_id},&#xA;        &amp;quot;record_id&amp;quot;:      {record_id},&#xA;        &amp;quot;sub_domain&amp;quot;:     {sub_domain},&#xA;        &amp;quot;record_line&amp;quot;:    {record_line},&#xA;        &amp;quot;value&amp;quot;:          {ip},&#xA;    }&#xA;&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, &amp;quot;https://dnsapi.cn/Record.Ddns&amp;quot;, strings.NewReader(body.Encode()))&#xA;    req.Header.Set(&amp;quot;Accept&amp;quot;, &amp;quot;text/json&amp;quot;)&#xA;    req.Header.Set(&amp;quot;Content-type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)&#xA;&#xA;    resp, err := client.Do(req)&#xA;&#xA;    defer resp.Body.Close()&#xA;&#xA;    if err != nil {&#xA;        return false&#xA;    }&#xA;    bytes, _ := ioutil.ReadAll(resp.Body)&#xA;    log.Println(string(bytes))&#xA;    return resp.StatusCode == 200&#xA;}&#xA;&#xA;func init() {&#xA;}&#xA;&#xA;func main() {&#xA;    for {&#xA;        ip, err := get_public_ip()&#xA;        if ip != &amp;quot;&amp;quot; &amp;amp;&amp;amp; err == nil {&#xA;            log.Println(&amp;quot;got ip:&amp;quot; + ip)&#xA;            if ip != current_ip {&#xA;                log.Println(&amp;quot;update dnspod with new ip:&amp;quot; + ip)&#xA;                if update_dnspod(ip) {&#xA;                    current_ip = ip&#xA;                }&#xA;            }&#xA;        } else {&#xA;            log.Println(&amp;quot;error:&amp;quot;, err)&#xA;        }&#xA;        time.Sleep(interval * time.Second)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>系统调试和分析工具</title>
      <link>http://hugozhu.myalert.info/2013/02/26/linux_perf_tools.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux下的调试和分析工具集&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/tools.jpg&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>将Java的Properties文件转换成环境变量</title>
      <link>http://hugozhu.myalert.info/2013/02/25/Java%20properties%20to%20enviorment%20variables.html</link>
      <pubDate>2013-02-25 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在Java程序中使用properties文件很方便，但有时候需要和脚本配合使用时，需要把properties文件内的多个变量转换成环境变量，本文提供一个转换脚本示范：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如env.properties如下（=附近可以有空格，也可以有空行）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&#xA;MYSQL_USER = root&#xA;MYSQL_PASS = &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面的脚本后就相当于&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export MYSQL_URL=&amp;quot;//localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;quot;&#xA;export MYSQL_USER=&amp;quot;root&amp;quot;&#xA;export MYSQL_PASS=&amp;quot;&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;env.sh脚本代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;property_file=env.properties&#xA;&#xA;get_prop(){&#xA;    propfile=$1&#xA;    key=$2&#xA;    grep  &amp;quot;^${2}=&amp;quot; ${1}| sed &amp;quot;s%${2}=\(.*\)%\1%&amp;quot;&#xA;}&#xA;&#xA;trim() {&#xA;    trimmed=$1&#xA;    trimmed=${trimmed%% }&#xA;    trimmed=${trimmed## }&#xA;    echo &amp;quot;$trimmed&amp;quot;&#xA;}&#xA;&#xA;`grep -v &amp;quot;^#&amp;quot; $property_file | sed -e &#39;/^$/d&#39; | while read line&#xA;do&#xA;    key=$(echo $line | awk -F &amp;quot;=&amp;quot; &#39;{print $1}&#39;)&#xA;    trimmed_key=$(trim $key)&#xA;    trimmed_val=$(trim $(get_prop $property_file &amp;quot;$key&amp;quot;)&#xA;    echo &amp;quot;export $trimmed_key=\&amp;quot;$trimmed_val\&amp;quot;)&amp;quot;&#xA;done`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>http://hugozhu.myalert.info/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>