<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Hugo Zhu</title>
    <link>http://hugozhu.myalert.info</link>
    <pubDate>2013-03-16 06:10:27 +0800</pubDate>
    <item>
      <title>如何使用Raspberry Pi控制步进电机旋转高清摄像头并拍照</title>
      <link>http://hugozhu.myalert.info/2013/03/16/03-16-use-raspberry-pi-control-step-motor-rotate-webcam.html</link>
      <pubDate>2013-03-16 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;硬件准备&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;安装&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;步进电机电源&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;步进电机驱动线路&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;安装摄像头&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;驱动示例代码&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;转动效果视频&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;连续转动拍摄代码实现&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_8&#34;&gt;拍摄图片效果&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;硬件准备&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;需要以下硬件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以工作的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHo44Chb01aWIu4ho12MwdcCLV6ff8kJMg0iz0FTGXaJAqMvt94sTe0NIrCAdd8LW&#34;&gt;树莓派&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHoWKV0kwS8Wy16Cg6qBM%2BZAOnJCqNG%2BPJAy9U15g8TwJiq5U3GGcJ8eTvC7%2F6APShw%3D%3D&#34;&gt;母对母1P杜邦线&lt;/a&gt;6根&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxjSLt%2BsmFEpvY8zQ4WXjoTHsLWTKD4gnL0sndE3qVPXd4UC6NUEZOQAryYUWhO7gt10i%2FUQ%3D%3D&#34;&gt;DC 5V4相28YBJ-48步进电机&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxjSLuXQmw2TUIlWTNRCvS2wo483pjZyXspPuvkTH5pg4vQUqrztOAoNz2Gfp8MmwKPg%2FbQb8%3D&#34;&gt;UL2003芯片步进电机驱动板&lt;/a&gt;一块&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;安装&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;按下图将步进电机接到驱动板上，也就是白色的接口&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img04.taobaocdn.com/bao/uploaded/i4/T10lS4XnXfXXaZhKrX_115008.jpg_310x310.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://img02.taobaocdn.com/imgextra/i2/49873130/T2534HXoBXXXXXXXXX_!!49873130.jpg&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_2&#34;&gt;步进电机电源&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;步进电机需要5V电压驱动，而树莓派的&lt;a href=&#34;http://elinux.org/RPi_Low-level_peripherals&#34;&gt;GPIO接口&lt;/a&gt;中已有5V输出，将图中的Pin 2（最右上角那个）5V，接到驱动板的5V正极，Pin 6接到5V负级，电源部分则搞定。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://trouch.com/wp-content/uploads/2012/08/webiopi-chrome.png&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_3&#34;&gt;步进电机驱动线路&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;驱动板上有IN1, IN2, IN3, IN4四个接口，根据资料得知这四个接口依次设置为低电平就可以驱动，我们分别用杜邦线将GPIO 17（Pin 11），GPIO 18（Pin 12）, GPIO 21（Pin 13）, GPIO 22（Pin 15）和IN1，IN2，IN3，IN4一一相连。 &lt;strong&gt;注意不同的GPIO驱动对端口的编号不一定一样。&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;驱动原理：（每次将四个GPIO端口按下表依次设置好电平后，可以sleep几十毫秒来控制转速）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;序列&lt;/strong&gt;    | &lt;strong&gt;GPIO 17&lt;/strong&gt; | &lt;strong&gt;GPIO 18&lt;/strong&gt; | &lt;strong&gt;GPIO 21&lt;/strong&gt;|&lt;strong&gt;GPIO 22&lt;/strong&gt;&lt;br /&gt;&#xA;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&#xA;0            | &lt;strong&gt;LOW&lt;/strong&gt;       | HIGH      | HIGH | HIGH&#xA;1            | HIGH          | &lt;strong&gt;LOW&lt;/strong&gt;   | HIGH | HIGH&#xA;2            | HIGH          | HIGH      | &lt;strong&gt;LOW&lt;/strong&gt;  | HIGH&#xA;3            | HIGH          | HIGH      | HIGH | &lt;strong&gt;LOW&lt;/strong&gt;&#xA;4            | &lt;strong&gt;LOW&lt;/strong&gt;       | HIGH      | HIGH | HIGH&#xA;5|…&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_4&#34;&gt;安装摄像头&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;本来是希望用3D打印机来制作齿轮和支架来完成这部分工作的，但因为打印机还没到货，所以先用乐高积木来做了, 刚好乐高积木可以插在步进电机中轴上，而且很牢靠，还不用密封带了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;摄像头如下图用两根导线固定在乐高积木上：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/bmiddle/6bc40342jw1e2rqxrtrd2j.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后用各种积木搭个底座把电机固定起来，并留两个洞口可以将驱动线和摄像头的USB线穿出，这样表面上比较整齐，USB线也不会因为牵扯影响转动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww4.sinaimg.cn/bmiddle/6bc40342jw1e2rqt5b23rj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://photo.weibo.com/1808008002/wbphotos/large/photo_id/3556528869320348?refer=weibofeedv5&#34;&gt;点击看大图&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;驱动示例代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;这里使用的是Python GPIO库，注意这里的端口命名是按树莓派的叫法（Pin 11, 12, 13, 15）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/step_motor # cat motor.py&#xA;import RPi.GPIO as GPIO&#xA;import time&#xA;import sys&#xA;from array import *&#xA;&#xA;GPIO.setwarnings(False) &#xA;GPIO.setmode(GPIO.BOARD)&#xA;&#xA;steps    = int(sys.argv[1]);&#xA;clockwise = int(sys.argv[2]);&#xA;&#xA;arr = [0,1,2,3];&#xA;if clockwise!=1:&#xA;    arr = [3,2,1,0];&#xA;&#xA;ports = [11,12,13,15]&#xA;&#xA;for p in ports:&#xA;    GPIO.setup(p,GPIO.OUT)&#xA;&#xA;for x in range(0,steps):&#xA;    for j in arr:&#xA;        time.sleep(0.01)&#xA;        for i in range(0,4):&#xA;            if i == j:            &#xA;                GPIO.output(ports[i],True)&#xA;            else:&#xA;                GPIO.output(ports[i],False)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;python motor.py  90 0&lt;/code&gt; 可以顺时针转动大约80度。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;python motor.py  90 1&lt;/code&gt; 则可逆时针转动大约80度。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;toc_6&#34;&gt;转动效果视频&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;embed src=&#34;http://player.youku.com/player.php/sid/XNTI3MzU1MjIw/v.swf&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; width=&#34;480&#34; height=&#34;400&#34; align=&#34;middle&#34; allowScriptAccess=&#34;always&#34; type=&#34;application/x-shockwave-flash&#34;&gt;&lt;/embed&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_7&#34;&gt;连续转动拍摄代码实现&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;这次使用webipi把控制程序转换成REST API，这样方便网页调用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;root@raspberrypi2 ~/projects/gpio_server # cat webiopi_custom.py&#xA;# Imports&#xA;import webiopi&#xA;import time&#xA;&#xA;# Retrieve GPIO lib&#xA;GPIO = webiopi.GPIO&#xA;&#xA;# -------------------------------------------------- #&#xA;# Macro definition part                              #&#xA;# -------------------------------------------------- #&#xA;&#xA;# A custom macro which prints out the arg received and return OK&#xA;def myMacroWithArgs(arg1, arg2, arg3):&#xA;    print(&amp;quot;myMacroWithArgs(%s, %s, %s)&amp;quot; % (arg1, arg2, arg3))&#xA;    return &amp;quot;OK&amp;quot;&#xA;&#xA;# A custom macro without args which return nothing&#xA;def myMacroWithoutArgs():&#xA;    print(&amp;quot;myMacroWithoutArgs()&amp;quot;)&#xA;&#xA;# Example loop which toggle GPIO 7 each 5 seconds&#xA;def loop():&#xA;    time.sleep(5)        &#xA;&#xA;&#xA;def turnLed(port_str, ms):&#xA;    port = int(port_str)&#xA;    GPIO.setFunction(port,GPIO.OUT)    &#xA;    GPIO.output(port,GPIO.LOW)&#xA;    time.sleep(float(ms)/1000)&#xA;    GPIO.output(port,GPIO.HIGH)&#xA;&#xA;def turnWebcam(steps_str, clockwise_str):&#xA;    steps = int(steps_str);&#xA;    clockwise = int(clockwise_str);&#xA;    arr = [0,1,2,3];&#xA;    if clockwise!=1:&#xA;        arr = [3,2,1,0];&#xA;&#xA;    ports = [17,18,27,22]&#xA;&#xA;    for p in ports:&#xA;        GPIO.setFunction(p,GPIO.OUT)&#xA;&#xA;    for x in range(0,steps):&#xA;        for j in arr:&#xA;            time.sleep(0.01)&#xA;            for i in range(0,4):&#xA;                if i == j:            &#xA;                    GPIO.output(ports[i],GPIO.LOW)&#xA;                else:&#xA;                    GPIO.output(ports[i],GPIO.HIGH)&#xA;&#xA;# -------------------------------------------------- #&#xA;# Initialization part                                #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Setup GPIOs&#xA;&#xA;# -------------------------------------------------- #&#xA;# Main server part                                   #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Instantiate the server on the port 8000, it starts immediately in its own thread&#xA;server = webiopi.Server(port=8001, login=&amp;quot;pi&amp;quot;, password=&amp;quot;pi&amp;quot;)&#xA;# or     webiopi.Server(port=8000, passwdfile=&amp;quot;/etc/webiopi/passwd&amp;quot;)&#xA;&#xA;# Register the macros so you can call it with Javascript and/or REST API&#xA;server.addMacro(turnWebcam)&#xA;server.addMacro(turnLed)&#xA;&#xA;&#xA;# -------------------------------------------------- #&#xA;# Loop execution part                                #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Run our loop until CTRL-C is pressed or SIGTERM received&#xA;webiopi.runLoop()&#xA;&#xA;# If no specific loop is needed and defined above, just use &#xA;# webiopi.runLoop()&#xA;# here instead&#xA;&#xA;# -------------------------------------------------- #&#xA;# Termination part                                   #&#xA;# -------------------------------------------------- #&#xA;&#xA;# Cleanly stop the server&#xA;server.stop()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;python webiopi_custom.py&lt;/code&gt; 后启动GPIO REST API服务器&lt;/p&gt;&#xA;&#xA;&lt;p&gt;转动命令是：&lt;code&gt;curl --data &amp;quot;&amp;quot; &amp;quot;http://pi:pi@raspberrypi2:8001/macros/turnWebcam/90,0&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;拍照命令是：&lt;code&gt;/usr/bin/fswebcam -v -r 640x480 --no-banner /var/www/fswebcam/foo.jpg&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是我们可以用以下方法来实现连续拍摄：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行拍照命令, 生成right.jpg&lt;/li&gt;&#xA;&lt;li&gt;顺时转80度&lt;/li&gt;&#xA;&lt;li&gt;执行拍照命令, 生成middle.jpg&lt;/li&gt;&#xA;&lt;li&gt;顺时转80度&lt;/li&gt;&#xA;&lt;li&gt;执行拍照命令, 生成left.jpg&lt;/li&gt;&#xA;&lt;li&gt;逆时针转160度归位&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;将命令通过网页执行后，就可以在外面看房间里的情况了，今天出去外面采草莓在iPhone上试了一下，结果符合预期。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_8&#34;&gt;拍摄图片效果&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/large/6bc40342jw1e2r069hyhsj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总共花了不到2小时就可以搞定这个了，还是非常好玩的~ 后面还可以用OpenCV库来合成照片到真正的全景图&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>如何在Raspberry Pi上用LED闪烁提示网站首页新访客</title>
      <link>http://hugozhu.myalert.info/2013/03/13/vistor-on-homepage-led-indicator.html</link>
      <pubDate>2013-03-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本方法只适合小网站，主要是好玩。Raspberry Pi不是很合适需要实时控制的系统（比如，飞行器，遥控小车），因为Linux内核要多任务，应用程序的优先级不能保持最高，会带来延时，但做些实时性要求不高的系统还是可以的。&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;硬件安装&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;需要以下硬件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以工作的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHo44Chb01aWIu4ho12MwdcCLV6ff8kJMg0iz0FTGXaJAqMvt94sTe0NIrCAdd8LW&#34;&gt;树莓派&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHoWKV0kwS8Wy16Cg6qBM%2BZAOnJCqNG%2BPJAy9U15g8TwJiq5U3GGcJ8eTvC7%2F6APShw%3D%3D&#34;&gt;1P杜邦线2条&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxiNm9RKSkRargJCPYP6KVEIQUWKzMUFn1hvlcbkMSKk3m2pVJo%2BqQDYKVz%2Bt1%2FjL7Iywe7g%3D%3D&#34;&gt;面包板&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHKxVk7v382jKYSyD7qi5ltcqvLWmWBL7lxLB2%2BsaWLuet8Ik65QHyGWV5mRTheUA&#34;&gt;面包板跳线&lt;/a&gt; 或 &lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHKxVk7v382jKYSyD7qi5ltcqvLWmWBL7lxLB2%2BsaWLuet8Ik65QHyGWV5mRTheUA&#34;&gt;单排针&lt;/a&gt; 两根&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CITy7klxxrJ35Nnc0iO6niAHKxVk7v382jKYSyD7qi5ltcqvLWmWBL7lxLB2%2BsaWLuet8Ik65QHyGWV5mRTheUA&#34;&gt;发光二极管&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;li&gt;300欧姆的&lt;a href=&#34;http://s.click.taobao.com/t?e=zGU34CA7K%2BPkqB07S4%2FK0CFcRfH0GoT805sipKjxiNm80QgaIDkojjQIBhc4L8WmRpaGVVBVD9DpAt8wKPZTmbzvVp4EIdCD2Ow2DOQmdPtlV8g%3D&#34;&gt;电阻&lt;/a&gt;一个&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;GPIO接口&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww1.sinaimg.cn/large/6bc40342gw1e2o2uls7wlj.jpg&#34; width=&#34;630&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用杜邦线将上图的3.3V输出和GPIO 23引出（板子正面朝上，GPIO引脚在左上角），将电阻和LED串联起来（电阻防止LED电流过大烧掉），注意二极管的两根脚不一样长，长脚的接正级，这样GPIO 23如果输出高电平，二极管就不发光了，输出低电平就亮啦！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;都接好了后的样子如下：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://ww3.sinaimg.cn/bmiddle/6bc40342jw1e2ni9esb2uj.jpg&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;GPIO接口编程&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;WiringPi&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;An implementation of most of the Arduino Wiring functions for the Raspberry Pi。&#xA;代码地址在： &lt;a href=&#34;https://github.com/wiringPi&#34;&gt;https://github.com/wiringPi&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/WiringPi/WiringPi&#xA;cd WiringPi/wiringPi&#xA;sudo make install   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让二极管闪一下的示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#include &amp;lt;wiringPi.h&amp;gt;&#xA;#include &amp;lt;stdio.h&amp;gt;&#xA;#include &amp;lt;stdlib.h&amp;gt;&#xA;&#xA;int main (int argc, char* argv[])&#xA;{&#xA;    int pinNumber = 4;&#xA;    if (-1 == wiringPiSetup()) {&#xA;        printf(&amp;quot;failed to setup wiringPi&amp;quot;);&#xA;        return 1;&#xA;    }   &#xA;    pinMode(pinNumber, OUTPUT);&#xA;    digitalWrite(pinNumber, 1);&#xA;    delay(200);&#xA;    digitalWrite(pinNumber, 0);&#xA;    delay(200);&#xA;    return 0;   &#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;WiringPi也有Python, Perl, PHP, Ruby的接口包装，按&lt;a href=&#34;https://github.com/wiringPi&#34;&gt;这里&lt;/a&gt;，怎么没有Go的呢。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;RPi.GPIO&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这是GPIO的Python库，地址在：&lt;a href=&#34;https://pypi.python.org/pypi/RPi.GPIO&#34;&gt;https://pypi.python.org/pypi/RPi.GPIO&lt;/a&gt;&#xA;这里建议用python2，原因是web.py还不支持python 3 &amp;hellip;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pacman -S python2&#xA;pacman -S python2-distribute&#xA;easy_install RPi.GPIO&#xA;    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让二极管一直闪的示例代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;import RPi.GPIO as GPIO&#xA;import time&#xA;&#xA;PORT = 16&#xA;&#xA;GPIO.setwarnings(False) &#xA;GPIO.setmode(GPIO.BOARD)&#xA;&#xA;GPIO.setup(PORT,GPIO.OUT)&#xA;&#xA;while True:&#xA;    GPIO.output(PORT,True)&#xA;    time.sleep(0.2)&#xA;    GPIO.output(PORT,False)&#xA;    time.sleep(0.2)&#xA;    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;Webiopi&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;项目地址： &lt;a href=&#34;http://code.google.com/p/webiopi/&#34;&gt;http://code.google.com/p/webiopi/&lt;/a&gt; 这是一个使用RESTful API控制Pi的GPIO接口，文档丰富，使用起来非常简单。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装好后，用命令&lt;code&gt;python -m webiopi&lt;/code&gt;启动，用浏览器打开 &lt;a href=&#34;http://webiopi:raspberry@raspberrypi2:8000/webiopi/&#34;&gt;http://webiopi:raspberry@raspberrypi2:8000/webiopi/&lt;/a&gt; 可以看到控制界面，其中有GPIO 26个引脚的状态（输入输出，高电平或低电平），用鼠标点端口还可以修改数据：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://trouch.com/wp-content/uploads/2012/08/webiopi-chrome.png&#34; width=&#34;630&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;完成的代码&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;最后用一小段代码来实现最初的想法，这段代码可以较实时的处理QPS&amp;lt;=3的网站流量，如果流量较大则会滞后反应。。。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;hugo@raspberrypi ~/bin $ cat traffic_led.sh &#xA;#!/bin/sh&#xA;&#xA;tail -f  /mnt/usb/logs/nginx/access.log  | grep --line-buffered &amp;quot;GET / HTTP&amp;quot; | while read LINE; do  {&#xA;   #echo $LINE&#xA;   curl -s --data &amp;quot;&amp;quot; &amp;quot;http://webiopi:raspberry@raspberrypi2:8000/GPIO/23/value/0&amp;quot;&#xA;   sleep 0.2&#xA;   curl -s --data &amp;quot;&amp;quot; &amp;quot;http://webiopi:raspberry@raspberrypi2:8000/GPIO/23/value/1&amp;quot;&#xA;   sleep 0.1&#xA;}&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;类似的还可以用这个方法来提醒：来自某某某的新邮件到了，Github有Pull Requests了。。。,或者网站挂了。。。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>在Raspberry Pi上安装ArchLinux</title>
      <link>http://hugozhu.myalert.info/2013/03/09/setup-archliunx-on-raspberry-pi.html</link>
      <pubDate>2013-03-09 12:00:00 +0800</pubDate>
      <description>&#xA;&#xA;&lt;p&gt;&lt;nav&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_0&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_1&#34;&gt;增加sudo用户&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_2&#34;&gt;USB盘&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_3&#34;&gt;Pacman&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_4&#34;&gt;UnixBench&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_5&#34;&gt;无线网络&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_6&#34;&gt;Samba&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#toc_7&#34;&gt;注意事项&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/nav&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_0&#34;&gt;介绍&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;之前买的Raspberry Pi因为要跑&lt;a href=&#34;http://hugozhu.myalert.info&#34;&gt;这个网站&lt;/a&gt;，不能经常拔下来玩别的，所以又买了一个，这次安装的是&lt;a href=&#34;https://www.archlinux.org&#34;&gt;Arch Linux&lt;/a&gt;。这个发行版安装好后非常基础，占用的空间也只有600M不到，比较合适已有Linux基础的同学玩。初学者可以玩官方推荐的&lt;a href=&#34;http://www.raspbian.org&#34;&gt;Raspbian&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Arch Linux特点：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;启动快，上电后只要3s完成启动&lt;/li&gt;&#xA;&lt;li&gt;安装完没有图形界面，干净&lt;/li&gt;&#xA;&lt;li&gt;面向开发者的系统&lt;/li&gt;&#xA;&lt;li&gt;包管理系统pacman很好用，一个命令就可以完成各种操作&lt;/li&gt;&#xA;&lt;li&gt;ArchLinux缺省账号和密码是root/root，弄好了后要记得修改root密码&lt;/li&gt;&#xA;&lt;li&gt;从中国用下载包很快，比Raspbian的源快多了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_1&#34;&gt;增加sudo用户&lt;/h1&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;   useradd hugo&#xA;   passwd hugo&#xA;   mkdir /home/hugo&#xA;   chown hugo:hugo /home/hugo   &#xA;   pacman -S sudo&#xA;   visudo   &#xA;   &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行&lt;code&gt;visudo&lt;/code&gt;把新用户设置成管理员（增加sudo权限），最后面增加下面一行：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    hugo ALL=(ALL) NOPASSWD: ALL&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_2&#34;&gt;USB盘&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;插上USB盘后，ArchLinux并不会自动mount，手动mount的过程如下:&#xA;插上USB前后执行两次 &lt;code&gt;lsblk -o name,kname,uuid&lt;/code&gt;，那么输出上多出的那行就是该USB的设备名，或UUID，找到该行后就可以执行mount命令了（注意sda这个符号不同机器可能不一样）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    [root@raspberrypi2 ~]# lsblk -o name,kname,uuid   &#xA;    NAME        KNAME     UUID&#xA;    sda         sda       001B-9622&#xA;    mmcblk0     mmcblk0   &#xA;    ├─mmcblk0p1 mmcblk0p1 44C8-CEF1&#xA;    └─mmcblk0p2 mmcblk0p2 fcee8534-f5f0-42ee-83ac-f943f878ee67&#xA;    &#xA;    mkdir /mnt/usb&#xA;    mount /dev/sda /mnt/usb &#xA;    或 &#xA;    mount -U 001B-9622 /mnt/usb&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;格式化整个USB盘可以用&lt;code&gt;mkfs.ext4 /dev/sda&lt;/code&gt;&#xA;然后在/etc/fstab里增加一行，以后重启就会自动mount了：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/dev/sda       /mnt/usb        ext4    defaults,noatime  0       0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还可以测试一下SD卡和USB盘的读写性能：&#xA;&#xA;[root@raspberrypi2 ~]# hdparm -Tt /dev/mmcblk0&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/dev/mmcblk0:&#xA; Timing cached reads:   292 MB in  2.00 seconds = 145.73 MB/sec&#xA; Timing buffered disk reads:  48 MB in  3.12 seconds =  15.38 MB/sec&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[root@raspberrypi2 ~]# hdparm  -Tt /dev/sda&lt;/p&gt;&#xA;&#xA;&lt;p&gt;/dev/sda:&#xA; Timing cached reads:   280 MB in  2.00 seconds = 139.80 MB/sec&#xA; Timing buffered disk reads:  50 MB in  3.01 seconds =  16.61 MB/sec&#xA; &lt;/p&gt;&#xA;&#xA;&lt;p&gt;等多信息可参考&lt;a href=&#34;https://wiki.archlinux.org/index.php/USB_Storage_Devices#Auto-mounting_with_udev&#34;&gt;Wiki&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_3&#34;&gt;Pacman&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;ArchLinux的包管理软件是pacman，类似apt-get, yum等，这里有所有的包：&lt;a href=&#34;http://archlinuxarm.org/packages&#34;&gt;http://archlinuxarm.org/packages&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/Pacman&#34;&gt;使用方法&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;pacman -Syu &amp;amp;&amp;amp; sync #更新整个系统，&lt;strong&gt;新安装好要运行一次&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;pacman -S gcc make git #安装gcc, make等，作为程序员必须的&lt;/li&gt;&#xA;&lt;li&gt;pacman -R package_name &amp;ndash;nosave #删除干净某个包&lt;/li&gt;&#xA;&lt;li&gt;pacman -Scc #完全清理包缓存&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_4&#34;&gt;UnixBench&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;了解一下性能基准测试非常有必要。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl http://byte-unixbench.googlecode.com/files/unixbench-5.1.2.tar.gz -o unixbench-5.1.2.tar.gz&#xA;tar zxvf unixbench-5.1.2.tar.gz&#xA;cd unixbench-5.1.2&#xA;make&#xA;./Run&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果没有X，要在Makefile里注释掉X的测试，结果如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;========================================================================&#xA;   BYTE UNIX Benchmarks (Version 5.1.2)&#xA;&#xA;   System: raspberrypi: GNU/Linux&#xA;   OS: GNU/Linux -- 3.2.27+ -- #250 PREEMPT Thu Oct 18 19:03:02 BST 2012&#xA;   Machine: armv6l (unknown)&#xA;   Language: en_US.utf8 (charmap=&amp;quot;ANSI_X3.4-1968&amp;quot;, collate=&amp;quot;ANSI_X3.4-1968&amp;quot;)&#xA;   23:12:18 up 63 days, 22:35,  2 users,  load average: 0.27, 0.28, 0.23; runlevel 2&#xA;&#xA;------------------------------------------------------------------------&#xA;Benchmark Run: Sat Mar 09 2013 23:12:18 - 23:41:57&#xA;0 CPUs in system; running 1 parallel copy of tests&#xA;&#xA;Dhrystone 2 using register variables        1686980.7 lps   (10.0 s, 7 samples)&#xA;Double-Precision Whetstone                      269.9 MWIPS (10.0 s, 7 samples)&#xA;Execl Throughput                                256.8 lps   (29.7 s, 2 samples)&#xA;File Copy 1024 bufsize 2000 maxblocks         43489.0 KBps  (30.0 s, 2 samples)&#xA;File Copy 256 bufsize 500 maxblocks           14568.0 KBps  (30.0 s, 2 samples)&#xA;File Copy 4096 bufsize 8000 maxblocks         96518.7 KBps  (30.0 s, 2 samples)&#xA;Pipe Throughput                              172158.1 lps   (10.0 s, 7 samples)&#xA;Pipe-based Context Switching                  24098.7 lps   (10.0 s, 7 samples)&#xA;Process Creation                                772.2 lps   (30.0 s, 2 samples)&#xA;Shell Scripts (1 concurrent)                    462.6 lpm   (60.1 s, 2 samples)&#xA;Shell Scripts (8 concurrent)                     59.0 lpm   (60.5 s, 2 samples)&#xA;System Call Overhead                         396466.7 lps   (10.0 s, 7 samples)&#xA;&#xA;System Benchmarks Index Values               BASELINE       RESULT    INDEX&#xA;Dhrystone 2 using register variables         116700.0    1686980.7    144.6&#xA;Double-Precision Whetstone                       55.0        269.9     49.1&#xA;Execl Throughput                                 43.0        256.8     59.7&#xA;File Copy 1024 bufsize 2000 maxblocks          3960.0      43489.0    109.8&#xA;File Copy 256 bufsize 500 maxblocks            1655.0      14568.0     88.0&#xA;File Copy 4096 bufsize 8000 maxblocks          5800.0      96518.7    166.4&#xA;Pipe Throughput                               12440.0     172158.1    138.4&#xA;Pipe-based Context Switching                   4000.0      24098.7     60.2&#xA;Process Creation                                126.0        772.2     61.3&#xA;Shell Scripts (1 concurrent)                     42.4        462.6    109.1&#xA;Shell Scripts (8 concurrent)                      6.0         59.0     98.3&#xA;System Call Overhead                          15000.0     396466.7    264.3&#xA;                                                                   ========&#xA;System Benchmarks Index Score                                          99.9&#xA;&#xA;&#xA;========================================================================&#xA;   BYTE UNIX Bench  marks (Version 5.1.2)&#xA;&#xA;   System: raspberrypi2: GNU/Linux&#xA;   OS: GNU/Linux -- 3.6.11-8-ARCH+ -- #1 PREEMPT Sat Mar 9 00:38:58 UTC 2013&#xA;   Machine: armv6l (unknown)&#xA;   Language: en_US.utf8 (charmap=&amp;quot;UTF-8&amp;quot;, collate=&amp;quot;ANSI_X3.4-1968&amp;quot;)&#xA;   23:11:34 up 40 min,  2 users,  load average: 0.32, 0.56, 0.40; runlevel 5&#xA;&#xA;------------------------------------------------------------------------&#xA;Benchmark Run: Sat Mar 09 2013 23:11:34 - 23:40:13&#xA;0 CPUs in system; running 1 parallel copy of tests&#xA;&#xA;Dhrystone 2 using register variables        1686859.5 lps   (10.1 s, 7 samples)&#xA;Double-Precision Whetstone                      240.0 MWIPS (10.0 s, 7 samples)&#xA;Execl Throughput                                235.9 lps   (29.8 s, 2 samples)&#xA;File Copy 1024 bufsize 2000 maxblocks         36862.7 KBps  (30.0 s, 2 samples)&#xA;File Copy 256 bufsize 500 maxblocks           11351.7 KBps  (30.0 s, 2 samples)&#xA;File Copy 4096 bufsize 8000 maxblocks         79915.7 KBps  (30.0 s, 2 samples)&#xA;Pipe Throughput                              127650.5 lps   (10.1 s, 7 samples)&#xA;Pipe-based Context Switching                  18840.9 lps   (10.1 s, 7 samples)&#xA;Process Creation                                779.2 lps   (30.1 s, 2 samples)&#xA;Shell Scripts (1 concurrent)                    193.1 lpm   (60.3 s, 2 samples)&#xA;Shell Scripts (8 concurrent)                     26.7 lpm   (60.7 s, 2 samples)&#xA;System Call Overhead                         314659.8 lps   (10.1 s, 7 samples)&#xA;&#xA;System Benchmarks Index Values               BASELINE       RESULT    INDEX&#xA;Dhrystone 2 using register variables         116700.0    1686859.5    144.5&#xA;Double-Precision Whetstone                       55.0        240.0     43.6&#xA;Execl Throughput                                 43.0        235.9     54.9&#xA;File Copy 1024 bufsize 2000 maxblocks          3960.0      36862.7     93.1&#xA;File Copy 256 bufsize 500 maxblocks            1655.0      11351.7     68.6&#xA;File Copy 4096 bufsize 8000 maxblocks          5800.0      79915.7    137.8&#xA;Pipe Throughput                               12440.0     127650.5    102.6&#xA;Pipe-based Context Switching                   4000.0      18840.9     47.1&#xA;Process Creation                                126.0        779.2     61.8&#xA;Shell Scripts (1 concurrent)                     42.4        193.1     45.6&#xA;Shell Scripts (8 concurrent)                      6.0         26.7     44.5&#xA;System Call Overhead                          15000.0     314659.8    209.8&#xA;                                                                   ========&#xA;System Benchmarks Index Score                                          76.3&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看上去ArchLinux性能差了一节，看来官方推荐Raspian确实做了不少优化，我觉得介绍一下系统方面的优化，也是非常不错的内容。&lt;/p&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_5&#34;&gt;无线网络&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;我买的是基于RT5370芯片组的腾达W311MI，Raspberry Pi支持的很好。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;确认系统已经识别USB网卡，如下&lt;code&gt;RT5370 Wireless Adapter&lt;/code&gt;就代表已经识别成功&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[root@raspberrypi2 ~]# lsusb&#xA;Bus 001 Device 002: ID 0424:9512 Standard Microsystems Corp. LAN9500 Ethernet 10/100 Adapter&#xA;Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub&#xA;Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. &#xA;Bus 001 Device 004: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;安装无线工具&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;pacman -S wireless_tools&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;设置开机启动无线网络&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用&lt;code&gt;wifi-menu&lt;/code&gt;手动连上wifi ap，可以连多个，相应的输入会保存在：/etc/network.d/，在下面的文件里输入相应的文件名&lt;/p&gt;&#xA;&#xA;&lt;p&gt;修改/etc/conf.d/netcfg&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;DHCP_TIMEOUT=30 &#xA;AUTO_PROFILES=(&amp;quot;wlan0-Hugo2&amp;quot; &amp;quot;wlan0-hugo&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果是隐藏SSID的要加一行&amp;rdquo;HIDDEN=YES&amp;rdquo;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;执行一下命令在重启时自动连上wifi&#xA;&lt;code&gt;&#xA;systemctl enable net-auto-wireless&#xA;&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;有条件的可以在路由器里设置好根据MAC地址总是分配同一个ip给Pi，这样就可以拔掉网线的束缚了~&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;测试了断开后可以自动重连&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;用scp测试从Mac通过无线传大文件到Raspberry Pi，传输速度只有1.6MB/s，如果通过网线传则有4MB/s&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_6&#34;&gt;Samba&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;安装相关包： &lt;code&gt;pacman -S samba&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;生成一个配置文件： &lt;code&gt;cp /etc/samba/smb.conf.default /etc/samba/smb.conf&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;加到启动脚本里： &lt;code&gt;systemctl enable smbd.service&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;增加一个samba用户： &lt;code&gt;smbpasswd -a hugo&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h1 id=&#34;toc_7&#34;&gt;注意事项&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;因为Pi没有实时时钟，ntpd 或 openntpd在无线网络下可能先于wifi开始工作启动，造成服务不工作，系统日期未初始化成功。我的解决方案是系统启动完成后延时10s执行ntpdate设置时间（期望这个时候wifi已经工作了），并且重启samba服务（好像日期不正常samba也不正常，这块还没仔细研究）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>如何封杀尝试Raspberry Pi SSH密码的来源IP</title>
      <link>http://hugozhu.myalert.info/2013/03/08/block_failed_ssh_attempts_with_iptable.html</link>
      <pubDate>2013-03-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Raspberry Pi整天开着，如果用缺省SSH端口对外开放，就会经常遇到扫描SSH密码的肉鸡。虽然密码不是很简单，但还是感觉很不安全的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;系统的ssh登录日志文件在：/var/log/auth.log，登录失败时会记录以下格式的日志：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;Mar  7 10:31:51 raspberrypi sshd[24510]: Failed password for root from 221.8.19.129 port 4066 ssh2&#xA;Mar  7 10:31:55 raspberrypi sshd[24514]: Failed password for root from 221.8.19.129 port 4079 ssh2&#xA;Mar  7 10:31:56 raspberrypi sshd[24518]: Failed password for sshd from 221.8.19.129 port 4080 ssh2&#xA;Mar  7 10:32:26 raspberrypi sshd[24522]: Failed password for sshd from 221.8.19.129 port 4149 ssh2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;用最简单的Shell脚本来解决这个问题：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;guard.sh&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;last_ip=&amp;quot;&amp;quot;&#xA;tail -f /var/log/auth | while read LINE; do&#xA;{&#xA;    if [[ &amp;quot;${LINE}&amp;quot; =~ &amp;quot;Failed&amp;quot; ]]; then            &#xA;        ip=&amp;quot;$(echo ${LINE} | awk &#39;{print $(NF-3)}&#39;)&amp;quot;&#xA;        if [[ &amp;quot;$last_ip&amp;quot; == &amp;quot;$ip&amp;quot; ]]; then&#xA;             echo &amp;quot;block $ip&amp;quot;&#xA;             #curl -s --data-ascii &amp;quot;uuid=&amp;lt;my iphone&#39;s uuid&amp;gt;&amp;quot; --data &amp;quot;body=${LINE}&amp;quot; http://raspberrypi/pushme                 &#xA;             iptables -A INPUT -s &amp;quot;$ip&amp;quot; -j DROP&#xA;        fi&#xA;        last_ip=$ip&#xA;        echo $LINE&#xA;    fi&#xA;}&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;用root用户执行以下命令，也可以放到启动脚本里：/etc/rc.local&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;nohup /root/bin/guard.sh &amp;gt; /var/logs/guard.log 2&amp;gt;&amp;amp;1 &amp;amp;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;如果连续两次输错密码，那ip就会被封，我另外加了一个报警，会通知到我的手机，这下感觉安全了些。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;登录Pi用&lt;code&gt;iptables -L&lt;/code&gt;可以看到被封杀的IP列表，如果需要解封这些IP，可以用命令&lt;code&gt;iptables -F&lt;/code&gt;，也可以用crontjob每天定时运行一次&lt;code&gt;iptables -F&lt;/code&gt;来清除&lt;/p&gt;&#xA;&#xA;&lt;p&gt;脚本还很简单，还可以有不少改进，可以在评论里讨论。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Raspberry Pi做BT下载机+高清播放器</title>
      <link>http://hugozhu.myalert.info/2013/03/06/raspberry-pi-with-xmbc.html</link>
      <pubDate>2013-03-06 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先高清播放器功能只是Raspberry Pi的一个小功能，如果你只需要高清播放功能又不想折腾，那还是买个&lt;a href=&#34;http://s.taobao.com/search?q=%B8%DF%C7%E5%B2%A5%B7%C5%C6%F7&amp;amp;commend=all&amp;amp;ssid=s5-e&amp;amp;search_type=item&amp;amp;sourceId=tb.index&amp;amp;initiative_id=tbindexz_20130306&#34;&gt;山寨的&lt;/a&gt;的更简单。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Raspberry Pi的图形处理器规格：Broadcom VideoCore IV, OpenGL ES 2.0, 1080p 30 h.264/MPEG-4 AVC 高清解码器，内存和CPU共享（可设置成256M），性能还是很强劲的。HDMI支持640x350和1920×1200（1080P）的分辨率。安装了&lt;a href=&#34;http://xbmc.org&#34;&gt;XBMC&lt;/a&gt;，基本上可以实现包括Airplay在内的Apple TV上的大部分功能，但价格只有其一半不到，可以播放下载的视频或观看在线视频，如&lt;a href=&#34;http://yisou.com&#34;&gt;一搜&lt;/a&gt;，优酷，搜狐视频，奇艺等。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;外设&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;除了Pi单片机外，你还需要以下外设附件：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;5V-1A左右的电源，可以用iPhone或iPad的充电电源，或手机的充电器，电流最少要800毫安&lt;/li&gt;&#xA;&lt;li&gt;micro USB线一根，和Kindle以及大多数android手机充电USB线一样&lt;/li&gt;&#xA;&lt;li&gt;HDMI线一根，接电视机&lt;/li&gt;&#xA;&lt;li&gt;SD卡一张，最少2G&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Raspbmc&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.raspbmc.com/&#34;&gt;Raspbmc&lt;/a&gt; 是专为在Raspberry Pi上运行&lt;a href=&#34;http://xbmc.org&#34;&gt;XBMC&lt;/a&gt;的定制Linux。最小化的安装，减少了不必要的软件和资源占用，简化了安装和配置，没有Linux知识也可以上手。这个版本的维护者是一个19岁的小朋友Sam Nazarko。有时间折腾的同学可以自己编译XMBC安装。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;特点：&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;免费，开源&lt;/li&gt;&#xA;&lt;li&gt;支持多语言&lt;/li&gt;&#xA;&lt;li&gt;支持1080P回放&lt;/li&gt;&#xA;&lt;li&gt;支持直接播放NFS，SMB，FTP,HTTP或USB硬盘的有视频文件，支持大多数格式&lt;/li&gt;&#xA;&lt;li&gt;支持AirPlay或AirTune功能，可以把iPhone/iPad上的视频或音乐通过Pi投放到电视上，这点和Apple TV功能一样&lt;/li&gt;&#xA;&lt;li&gt;支持GPIO&lt;/li&gt;&#xA;&lt;li&gt;基于Debian，可以从Debian的软件源安装其它软件&lt;/li&gt;&#xA;&lt;li&gt;支持1080P DTS软解，这个不少播放器是不支持的，需要额外License&lt;/li&gt;&#xA;&lt;li&gt;内置了以下服务:&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Samba&lt;/li&gt;&#xA;&lt;li&gt;TVHeadend Server&lt;/li&gt;&#xA;&lt;li&gt;FTP Server&lt;/li&gt;&#xA;&lt;li&gt;SSH Server&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;安装&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;Windows下载&lt;a href=&#34;http://download.raspbmc.com/downloads/bin/installers/raspbmc-win32.zip&#34;&gt;安装程序&lt;/a&gt;，运行即可。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.raspbmc.com/wp-content/uploads/2012/06/ins-300x165.jpg&#34; alt=&#34;image&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Linux/Mac:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -O http://svn.stmlabs.com/svn/raspbmc/testing/installers/python/install.py&#xA;chmod +x install.py&#xA;sudo python install.py&#xA;&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://www.raspbmc.com/wp-content/uploads/2012/06/installPython.png&#34; alt=&#34;image&#34; /&gt;&#xA;&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;或直接下载&lt;a href=&#34;http://download.raspbmc.com/downloads/bin/ramdistribution/installer.img.gz&#34;&gt;安装包&lt;/a&gt;安装&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;下载&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;你可以在Pi上外接一个USB移动硬盘，但要注意硬盘要有自己电源，也可以mount网络上的硬盘分区。然后运行transmission软件下载视频。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;Transmission&lt;/h4&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install transmission-daemon&#xA;sudo /etc/init.d/transmission-daemon stop&#xA;sudo nano /etc/transmission-daemon/settings.json&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    “rpc-whitelist”: “127.0.0.1″, to “rpc-whitelist”: “*.*.*.*”,&#xA;    “rpc-password”: “password”, to “rpc-password”: “替换成管理密码“,&#xA;    “rpc-username”: “username”, to “rpc-username”: “替换成管理用户“,   &#xA;    “download-dir”：“\/home\/xbmc\/Videos\/Downloads”,&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    sudo chmod g+rw /home/xbmc/Videos/Downloads&#xA;    sudo chgrp -R debian-transmission /home/xbmc/Videos/Downloads   &#xA;    sudo /etc/init.d/transmission-daemon start&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;24x7开始下载，耗电量很低的，这是下载界面：&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BErnJ-6CcAEVYsV.jpg:large&#34; alt=&#34;image&#34; /&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;遥控和播放&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;遥控方案有两种：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;p&gt;红外接收器 + 电视/DVD/VCD/EVD等已有遥控器，&lt;a href=&#34;http://forum.stmlabs.com/showthread.php?tid=5549&#34;&gt;这里&lt;/a&gt;有一个实现方案&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;通过网络用手机来遥控，其实就是用任何一个xmbc的客户端&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;iPhone: &lt;a href=&#34;https://itunes.apple.com/us/app/unofficial-official-xbmc-remote/id520480364?ls=1&amp;amp;mt=8&#34;&gt;Offical XBMC Remote&lt;/a&gt; 免费的&lt;/li&gt;&#xA;&lt;li&gt;Android: &lt;a href=&#34;http://code.google.com/p/android-xbmcremote/&#34;&gt;Android XBMC Remote&lt;/a&gt; 免费的&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;参考文章:&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.raspbmc.com/about/&#34;&gt;http://www.raspbmc.com/about/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>Java并发包中的同步队列SynchronousQueue实现原理</title>
      <link>http://hugozhu.myalert.info/2013/03/05/java-SynchronousQueue-notes.html</link>
      <pubDate>2013-03-05 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java 6的并发编程包中的&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html&#34;&gt;SynchronousQueue&lt;/a&gt;是一个没有数据缓冲的&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/BlockingQueue.html&#34;&gt;BlockingQueue&lt;/a&gt;，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的&lt;strong&gt;线程&lt;/strong&gt;，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后&lt;strong&gt;一起&lt;/strong&gt;离开。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;实现原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;同步队列的实现方法有许多：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;阻塞算法实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;阻塞算法实现通常在内部采用一个锁来保证多个线程中的put()和take()方法是串行执行的。采用锁的开销是比较大的，还会存在一种情况是线程A持有线程B需要的锁，B必须一直等待A释放锁，即使A可能一段时间内因为B的优先级比较高而得不到时间片运行。所以在高性能的应用中我们常常希望规避锁的使用。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class NativeSynchronousQueue&amp;lt;E&amp;gt; {&#xA;    boolean putting = false;&#xA;    E item = null;&#xA;&#xA;    public synchronized E take() throws InterruptedException {&#xA;        while (item == null)&#xA;            wait();&#xA;        E e = item;&#xA;        item = null;&#xA;        notifyAll();&#xA;        return e;&#xA;    }&#xA;&#xA;    public synchronized void put(E e) throws InterruptedException {&#xA;        if (e==null) return;&#xA;        while (putting)&#xA;            wait();&#xA;        putting = true;&#xA;        item = e;&#xA;        notifyAll();&#xA;        while (item!=null)&#xA;            wait();&#xA;        putting = false;&#xA;        notifyAll();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;信号量实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;经典同步队列实现采用了三个信号量，代码很简单，比较容易理解：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class SemaphoreSynchronousQueue&amp;lt;E&amp;gt; {&#xA;    E item = null;&#xA;    Semaphore sync = new Semaphore(0);&#xA;    Semaphore send = new Semaphore(1);&#xA;    Semaphore recv = new Semaphore(0);&#xA;&#xA;    public E take() throws InterruptedException {&#xA;        recv.acquire();&#xA;        E x = item;&#xA;        sync.release();&#xA;        send.release();&#xA;        return x;&#xA;    }&#xA;&#xA;    public void put (E x) throws InterruptedException{&#xA;        send.acquire();&#xA;        item = x;&#xA;        recv.release();&#xA;        sync.acquire();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在多核机器上，上面方法的同步代价仍然较高，操作系统调度器需要上千个时间片来阻塞或唤醒线程，而上面的实现即使在生产者put()时已经有一个消费者在等待的情况下，阻塞和唤醒的调用仍然需要。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 5实现&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;public class Java5SynchronousQueue&amp;lt;E&amp;gt; {&#xA;    ReentrantLock qlock = new ReentrantLock();&#xA;    Queue waitingProducers = new Queue();&#xA;    Queue waitingConsumers = new Queue();&#xA;    &#xA;    static class Node extends AbstractQueuedSynchronizer {&#xA;        E item;&#xA;        Node next;&#xA;        &#xA;        Node(Object x) { item = x; }&#xA;        void waitForTake() { /* (uses AQS) */ }&#xA;           E waitForPut() { /* (uses AQS) */ }&#xA;    }&#xA;    &#xA;    public E take() {&#xA;        Node node;&#xA;        boolean mustWait;&#xA;        qlock.lock();&#xA;        node = waitingProducers.pop();&#xA;        if(mustWait = (node == null))&#xA;           node = waitingConsumers.push(null);&#xA;         qlock.unlock();&#xA;    &#xA;        if (mustWait)&#xA;           return node.waitForPut();&#xA;        else&#xA;            return node.item;&#xA;    }&#xA;    &#xA;    public void put(E e) {&#xA;         Node node;&#xA;         boolean mustWait;&#xA;         qlock.lock();&#xA;         node = waitingConsumers.pop();&#xA;         if (mustWait = (node == null))&#xA;             node = waitingProducers.push(e);&#xA;         qlock.unlock();&#xA;        &#xA;         if (mustWait)&#xA;             node.waitForTake();&#xA;         else&#xA;            node.item = e;&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Java 5的实现相对来说做了一些优化，只使用了一个锁，使用队列代替信号量也可以允许发布者直接发布数据，而不是要首先从阻塞在信号量处被唤醒。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java6实现&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java 6的SynchronousQueue的实现采用了一种性能更好的&lt;strong&gt;无锁算法&lt;/strong&gt; &amp;ndash; 扩展的“&lt;a href=&#34;http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html&#34;&gt;Dual stack and Dual queue&lt;/a&gt;”算法。性能比Java5的实现有较大提升。竞争机制支持公平和非公平两种：非公平竞争模式使用的数据结构是后进先出栈(Lifo Stack)；公平竞争模式则使用先进先出队列（Fifo Queue），性能上两者是相当的，一般情况下，Fifo通常可以支持更大的吞吐量，但Lifo可以更大程度的保持线程的本地化。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码实现里的Dual Queue或Stack内部是用链表(LinkedList)来实现的，其节点状态为以下三种情况：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;持有数据 - put()方法的元素&lt;/li&gt;&#xA;&lt;li&gt;持有请求 - take()方法&lt;/li&gt;&#xA;&lt;li&gt;空&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;这个算法的特点就是任何操作都可以根据节点的状态判断执行，而不需要用到锁。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其核心接口是Transfer，生产者的put或消费者的take都使用这个接口，根据第一个参数来区别是入列（栈）还是出列（栈）。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;    /**&#xA;     * Shared internal API for dual stacks and queues.&#xA;     */&#xA;    static abstract class Transferer {&#xA;        /**&#xA;         * Performs a put or take.&#xA;         *&#xA;         * @param e if non-null, the item to be handed to a consumer;&#xA;         *          if null, requests that transfer return an item&#xA;         *          offered by producer.&#xA;         * @param timed if this operation should timeout&#xA;         * @param nanos the timeout, in nanoseconds&#xA;         * @return if non-null, the item provided or received; if null,&#xA;         *         the operation failed due to timeout or interrupt --&#xA;         *         the caller can distinguish which of these occurred&#xA;         *         by checking Thread.interrupted.&#xA;         */&#xA;        abstract Object transfer(Object e, boolean timed, long nanos);&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;TransferQueue实现如下(摘自Java 6源代码)，入列和出列都基于Spin和CAS方法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;        /**&#xA;         * Puts or takes an item.&#xA;         */&#xA;        Object transfer(Object e, boolean timed, long nanos) {&#xA;            /* Basic algorithm is to loop trying to take either of&#xA;             * two actions:&#xA;             *&#xA;             * 1. If queue apparently empty or holding same-mode nodes,&#xA;             *    try to add node to queue of waiters, wait to be&#xA;             *    fulfilled (or cancelled) and return matching item.&#xA;             *&#xA;             * 2. If queue apparently contains waiting items, and this&#xA;             *    call is of complementary mode, try to fulfill by CAS&#39;ing&#xA;             *    item field of waiting node and dequeuing it, and then&#xA;             *    returning matching item.&#xA;             *&#xA;             * In each case, along the way, check for and try to help&#xA;             * advance head and tail on behalf of other stalled/slow&#xA;             * threads.&#xA;             *&#xA;             * The loop starts off with a null check guarding against&#xA;             * seeing uninitialized head or tail values. This never&#xA;             * happens in current SynchronousQueue, but could if&#xA;             * callers held non-volatile/final ref to the&#xA;             * transferer. The check is here anyway because it places&#xA;             * null checks at top of loop, which is usually faster&#xA;             * than having them implicitly interspersed.&#xA;             */&#xA;&#xA;            QNode s = null; // constructed/reused as needed&#xA;            boolean isData = (e != null);&#xA;&#xA;            for (;;) {&#xA;                QNode t = tail;&#xA;                QNode h = head;&#xA;                if (t == null || h == null)         // saw uninitialized value&#xA;                    continue;                       // spin&#xA;&#xA;                if (h == t || t.isData == isData) { // empty or same-mode&#xA;                    QNode tn = t.next;&#xA;                    if (t != tail)                  // inconsistent read&#xA;                        continue;&#xA;                    if (tn != null) {               // lagging tail&#xA;                        advanceTail(t, tn);&#xA;                        continue;&#xA;                    }&#xA;                    if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0)        // can&#39;t wait&#xA;                        return null;&#xA;                    if (s == null)&#xA;                        s = new QNode(e, isData);&#xA;                    if (!t.casNext(null, s))        // failed to link in&#xA;                        continue;&#xA;&#xA;                    advanceTail(t, s);              // swing tail and wait&#xA;                    Object x = awaitFulfill(s, e, timed, nanos);&#xA;                    if (x == s) {                   // wait was cancelled&#xA;                        clean(t, s);&#xA;                        return null;&#xA;                    }&#xA;&#xA;                    if (!s.isOffList()) {           // not already unlinked&#xA;                        advanceHead(t, s);          // unlink if head&#xA;                        if (x != null)              // and forget fields&#xA;                            s.item = s;&#xA;                        s.waiter = null;&#xA;                    }&#xA;                    return (x != null)? x : e;&#xA;&#xA;                } else {                            // complementary-mode&#xA;                    QNode m = h.next;               // node to fulfill&#xA;                    if (t != tail || m == null || h != head)&#xA;                        continue;                   // inconsistent read&#xA;&#xA;                    Object x = m.item;&#xA;                    if (isData == (x != null) ||    // m already fulfilled&#xA;                        x == m ||                   // m cancelled&#xA;                        !m.casItem(x, e)) {         // lost CAS&#xA;                        advanceHead(h, m);          // dequeue and retry&#xA;                        continue;&#xA;                    }&#xA;&#xA;                    advanceHead(h, m);              // successfully fulfilled&#xA;                    LockSupport.unpark(m.waiter);&#xA;                    return (x != null)? x : e;&#xA;                }&#xA;            }&#xA;        }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;参考文章&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/SynchronousQueue.html&#34;&gt;Javadoc of SynchronousQueue&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf&#34;&gt;Scalable Synchronous Queues&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html&#34;&gt;Nonblocking Concurrent Data Structures with Condition Synchronization&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>OpenVPN使用多个端口</title>
      <link>http://hugozhu.myalert.info/2013/03/02/openvpn-multiple-ports.html</link>
      <pubDate>2013-03-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Openvpn本身不能设置多个端口，使用iptables可以解决这个问题 （假设openvpn本来56788端口）：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;for port in {56780..56787}&#xA;do &#xA;    iptables -t nat -A PREROUTING -p tcp -d &amp;lt;your_external_ip&amp;gt; --dport $port -j REDIRECT --to-port 56788&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>在Ubuntu上配置L2TP，PPTP和OpenVPN服务</title>
      <link>http://hugozhu.myalert.info/2013/03/01/setup-l2tp-pptp-openvpn-on-ubuntu.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;MacOS, Windows, iOS都内置支持PPTP，L2TP；OpenVPN需要安装客户端，手机上一般不支持。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;先打开内核的IP转发，修改 /etc/sysctl.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;net.ipv4.ip_forward=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面命令以生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo sysctl -p&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;PPTP&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装pptpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install pptpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/pptpd.conf，下面两行取消注释&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;localip 192.168.0.1&#xA;remoteip 192.168.0.234-238,192.168.0.245&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这行注释掉&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#logwtmp &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;从文件 /etc/pptpd.conf 中找到配置选项文件，如下为：/etc/ppp/pptpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;grep options /etc/pptpd.conf&#xA;#       Specifies the location of the PPP options file.&#xA;#       By default PPP looks in &#39;/etc/ppp/options&#39;&#xA;option /etc/ppp/pptpd-options&#xA;#       option in the pppd options file, or run bcrelay.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑 /etc/ppp/pptpd-options，增加以下内容，最后两项为推给VPN客户端的DNS服务器IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;mtu 1492&#xA;name pptpd&#xA;refuse-pap&#xA;refuse-chap&#xA;refuse-mschap&#xA;require-mschap-v2&#xA;require-mppe-128&#xA;proxyarp&#xA;lock&#xA;nobsdcomp&#xA;novj&#xA;novjccomp&#xA;nologfd &#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    pptpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE&#xA;iptables -A INPUT -i lo -j ACCEPT&#xA;iptables -A INPUT -i tap+ -j ACCEPT&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tap+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -P FORWARD ACCEPT    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;L2TP Over IPSec&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;假设你的服务器IP是：&lt;strong&gt;1.2.3.4&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先更新一下源&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get update&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装openswan&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openswan&#xA;&#xA;sudo cp /etc/ipsec.d/examples/l2tp-psk.conf /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件 /etc/ipsec.d/l2tp-psk.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;left=1.2.3.4 #机器的外部IP&#xA;leftnexthop=1.2.3.1 #机器的Gateway&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.conf，在文件最后增加：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;include /etc/ipsec.d/l2tp-psk.conf&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ipsec.secrets&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;1.2.3.4 %any: &amp;quot;yourSharedPSK!&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;安装 xl2tpd&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;apt-get install xl2tpd&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/xl2tpd/xl2tpd.conf , 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;[global]&#xA;ipsec saref = yes&#xA;listen-addr = 1.2.3.4&#xA;&#xA;[lns default]&#xA;ip range = 192.168.1.10-192.168.1.20&#xA;local ip = 192.168.1.1&#xA;;require chap = yes&#xA;refuse chap = yes&#xA;refuse pap = yes&#xA;require authentication = yes&#xA;ppp debug = yes&#xA;pppoptfile = /etc/ppp/xl2tpd-options&#xA;length bit = yes    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;配置 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cp /etc/ppp/options /etc/ppp/xl2tpd-options&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/xl2tpd-options&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;asyncmap 0&#xA;auth&#xA;crtscts&#xA;lock&#xA;hide-password&#xA;modem&#xA;mru 1280&#xA;netmask 255.255.255.0&#xA;mtu 1280&#xA;name l2tpd&#xA;proxyarp&#xA;lcp-echo-interval 30&#xA;lcp-echo-failure 4&#xA;noipx&#xA;ms-dns 8.8.8.8&#xA;ms-dns 8.8.4.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 /etc/ppp/chap-secrets， 增加一个VPN用户: foo ，密码设置为: bar&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# Secrets for authentication using CHAP&#xA;# client        server  secret                  IP addresses     &#xA;foo    l2tpd   bar   *&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改 iptable，注意eth0可能要修改成实际的网络接口名（用 ifconfig 可以列出）, 其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -A INPUT -p 50 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 500 -j ACCEPT&#xA;iptables -A INPUT -p udp -d 1.2.3.4 --dport 4500 -j ACCEPT&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;OpenVPN&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装Openvpn&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install openvpn    &#xA;&#xA;cp -r /usr/share/doc/openvpn/examples/easy-rsa/ /etc/openvpn/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;生成CA证书&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd /etc/openvpn/easy-rsa/2.0&#xA;source vars&#xA;./clean-all&#xA;./build-ca&#xA;./build-key-server server&#xA;./build-key client&#xA;./build-dh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;编辑/etc/openvpn/server.conf&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;local 116.251.211.71    &#xA;port 56788    &#xA;proto tcp    &#xA;dev tun&#xA;ca /etc/openvpn/easy-rsa/2.0/keys/ca.crt&#xA;cert /etc/openvpn/easy-rsa/2.0/keys/server.crt&#xA;key /etc/openvpn/easy-rsa/2.0/keys/server.key      &#xA;dh  /etc/openvpn/easy-rsa/2.0/keys/dh1024.pem    &#xA;server 10.8.0.0 255.255.255.0    &#xA;ifconfig-pool-persist ipp.txt&#xA;push &amp;quot;redirect-gateway def1&amp;quot;    &#xA;push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;&#xA;push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;    &#xA;client-to-client&#xA;keepalive 10 120&#xA;comp-lzo    &#xA;max-clients 50    &#xA;user nobody&#xA;group nogroup    &#xA;persist-key&#xA;persist-tun    &#xA;status openvpn-status.log    &#xA;log-append  openvpn.log    &#xA;verb 3    &#xA;mute 20    &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;设置iptable，其中1.2.3.4改成服务器的外部IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;iptables -F&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o venet0 -j MASQUERADE&#xA;&#xA;iptables -A INPUT -p tcp -m state --state NEW --dport 22 -j ACCEPT&#xA;iptables -t nat -A PREROUTING -p udp -m udp --dport 53 -j DNAT --to-destination 8.8.8.8&#xA;&#xA;iptables -A INPUT -p udp --dport 1194 -j ACCEPT&#xA;iptables -A INPUT -s 10.8.0.0/24 -p all -j ACCEPT&#xA;iptables -A FORWARD -d 10.8.0.0/24 -j ACCEPT&#xA;&#xA;iptables -A INPUT -i tun+ -j ACCEPT&#xA;iptables -A FORWARD -i tun+ -j ACCEPT&#xA;iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j SNAT --to-source 1.2.3.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>Java的资源管理</title>
      <link>http://hugozhu.myalert.info/2013/03/01/resource-management-in-java.html</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;try-catch-finally&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &amp;ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如&lt;a href=&#34;http://findbugs.sourceforge.net&#34;&gt;&lt;strong&gt;FindBugs&lt;/strong&gt;&lt;/a&gt;可以帮助发现此类问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先我们来看一段文件操作代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String from, String to) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    in = new FileInputStream(from);  &#xA;    out = new FileOutputStream(to);  &#xA;    int c;  &#xA;    while ((c = in.read()) != -1)&#xA;        out.write(c);  &#xA;    in.close();&#xA;    out.close();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-&lt;a href=&#34;http://zh.wikipedia.org/wiki/文件描述符&#34;&gt;文件描述符&lt;/a&gt;，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/File_descriptor&#34;&gt;File descriptor&lt;/a&gt;&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;https://pbs.twimg.com/media/BEUt3v3CEAAeP-m.jpg:large&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;较为正确的代码应该是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);&#xA;    } finally {&#xA;         try {&#xA;             if (in!=null) {&#xA;                in.close();&#xA;             }&#xA;         } finally {&#xA;             if (out!=null) {&#xA;                out.close();&#xA;             }&#xA;         }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但是这样的代码写起来是不是让人有点沮丧？这样写代码犯错的可能性确实比较大。&#xA;改良过后的代码阅读性好一些：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try {&#xA;        in = new FileInputStream(src);  &#xA;        out = new FileOutputStream(dest);  &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;    } finally {&#xA;        FileUtils.close(in);&#xA;        FileUtils.close(out);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;让我们也看看在其他语言里是怎么实现的：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Ruby：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;def copy(src, dest)&#xA;    File.open(dest, &#39;w&#39;) do |f|  &#xA;        f.write(File.read(src))&#xA;    end  &#xA;end&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Ruby的File.open 方法接受一个函数作为参数，执行该函数后，会保证打开的文件被关闭，即使在执行函数过程中有异常。相比之下这种代码优美多了有没有？&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Golang：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;func copy(src string, dest string) {&#xA;    src_file, err := os.Open(src)&#xA;    if err != nil { panic(err) }&#xA;    defer src_file.Close()&#xA;&#xA;    dest_file, err := os.Open(dest)&#xA;    if err != nil { panic(err) }&#xA;    defer dest_file.Close() &#xA;&#xA;    buf := make([]byte,1024)&#xA;&#xA;    for {&#xA;        n, err := src_file.Read(buf)&#xA;        if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err) }&#xA;        if n == 0 {break}&#xA;&#xA;        if _, err:= dest_file.Write(buf[:n]); err != nil {&#xA;           panic(err)&#xA;        } &#xA;    }       &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Go语言通过defer关键词来保证程序结束时相应的方法会被调用，嗯，你还是要显示的写Close()方法，但有一点改进就是你可以在打开后立刻写关闭语句，只要加上defer关键词。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Clojure：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;defn copy[src dest] ( &#xA;   (with-open [rdr (reader src)&#xA;               wrtr (writer dest)]&#xA;      (doseq [line (line-seq rdr)]&#xA;          (.write wrtr line))))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Clojure通过with-open函数来保证打开的文件在异常情况下也会被关闭&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Java 7：&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;private void copy(String src, String dest) throws IOException {&#xA;    FileInputStream in = null;  &#xA;    FileOutputStream out = null;  &#xA;    try (FileInputStream in = new FileInputStream(src);  &#xA;         FileOutputStream out = new FileOutputStream(dest)) {            &#xA;        int c;  &#xA;        while ((c = in.read()) != -1)&#xA;            out.write(c);  &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;终于Java 7通过自动资源管理较好的解决了这个问题，try()代码块内的变量在离开时候会自动调用AutoCloseable接口必须实现的close()方法。java.lang.AutoCloseable接口是在Java 7内新增的。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;独占资源和并发访问&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;锁&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;读写锁&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;信号量&lt;/h3&gt;&#xA;&#xA;&lt;h3&gt;连接池&lt;/h3&gt;&#xA;&#xA;&lt;h2&gt;作业&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;参考链接&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/articles/java/trywithresources-401775.html&#34;&gt;Better Resource Management with Java SE 7: Beyond Syntactic Sugar&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>在线广告系统架构变迁</title>
      <link>http://hugozhu.myalert.info/2013/02/28/the-evolution-of-online-advertsing-system.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;&lt;em&gt;（未完）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;广告按业务划分有以下几类：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;展示广告（Banner广告）&lt;/li&gt;&#xA;&lt;li&gt;搜索广告（关键词广告）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;按计费模式有：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;CPT: 按有效广告展示天数计费，可定价或竞价；&lt;/li&gt;&#xA;&lt;li&gt;CPM: 按有效广告展现次数计费，可定价或竞价；&lt;/li&gt;&#xA;&lt;li&gt;CPC: 按有效点击次数计费；&lt;/li&gt;&#xA;&lt;li&gt;CPS: 按效果计费，如，按成交订单额，按流量带来的有效下载或安装次数计费；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;广告系统按结构可划分为以下子系统：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;广告投送服务器&lt;/li&gt;&#xA;&lt;li&gt;广告数据库及业务系统&lt;/li&gt;&#xA;&lt;li&gt;用户行为跟踪系统&lt;/li&gt;&#xA;&lt;li&gt;日志传输系统&lt;/li&gt;&#xA;&lt;li&gt;流式数据分析和计算平台&lt;/li&gt;&#xA;&lt;li&gt;离线数据分析和计算平台&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;从展示广告到搜索广告再到社会化广告&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;早期的互联网广告以展示广告为主，业务模式和在报纸，期刊上刊登广告相似，广告主按其广告的展现次数或时长来付费。直到1998年有个叫GoTo的公司（后公司改名为Overture，2005年被Yahoo收购）开始提供关键词广告，这是一种简单高效的定向广告，广告主可以按与其业务相关的关键词购买搜索流量，按访客的点击计费，和早期的展示广告相比这无疑是一个巨大的进步，通过关键词将用户和广告关联起来，而不是在广告位上一直展现同样的广告或随机的展现。随后Google迅速的采用了这个方法将自身的搜索流量变现，并不断优化和壮大，最终形成了Google的Adword产品，早期Google并不为搜索用户建立个性化数据，因此可用于定向的数据比较有限，于是Google又推出了AdSense产品，将触角伸向了全网，通过AdSense的合作网站，Google可以采集到访客在这些网站的访问足迹，并利用这些数据提高其广告的相关性；随着以Facebook为代表的社交网络的兴起，这些网站有个特点就是自身就具备了比较完善的用户个性化数据，利用这些数据，网站可以将定向技术使用到展示广告，这使展示广告迎来了第二春，广告产业对数据的应用价值有了极大的兴趣，也催化了大数据的技术广泛应用。近年来一种新的广告业务模式&amp;ndash;“实时竞价广告交易系统”也逐渐被网站主和广告主接受，其核心目的是让每次广告展现都创造出尽可能多的回报，以自动化的方式系统使用实时数据和竞价信息将广告空间分配给那一时刻出价最高的销售渠道。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;广告系统的架构变迁&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;早期的展示广告系统因为业务数据量不大，广告位按时长售卖。系统架构上比较简单。系统核心为关系数据库，广告主通过业务系统管理广告数据：账户设置，广告计划，预算，推广单元，广告创意等；通过审核后可以投放的数据进入广告投放服务器。简单的广告系统可以完全围绕数据库来实现。投放服务器直接访问数据库获取需要投放的广告数据，并通过缓存来提高性能，减少对数据库的压力。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图[简单的广告系统架构]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当广告系统里的广告主越来越多，广告位的流量越来越大，直接访问数据库的做法不能满足性能和扩展性的要求，主要原因是传统的关系数据库的设计目标是通用的需求。这种情况下广告系统可以定时将广告数据从数据库中导出，生成的数据文件通过网络传到投放服务器，投放服务器将数据文件载入内存供快速访问，当用户打开网站页面时候，部署在广告位的代码（可部署在客户端或服务器端）将参数传给广告投放服务器，投放服务器按一定策略和逻辑取出需要展现给用户的广告数据，按接口规范直接返回给用户浏览器渲染，或返回给调用广告引擎的服务器端程序，再由服务器端程序将广告嵌入内容页面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;图[改进后的简单的广告系统架构]&lt;/p&gt;&#xA;&#xA;&lt;p&gt;对于中小以内容或服务吸引访客的网站来说，广告是作为其运营收入的一部分，&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;接入大型广告网络&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;Google AdSense&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;淘宝联盟&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;部署开源广告系统&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;OpenX&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;使用第三方广告托管系统&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;百度广告管家&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;淘宝TanX&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;自主开发&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;广告系统模块&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;广告投放服务器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告投放服务器的规模是和流量以及广告数据量成正比的。当广告数据规模较小时，一台服务器的内存就能放下所有数据，如果同时这台服务器也能承担所有广告请求流量，那投放系统就能简化到一台机器；如果一台服务器不能承担所有流量，那么可以复制出同样的多台服务器共同承担广告请求流量，并在这个集群前使用负载均衡设备将流量均匀的分配给集群内的服务器；如果数据量太大以致于单机存不下所有数据，那么可以将广告数据按一定维度分区，存在一组服务器上，这组服务器提供不同分区的访问，对外则通过统一的接口供访问，调用者首先根据分区维度的参数值确定该分区的服务器，再向该服务器直接调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;随着软硬件的不断升级和优化，现代的普通商用服务器单台每秒可处理几千次的广告请求。在实现上选用高性能的Web服务器，如Nginx或Lighttpd，可以支撑大量并发连接，降低处理每个广告请求的系统消耗。如果对性能的有极端的要求，有些广告系统甚至会自主开发Web服务器（如采用Erlang，C语言等），或裁剪通用开源Web服务器不需要的功能，而只保留核心功能。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;K/V内存数据库&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告投放服务器对性能要求非常高，从收到广告请求到返回广告数据只有十几毫秒的时间完成决策和数据封装，而数据在内存中的读取速度相对最快，所以在广告投放服务器中，需要投放的广告数据都会保存在基于K/V的内存数据库中供快速读取。内存数据库和关系数据库中的数据通过消息队列保持同步，开源的K/V数据库有Memcache和Redis等。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;关系数据库&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告系统需要采用关系数据库来存储结构化的数据，如：广告计划，推广单元，创意等。这些是至关重要的核心数据，对数据安全性要求很高，要求即使在出现硬件损坏的情况下，客户的数据仍然能保证完整。业界一般采用两种方法存储这些核心数据：采用商业关系数据库如：Oracle，或采用开源数据库如：Mysql或Postgresql。商业数据库功能完善，但价格往往不菲，当广告系统规模变大后，成比例上升的软件成本不可小觑，所以会逐渐转向采用开源的Mysql，其高可用性则通过多个集群及实时复制技术来保证。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在广告系统中对广告数据的管理会通过一个或多个基于Web的应用来实现。通常采用J2EE或LAMP开发框架来开发。随着互联网广告的广泛和深入使用，广告的业务系统功能也越来越多且复杂，从架构上广告业务系统也朝着服务化和开放方向发展。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;消息中间件&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;广告数据在关系数据库的更新需要反应到投放服务器中的内存数据库，从而更新访客看到的广告。一般来说广告主对数据同步的延迟是有一定要求的，现代的广告系统也越来越往实时同步方向发展。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;CDN&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;对于带有图片或视频等富媒体内容的广告创意，为了让访客的浏览器能较快的下载广告内容，需要将这些内容文件放在离访客地理位置较近的服务器上，这正是CDN系统的优势，广告系统往往需要租用或自己搭建CDN系统。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;RPC框架&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;大型广告系统在实现服务化后，需要进行分布式通信的服务器越来越多，采用较好的RPC框架，可使得系统各个模块之间的通信方法标准化, 简化业务开发。这里介绍一下Facebook开源的Thrift框架。Thrift是一种高效的、支持多种编程语言的远程服务调用的框架。互联网上比较流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。Thrift则采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;流式分布式计算平台&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Storm是Twitter开源出来的实时计算框架。可用于广告的防作弊，过滤无效展现PV和点击，也可用于实时广告费用结算等业务。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;离线分布式计算平台&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;大型广告平台的数据量非常大，受众用户和网页都在亿级，广告量级在百万，而且数据之间还有各种关联关系，必须能通过一个分布式计算平台才能处理。Hadoop是Apache开源组织的一个大数据分布式计算框架，在很多大型网站上都已经得到了广泛的应用：如Amazon，Facebook和Yahoo，国内的阿里巴巴也建有节点超过千台的Hadoop集群，用于淘宝，支付宝，阿里金融等业务数据的分析。广告系统可以利用Hadoop分析广告展现日志和点击日志，计算每个广告在一定时间跨度内的展现量，点击量，有效展现，有效点击，平均点击消耗费用，转化率等广告主报表数据；有很多的算法计算都可以采用Hadoop平台来实现。Hadoop的核心思想是Map/Reduce模型，其计算流程类似于Unix的Pipe:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;input | map | shuffle &amp;amp; sort | reduce | output&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Hadoop之上有Hive，Pig等简易数据分析接口，还有类Google Bigtable的开源实现HBase&amp;ndash;高可靠、高性能、面向列、可伸缩的分布式存储系统。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Java程序的日志</title>
      <link>http://hugozhu.myalert.info/2013/02/28/logging-in-java.html</link>
      <pubDate>2013-02-28 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;对程序运行情况的记录和监控；&lt;/li&gt;&#xA;&lt;li&gt;在必要时可详细了解程序内部的运行状态；&lt;/li&gt;&#xA;&lt;li&gt;对系统性能的影响尽量小；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;日志规范&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。&#xA;首先我们有必要了解一下Linux普遍使用的&lt;a href=&#34;http://en.wikipedia.org/wiki/Syslog&#34;&gt;Syslog&lt;/a&gt;标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面是部分常见的Syslog模块类型：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;模块ID&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;kern&lt;/td&gt;&#xA;&lt;td&gt;内核消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;user&lt;/td&gt;&#xA;&lt;td&gt;用户级别消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;mail&lt;/td&gt;&#xA;&lt;td&gt;邮件系统&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;daemon&lt;/td&gt;&#xA;&lt;td&gt;系统后台守护程序&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;auth&lt;/td&gt;&#xA;&lt;td&gt;安全/鉴权消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;syslog&lt;/td&gt;&#xA;&lt;td&gt;syslogd内部产生的日志消息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;…&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;以及Syslog严重程度划分：&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;严重程度&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;0&lt;/td&gt;&#xA;&lt;td&gt;Emergency&lt;/td&gt;&#xA;&lt;td&gt;emerg(panic)&lt;/td&gt;&#xA;&lt;td&gt;紧急，系统已经不稳定了&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;1&lt;/td&gt;&#xA;&lt;td&gt;Alert&lt;/td&gt;&#xA;&lt;td&gt;alert&lt;/td&gt;&#xA;&lt;td&gt;需要立刻采取措施&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;2&lt;/td&gt;&#xA;&lt;td&gt;Critical&lt;/td&gt;&#xA;&lt;td&gt;crit&lt;/td&gt;&#xA;&lt;td&gt;严重情况&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;3&lt;/td&gt;&#xA;&lt;td&gt;Error&lt;/td&gt;&#xA;&lt;td&gt;err (error)&lt;/td&gt;&#xA;&lt;td&gt;系统出错&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;4&lt;/td&gt;&#xA;&lt;td&gt;Warning&lt;/td&gt;&#xA;&lt;td&gt;warning(warn)&lt;/td&gt;&#xA;&lt;td&gt;系统警告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;5&lt;/td&gt;&#xA;&lt;td&gt;Notice&lt;/td&gt;&#xA;&lt;td&gt;notice&lt;/td&gt;&#xA;&lt;td&gt;系统仍然正常，但值得注意&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;6&lt;/td&gt;&#xA;&lt;td&gt;Informational&lt;/td&gt;&#xA;&lt;td&gt;info&lt;/td&gt;&#xA;&lt;td&gt;正常系统通告&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;7&lt;/td&gt;&#xA;&lt;td&gt;Debug&lt;/td&gt;&#xA;&lt;td&gt;debug&lt;/td&gt;&#xA;&lt;td&gt;系统调试信息&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;p&gt;在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Java日志框架&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架太多了。。。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logging.apache.org&#34;&gt;&lt;strong&gt;Log4j&lt;/strong&gt;&lt;/a&gt; 或 &lt;a href=&#34;http://logging.apache.org/log4j/2.x/&#34;&gt;&lt;strong&gt;Log4j 2&lt;/strong&gt;&lt;/a&gt; - Apache的开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；用户也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，用户能够更加细致地控制日志的生成过程。这些可以通过一个配置文件（XML或Properties文件）来灵活地进行配置，而不需要修改程序代码。Log4j 2则是前任的一个升级，参考了Logback的许多特性；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://logback.qos.ch&#34;&gt;&lt;strong&gt;Logback&lt;/strong&gt;&lt;/a&gt; - Logback是由log4j创始人设计的又一个开源日记组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如log4j或JDK14 Logging；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://docs.oracle.com/javase/6/docs/api/java/util/logging/package-summary.html&#34;&gt;&lt;strong&gt;java.util.logging&lt;/strong&gt;&lt;/a&gt; - JDK内置的日志接口和实现，功能比较简单&amp;hellip;；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org&#34;&gt;&lt;strong&gt;Slf4j&lt;/strong&gt;&lt;/a&gt; - SLF4J是为各种Logging API提供一个简单统一的接口），从而使用户能够在部署的时候配置自己希望的Logging API实现；&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging/&#34;&gt;&lt;strong&gt;Apache Commons Logging&lt;/strong&gt;&lt;/a&gt; - Apache Commons Logging （JCL）希望解决的问题和Slf4j类似。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;选项太多了的后果就是选择困难症，我的看法是没有最好的，只有最合适的。在比较关注性能的地方，选择Logback或自己实现高性能Logging API可能更合适；在已经使用了Log4j的项目中，如果没有发现问题，继续使用可能是更合适的方式；我一般会在项目里选择使用Slf4j, 如果不想有依赖则使用java.util.logging或框架容器已经提供的日志接口。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Java日志最佳实践&lt;/h2&gt;&#xA;&#xA;&lt;h3&gt;定义日志变量&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;日志变量往往不变，最好定义成final static，变量名用大写。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;日志分级&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Java的日志框架一般会提供以下日志级别，缺省打开info级别，也就是debug，trace级别的日志在生产环境不会输出，在开发和测试环境可以通过不同的日志配置文件打开debug级别。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;fatal&lt;/strong&gt; - 严重的，造成服务中断的错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;error&lt;/strong&gt; - 其他错误运行期错误；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;warn&lt;/strong&gt; -  警告信息，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;info&lt;/strong&gt; -  有意义的事件信息，如程序启动，关闭事件，收到请求事件等；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;debug&lt;/strong&gt; - 调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;trace&lt;/strong&gt; - 更详细的跟踪信息；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;在程序里要合理使用日志分级:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;//调试的时候可以知道进入了方法&#xA;LOGGER.debug(&amp;quot;entering getting content&amp;quot;);&#xA;String content = CacheManager.getCachedContent();&#xA;if (content == null) {&#xA;&#xA;    //使用warn，因为程序还可以继续执行，但类似警告太多可能说明缓存服务不可用了，值得引起注意&#xA;    LOGGER.warn(&amp;quot;Got empty content from cache, need perform database lookup&amp;quot;); &#xA;&#xA;    Connection conn = ConnectionFactory.getConnection();&#xA;    if (conn == null) {&#xA;        LOGGER.error(&amp;quot;Can&#39;t get database connection, failed to return content&amp;quot;); //尽量提供详细的信息，知道错误的原因，而不能简单的写logger.error(&amp;quot;failed&amp;quot;)&#xA;    } else {&#xA;        try {&#xA;            content = conn.query(...);&#xA;        } catch (IOException e) {&#xA;            //异常要记录错误堆栈&#xA;            LOGGER.error(&amp;quot;Failed to perform database lookup&amp;quot;, e);&#xA;        } finally {&#xA;            ConnectionFactory.releaseConnection(conn);&#xA;        }&#xA;    }&#xA;}&#xA;//调试的时候可以知道方法返回了&#xA;LOGGER.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;return content;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面这段示范代码演示了各种级别的使用，但其中有个问题是debug日志太多后可能会影响性能？有一种改进方法是：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (LOGGER.isDebugEnabled()) {&#xA;    LOGGER.debug(&amp;quot;returning content: &amp;quot;+ content);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;但更好的方法是Slf4j提供的&lt;a href=&#34;http://www.slf4j.org/faq.html#logging_performance&#34;&gt;最佳实践&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;LOGGER.debug(&amp;quot;returning content: {}&amp;quot;, content);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;一方面可以减少参数构造的开销，另一方面也不用多写两行代码；&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;有意义的日志&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通常情况下在程序日志里记录一些比较有意义的状态数据：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;程序启动，退出的时间点；&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;程序运行消耗时间；&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;long startTime = System.currentTime();          &#xA;// business logical          &#xA;LOGGER.info(&amp;quot;execution cost : &amp;quot; + (System.currentTime() - startTime) + &amp;quot;ms&amp;quot;);　      &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;耗时程序的执行进度，不然程序开始运行后半天没一点输出挺让人着急啊~&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;重要变量的状态变化。&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h3&gt;日志安全&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;日志中尽量不要包含敏感信息，对于敏感信息如用户身份证号码，密码可以加密后存储；以防止日志文件不慎外泄时保全用户的数据安全；日志通常不允许修改，必要时还可以通过校验位来鉴别日志是否正确。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;日志监控方法&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;错误日志需要设置监控才能及时发现问题，所以在程序里记录日志的时候也需要考虑这点。&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;错误次数&lt;/li&gt;&#xA;&lt;li&gt;错误等级&lt;/li&gt;&#xA;&lt;li&gt;错误关联的数据&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;应用名&lt;/li&gt;&#xA;&lt;li&gt;用户ID&lt;/li&gt;&#xA;&lt;li&gt;时间&lt;/li&gt;&#xA;&lt;li&gt;IP&lt;/li&gt;&#xA;&lt;li&gt;发生错误的页面&lt;/li&gt;&#xA;&lt;/ol&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;作业&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;TODO：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;参考链接&lt;/h3&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://www.slf4j.org/manual.html&#34;&gt;http://www.slf4j.org/manual.html&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&#34;&gt;http://commons.apache.org/proper/commons-logging//guide.html#JCL_Best_Practices&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://wikipedia.org/wiki/syslog&#34;&gt;http://wikipedia.org/wiki/syslog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>使用Github合作开发项目</title>
      <link>http://hugozhu.myalert.info/2013/02/27/collaborating-development-with-github.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文大部分内容来自： &lt;a href=&#34;https://help.github.com/categories/63/articles&#34;&gt;https://help.github.com/categories/63/articles&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Github上合作开发最好的方式是“&lt;strong&gt;Fork + Pull Request&lt;/strong&gt;”。比如我最近需要一个静态Blog生成器，市面上有很多Ruby实现的，但我想要一个Go语言的实现，Github上找到了一个 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt; ，测试了一下已有的功能基本能满足了，就用上了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但实际使用过程中发现了一个问题，如果在URL中有中文，生成的URL如下没有做URL安全编码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;还有一种情况是如果URL中有空格，如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;http://hugozhu.myalert.info//2013//02/25/Java properties to enviorment variables.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;浏览器遇到这种URL时，会主动进行编码，但这里有两个问题：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;遇到中文时，浏览器是用GBK还是UTF-8还是其它字符集编码后再发送给服务器呢？&lt;/li&gt;&#xA;&lt;li&gt;遇到空格时，编码成+还是%20呢？&#xA;不同浏览器实现可能不一样，在不同操作系统上也可能不一样（可能和用户设置的缺省语言有关），这样有些用户可能会遭遇404错误了，实际上我在服务器的错误日志上的确看到这样的错误&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;日志：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;2013/02/27 20:41:33 [error] 7791#0: *3285 open() &amp;quot;.../2013/02/25/Java+properties+to+enviorment+variables.html&amp;quot; failed (2: No such file or directory), client: 221.179.193.78, server: hugozhu.myalert.info, request: &amp;quot;GET /2013/02/25/Java+properties+to+enviorment+variables.html HTTP/1.1&amp;quot;, host: &amp;quot;hugozhu.myalert.info&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;于是我需要动手修改代码：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先需要做的就是Fork一下原项目到自己的代码仓库： &lt;a href=&#34;https://github.com/hugozhu/gor&#34;&gt;https://github.com/hugozhu/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;修改好代码并提交到自己的仓库： &lt;a href=&#34;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&#34;&gt;https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;在你的代码仓库页面上点Pull Request:&#xA;&lt;img src=&#34;https://pbs.twimg.com/media/BEH7V0vCYAAMgcl.jpg:large&#34;/&gt;&lt;/li&gt;&#xA;&lt;li&gt;选择好你刚提交好的Commits，然后点发送;&lt;/li&gt;&#xA;&lt;li&gt;原项目的维护者就会收到这个Pull Request: &lt;a href=&#34;https://github.com/wendal/gor/pull/14&#34;&gt;https://github.com/wendal/gor/pull/14&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;如果你提交的代码足够好，维护者可以合并到项目主干上；&lt;/li&gt;&#xA;&lt;li&gt;记住下一次本地修改代码前要先Merge一下原作者新提交的改动;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git remote add upstream https://github.com/wendal/gor&#xA;git fetch upstream&#xA;git checkout master&#xA;git merge upstream/master &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;到此为止就完成了一次合作开发。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;==&lt;/p&gt;&#xA;&#xA;&lt;h1&gt;我们日常的项目开发中也可以采用这种思路，代码Review也可以增加Pull Request，对项目的迭代速度会有很大帮助。&lt;/h1&gt;&#xA;</description>
    </item>
    <item>
      <title>在Pi和Github上搭建自己的个人博客</title>
      <link>http://hugozhu.myalert.info/2013/02/27/%E5%9C%A8Pi%E5%92%8CGithub%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;方法如下：&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;本站同时托管在家里的&lt;a href=&#34;http://www.raspberrypi.org&#34;&gt;Raspberry Pi&lt;/a&gt;和&lt;a href=&#34;http://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;上，并同步保持更新，海外用户会访问Github，国内用户则会访问Pi，不同线路解析域名&lt;strong&gt;hugozhu.myalert.info&lt;/strong&gt;到不同的服务器是通过&lt;a href=&#34;http://dnspod.cn&#34;&gt;DnsPod&lt;/a&gt;的服务实现的，这么好的服务还是免费的，这里推荐一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因为Github Pages只能支持静态网页，你需要一个能生成静态网页的博客生成引擎。我使用的是&lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor&lt;/a&gt; ， 也可以使用&lt;a href=&#34;http://ruhoh.com&#34;&gt;ruhoh&lt;/a&gt;，&lt;a href=&#34;https://www.google.com/search?q=static+blog+generator&amp;amp;hl=en&amp;amp;newwindow=1&amp;amp;client=safari&amp;amp;rls=en&amp;amp;biw=1238&amp;amp;bih=868&amp;amp;ei=msAuUY-vDMKO2AWQ7IHoBQ&amp;amp;sqi=2&amp;amp;start=10&amp;amp;sa=N&#34;&gt;Google一下还有很多&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;静态页面博客的好处：&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;性能是最好的，很合适用Raspberry Pi来做服务器，节省资源；&lt;/li&gt;&#xA;&lt;li&gt;文章可以用Markdown格式来编写，采用Github来做版本控制，我的Blog仓库在 &lt;a href=&#34;http://github.com/hugozhu/blog&#34;&gt;http://github.com/hugozhu/blog&lt;/a&gt; ，数据安全很好，误删除也不担心了；&lt;/li&gt;&#xA;&lt;li&gt;很容易找到托管环境，方便迁移；&lt;/li&gt;&#xA;&lt;li&gt;用Gor在Pi上生成速度很快；再用Nginx提供Web服务，可以直接在Pi上写Blog；&lt;/li&gt;&#xA;&lt;li&gt;大繁至简&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;Github设置&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在你的仓库里增加一个your_github_id.github.com，比如我的github ID是hugozhu，相应的仓库名就是&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com&#34;&gt;hugozhu.github.com&lt;/a&gt;，这个仓库也就是网站的根目录了，在这里放生成好的静态文件&lt;/li&gt;&#xA;&lt;li&gt;如果你需要用自己的域名，而不是Github提供的，可以在根目录下增加一个&lt;a href=&#34;https://github.com/hugozhu/hugozhu.github.com/blob/master/CNAME&#34;&gt;CNAME&lt;/a&gt;文件,文件内容则是你的域名，在DnsPod上需要建一个CNAME记录，将你的域名指向your_github_id.github.com. 也就是github原来分配给你的，完成这个设置后，访问your_github_id.github.com会跳转到你的域名；&lt;/li&gt;&#xA;&lt;li&gt;每次更新后，Github会在10分钟内生效。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;更新博客&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Gor的使用详细说明可见 &lt;a href=&#34;https://github.com/wendal/gor&#34;&gt;https://github.com/wendal/gor&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;我的整个网站的内容也通过Github开源了: &lt;a href=&#34;https://github.com/hugozhu/blog&#34;&gt;https://github.com/hugozhu/blog&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;以我的网站为例：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone https://github.com/hugozhu/blog&#xA;    Cloning into &#39;blog&#39;...&#xA;    remote: Counting objects: 190, done.&#xA;    remote: Compressing objects: 100% (146/146), done.&#xA;    remote: Total 190 (delta 81), reused 132 (delta 23)&#xA;    Receiving objects: 100% (190/190), 155.48 KiB | 171 KiB/s, done.&#xA;    Resolving deltas: 100% (81/81), done.&#xA;cd blog&#xA;gor compile&#xA;    2013/02/27 13:17:19 gor.go:21: gor ver 2.1&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : default&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : page&#xA;    2013/02/27 13:17:19 payload.go:572: Load Layout : post&#xA;    2013/02/27 13:17:19 config.go:61: Look lile a Json, try it&#xA;    2013/02/27 13:17:19 config.go:64: It is Json Map&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/analytics/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/comments/config.yml&#xA;    2013/02/27 13:17:19 widgets.go:111: Load widget from  widgets/google_prettify/config.yml&#xA;    2013/02/27 13:17:19 compile.go:125: Done&#xA;cd compiled&#xA;git init&#xA;git add -A &#xA;git commit -m &amp;quot;update website&amp;quot; .&#xA;git remote add origin hugozhu@github.com:hugozhu/hugozhu.github.com&#xA;git push -u origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后等待10分钟，再打开 &lt;a href=&#34;http://hugozhu.github.com&#34;&gt;http://hugozhu.github.com&lt;/a&gt; 就好了。。。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Raspberry Pi设置&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装nginx&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install nginx&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;修改文件：/etc/nginx/sites-enabled/default，增加下面内容&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;server {&#xA;    server_name hugozhu.myalert.info;&#xA;&#xA;    root /home/pi/blog/compiled;&#xA;&#xA;    location / {&#xA;        ssi on;&#xA;    }     &#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;重新启动nginx，这样在Pi上也有一个你的个人博客了，方便自己访问，这里有个小小的技巧是可以通过server side include给静态页面增加动态内容，上面的配置在首页上打开了此功能，这样我可以在页底加上如下代码来显示访问者的IP&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;!--# echo var=&amp;quot;remote_addr&amp;quot; default=&amp;quot;no&amp;quot; --&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;最后重启Nginx生效&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/nginx restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h1&gt;TODO:&lt;/h1&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;实现一个简单的Web界面，可以通个Web界面来保存Blog，并重现编译和更新到Github；&#xA;&amp;gt; 已部分实现：在Github的博客仓库里可以直接创建或修改文件，用Go写了一个HTTP接口，curl一下后可更新，&lt;/li&gt;&#xA;&lt;li&gt;微博到博客的快速发布；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
    </item>
    <item>
      <title>动态DNS程序</title>
      <link>http://hugozhu.myalert.info/2013/02/26/dynamic-dns-script.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;动态根据宽带public ip更新dnspod登记的域名&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;按照 &lt;a href=&#34;https://gist.github.com/833369&#34;&gt;https://gist.github.com/833369&lt;/a&gt; 逻辑重新用Go实现了，用更少的内存开销在Raspberry Pi上跑。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;替换上你的Email，密码，域名ID，记录ID等参数，就可以运行了。 会在后台一直运行，每隔30秒检查一遍IP，如果修改了就更新IP。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;获得domain_id可以用：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl curl -k https://dnsapi.cn/Domain.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;获得record_id：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;curl -k https://dnsapi.cn/Record.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;  &amp;quot;io/ioutil&amp;quot;&#xA;  &amp;quot;log&amp;quot;&#xA;  &amp;quot;net&amp;quot;&#xA;  &amp;quot;net/http&amp;quot;&#xA;  &amp;quot;net/url&amp;quot;&#xA;  &amp;quot;strings&amp;quot;&#xA;  &amp;quot;time&amp;quot;&#xA;)&#xA;&#xA;var (&#xA;    body = url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {&amp;quot;email&amp;quot;},&#xA;        &amp;quot;login_password&amp;quot;: {&amp;quot;password&amp;quot;},&#xA;        &amp;quot;format&amp;quot;:         {&amp;quot;json&amp;quot;},&#xA;        &amp;quot;domain_id&amp;quot;:      {&amp;quot;0&amp;quot;},&#xA;        &amp;quot;record_id&amp;quot;:      {&amp;quot;0&amp;quot;},&#xA;        &amp;quot;sub_domain&amp;quot;:     {&amp;quot;www&amp;quot;},&#xA;        &amp;quot;record_line&amp;quot;:    {&amp;quot;默认&amp;quot;},&#xA;    }&#xA;    current_ip     = &amp;quot;&amp;quot;&#xA;    check_interval = 30 * time.Second&#xA;)&#xA;&#xA;var current_ip = &amp;quot;&amp;quot;&#xA;&#xA;func get_public_ip() (string, error) {&#xA;    conn, err := net.DialTimeout(&amp;quot;tcp&amp;quot;, &amp;quot;ns1.dnspod.net:6666&amp;quot;, timeout*time.Second)&#xA;    defer func() {&#xA;        if x := recover(); x != nil {&#xA;            log.Println(&amp;quot;Can&#39;t get public ip&amp;quot;, x)&#xA;        }&#xA;        if conn!=nil {&#xA;            conn.Close()&#xA;        }&#xA;    }()&#xA;&#xA;    if err == nil {&#xA;        var bytes []byte&#xA;        deadline := time.Now().Add(timeout*time.Second)&#xA;        err = conn.SetDeadline(deadline)&#xA;        if err!=nil {&#xA;            return &amp;quot;&amp;quot;, err&#xA;        }&#xA;        bytes, err = ioutil.ReadAll(conn)&#xA;        if err == nil {&#xA;            return string(bytes), nil&#xA;        }&#xA;    }&#xA;    return &amp;quot;&amp;quot;, err&#xA;}&#xA;&#xA;func timeoutDialler(timeout time.Duration) func(net, addr string) (c net.Conn, err error) {&#xA;    return func(netw, addr string) (net.Conn, error) {&#xA;        c, err := net.DialTimeout(netw, addr, timeout)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        deadline := time.Now().Add(timeout)&#xA;        err = c.SetDeadline(deadline)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        return c, nil&#xA;    }&#xA;}&#xA;&#xA;func update_dnspod(ip string) bool {&#xA;    client := &amp;amp;http.Client{&#xA;        Transport: &amp;amp;http.Transport{&#xA;            Dial: timeoutDialler(timeout * time.Second),&#xA;        },&#xA;    }&#xA;    body := url.Values{&#xA;        &amp;quot;login_email&amp;quot;:    {login_email},&#xA;        &amp;quot;login_password&amp;quot;: {login_password},&#xA;        &amp;quot;format&amp;quot;:         {format},&#xA;        &amp;quot;domain_id&amp;quot;:      {domain_id},&#xA;        &amp;quot;record_id&amp;quot;:      {record_id},&#xA;        &amp;quot;sub_domain&amp;quot;:     {sub_domain},&#xA;        &amp;quot;record_line&amp;quot;:    {record_line},&#xA;        &amp;quot;value&amp;quot;:          {ip},&#xA;    }&#xA;&#xA;    req, err := http.NewRequest(&amp;quot;POST&amp;quot;, &amp;quot;https://dnsapi.cn/Record.Ddns&amp;quot;, strings.NewReader(body.Encode()))&#xA;    req.Header.Set(&amp;quot;Accept&amp;quot;, &amp;quot;text/json&amp;quot;)&#xA;    req.Header.Set(&amp;quot;Content-type&amp;quot;, &amp;quot;application/x-www-form-urlencoded&amp;quot;)&#xA;&#xA;    resp, err := client.Do(req)&#xA;&#xA;    defer resp.Body.Close()&#xA;&#xA;    if err != nil {&#xA;        return false&#xA;    }&#xA;    bytes, _ := ioutil.ReadAll(resp.Body)&#xA;    log.Println(string(bytes))&#xA;    return resp.StatusCode == 200&#xA;}&#xA;&#xA;func init() {&#xA;}&#xA;&#xA;func main() {&#xA;    for {&#xA;        ip, err := get_public_ip()&#xA;        if ip != &amp;quot;&amp;quot; &amp;amp;&amp;amp; err == nil {&#xA;            log.Println(&amp;quot;got ip:&amp;quot; + ip)&#xA;            if ip != current_ip {&#xA;                log.Println(&amp;quot;update dnspod with new ip:&amp;quot; + ip)&#xA;                if update_dnspod(ip) {&#xA;                    current_ip = ip&#xA;                }&#xA;            }&#xA;        } else {&#xA;            log.Println(&amp;quot;error:&amp;quot;, err)&#xA;        }&#xA;        time.Sleep(interval * time.Second)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>系统调试和分析工具</title>
      <link>http://hugozhu.myalert.info/2013/02/26/linux_perf_tools.html</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Linux下的调试和分析工具集&lt;/p&gt;&#xA;&#xA;&lt;hr /&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/media/tools.jpg&#34; width=&#34;600&#34;/&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>将Java的Properties文件转换成环境变量</title>
      <link>http://hugozhu.myalert.info/2013/02/25/Java%20properties%20to%20enviorment%20variables.html</link>
      <pubDate>2013-02-25 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;Overview&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在Java程序中使用properties文件很方便，但有时候需要和脚本配合使用时，需要把properties文件内的多个变量转换成环境变量，本文提供一个转换脚本示范：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;比如env.properties如下（=附近可以有空格，也可以有空行）&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&#xA;MYSQL_USER = root&#xA;MYSQL_PASS = &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;执行下面的脚本后就相当于&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;export MYSQL_URL=&amp;quot;//localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;quot;&#xA;export MYSQL_USER=&amp;quot;root&amp;quot;&#xA;export MYSQL_PASS=&amp;quot;&amp;quot; &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;env.sh脚本代码&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;&#xA;property_file=env.properties&#xA;&#xA;get_prop(){&#xA;    propfile=$1&#xA;    key=$2&#xA;    grep  &amp;quot;^${2}=&amp;quot; ${1}| sed &amp;quot;s%${2}=\(.*\)%\1%&amp;quot;&#xA;}&#xA;&#xA;trim() {&#xA;    trimmed=$1&#xA;    trimmed=${trimmed%% }&#xA;    trimmed=${trimmed## }&#xA;    echo &amp;quot;$trimmed&amp;quot;&#xA;}&#xA;&#xA;`grep -v &amp;quot;^#&amp;quot; $property_file | sed -e &#39;/^$/d&#39; | while read line&#xA;do&#xA;    key=$(echo $line | awk -F &amp;quot;=&amp;quot; &#39;{print $1}&#39;)&#xA;    trimmed_key=$(trim $key)&#xA;    trimmed_val=$(trim $(get_prop $property_file &amp;quot;$key&amp;quot;)&#xA;    echo &amp;quot;export $trimmed_key=\&amp;quot;$trimmed_val\&amp;quot;)&amp;quot;&#xA;done`&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>我的第一篇博客</title>
      <link>http://hugozhu.myalert.info/2012/new-born.html</link>
      <pubDate>2012-12-22 12:00:00 +0800</pubDate>
      <description>&lt;h1&gt;感谢使用Gor编写博客&lt;/h1&gt;&#xA;&#xA;&lt;h2&gt;本文位于 posts/first-blog.md , 你可以任何删掉,修改这个文件&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;文件开头是当前文章的元数据&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;date为自动生成, 当然,你可以修改,这是你的自由&lt;/li&gt;&#xA;&lt;li&gt;permalink 可以是固定地址,也可以由gor为你自动生成&lt;/li&gt;&#xA;&lt;li&gt;categories 就是分类, 可以多个&lt;/li&gt;&#xA;&lt;li&gt;tags 同理,多个标签也是很常见的&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;请确保文件使用UTF8 without BOM编码&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你可以通过执行下面的语句来新建一篇博客:&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor post 文章标题&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;编译你的博客,并预览之&lt;/h2&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;gor compile #编译&#xA;gor http&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后打开你的浏览器,访问 &lt;a href=&#34;http://127.0.0.1:8080&#34;&gt;http://127.0.0.1:8080&lt;/a&gt; 来预览&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你将使用Markdown来编写博客&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://wowubuntu.com/markdown/&#34;&gt;Markdown 语法中文版&lt;/a&gt; 能让你快速入门其语法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相信&lt;a href=&#34;http://markdownpad.com&#34;&gt;MarkdownPad&lt;/a&gt;或&lt;a href=&#34;http://code.google.com/p/liteide/&#34;&gt;liteide&lt;/a&gt;会是你的编写博客的好帮手&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;如果你打算部署到github的pages上&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;申请github帐户&lt;/li&gt;&#xA;&lt;li&gt;新建一个库 username.github.com 即你的用户名命名的地址&lt;/li&gt;&#xA;&lt;li&gt;将compiled目录,作为根路径,提交上去github.com上&lt;/li&gt;&#xA;&lt;li&gt;稍等几分钟, 你即可通过 &lt;a href=&#34;http://username.github.com&#34;&gt;http://username.github.com&lt;/a&gt; 访问到&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;h2&gt;附上git教程 &lt;a href=&#34;http://gitbook.liuhui998.com/&#34;&gt;GitBook中文版&lt;/a&gt;&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;一般来说,你只需要几个简单的git命令就足以应付大部分需求(仅示例)&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;git clone git://github.com/wendal/wendal.net.git&#xA;git add -A&#xA;git commit -m &amp;quot;...&amp;quot;&#xA;git pull&#xA;git push&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2&gt;用gor编写博客将会是一件很开心的事,如果有任何意见或建议,欢迎到 &lt;a href=&#34;http://github.com/wendal/gor&#34;&gt;gor的官网&lt;/a&gt; 提交issue&lt;/h2&gt;&#xA;&#xA;&lt;h1&gt;祝你使用愉快&lt;/h1&gt;&#xA;</description>
    </item>
  </channel>
</rss>