<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>并发编程之内存屏障 - All about Raspberry Pi</title>
<meta name=description content="Memory Barriers/Fences：一组处理器指令，用来实现内存数据对CPU的可见性。"><meta name=author content="Hugo Zhu"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"All about Raspberry Pi","url":"\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"\/post\/2013\/22-memory-barriers-or-fences\/","name":"并发编程之内存屏障"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":"Hugo Zhu"},"headline":"并发编程之内存屏障","description":"Memory Barriers\/Fences：一组处理器指令，用来实现内存数据对CPU的可见性。","inLanguage":"en","wordCount":149,"datePublished":"2013-03-28T00:00:00\u002b00:00","dateModified":"2013-03-28T00:00:00\u002b00:00","image":"\/img\/pi.png","keywords":["Java, Concurrent Programming, 文章翻译"],"mainEntityOfPage":"\/post\/2013\/22-memory-barriers-or-fences\/","publisher":{"@type":"Organization","name":"\/","logo":{"@type":"ImageObject","url":"\/img\/pi.png","height":60,"width":60}}}</script><meta property="og:title" content="并发编程之内存屏障"><meta property="og:description" content="Memory Barriers/Fences：一组处理器指令，用来实现内存数据对CPU的可见性。"><meta property="og:image" content="/img/pi.png"><meta property="og:url" content="/post/2013/22-memory-barriers-or-fences/"><meta property="og:type" content="website"><meta property="og:site_name" content="All about Raspberry Pi"><meta name=twitter:title content="并发编程之内存屏障"><meta name=twitter:description content="Memory Barriers/Fences：一组处理器指令，用来实现内存数据对CPU的可见性。"><meta name=twitter:image content="/img/pi.png"><meta name=twitter:card content="summary_large_image"><link href=/img/pi.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.128.2"><link rel=alternate href=/index.xml type=application/rss+xml title="All about Raspberry Pi"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.5.0/css/all.css integrity=sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=/css/highlight.min.css><link rel=stylesheet href=/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-W88HDMN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","GTM-W88HDMN")}</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>All about Raspberry Pi</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li><a title=About href=/page/about/>About</a></li><li><a title=Tags href=/tags>Tags</a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="All about Raspberry Pi" href=/><img class=avatar-img src=/img/pi.png alt="All about Raspberry Pi"></a></div></div></div></nav><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>并发编程之内存屏障</h1><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on March 28, 2013
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;1&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;149&nbsp;words</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><p>原文地址：<a href=http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html><code>http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html</code></a> 或 <a href=http://ifeve.com/memory-barriersfences/><code>http://ifeve.com/memory-barriersfences/</code></a></p><p>关键词：Load Barrier, Store Barrier, Full Barrier</p><p>本文我将和大家讨论并发编程中最基础的一项技术：内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。</p><p>CPU使用了很多优化技术来达成一个事实：CPU执行单元的速度要远超主存访问速度。在我上一篇文章 &ldquo;Write Combing - 合并写"中我已经介绍了其中的一项技术。CPU避免内存访问延迟最常见的技术是将指令管道化，然后尽量重排这些管道的执行以最大利用缓存而把因为缓存未命中引起的延迟降到最小。</p><p>当一个程序执行时指令是否被重排并不重要，只要最终的结果是一样的。例如，在一个循环里，如果循环体内没用到这个计数器，循环的计数器什么时候更新（在循环开始，中间还是最后）并不重要。编译器和CPU可以自由的重排指令以最佳的利用CPU，只要下一次循环前更新该计数器即可。并且在循环执行中，这个变量可能一直存在寄存器上，并没有被推到缓存或主存，这样这个变量对其他CPU来说一直都是不可见的。</p><p>CPU核内部包含了多个执行单元。例如，现代Intel CPU包含了6个执行单元，可以组合进行算术运算，逻辑条件判断及内存操作。每个执行单元可以执行上述任务的某种组合。这些执行单元是并行执行的，这样指令也就是在并行执行。但如果站在另一个CPU角度看，这也就产生了程序顺序的另一种不确定性。</p><p>最后，当一个缓存失效发生时，现代CPU可以先假设一个内存载入的值并根据这个假设值继续执行，直到内存载入返回确切的值。</p><img src=http://ifeve.com/wp-content/uploads/2013/03/cpu.png><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CPU核
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  V
</span></span><span class=line><span class=cl>寄存器
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  V
</span></span><span class=line><span class=cl>执行单元 -&gt; Load/Store缓冲区-&gt;L1 Cache ---&gt;L3 Cache--&gt;内存控制器--&gt;主存
</span></span><span class=line><span class=cl>       |                                   |
</span></span><span class=line><span class=cl>       +-&gt; Write Combine缓冲区-&gt;L2 Cache ---+
</span></span></code></pre></div><p>代码顺序并不是真正的执行顺序，CPU和编译器可以各种优化只要有空间提高性能。缓存和主存的读取会利用load, store和write-combining缓冲区来缓冲和重排。这些缓冲区是查找速度很快的关联队列，当一个后来发生的load需要读取上一个store的值，而该值还没有到达缓存，查找是必需的，上图描绘的是一个简化的现代多核CPU，从上图可以看出执行单元可以利用本地寄存器和缓冲区来管理和缓存子系统的交互。</p><p>在多线程环境里需要使用技术来使得程序结果尽快可见。这篇文章里我不会涉及到 Cache Conherence 的概念。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为内存屏障或内存栅栏。</p><p>内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。</p><p>大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。相对来说Intel CPU的强内存模型比DEC Alpha的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。因为x86处理器是在多线程编程中最常见的，下面我尽量用x86的架构来阐述。</p><h1 id=store-barrier>Store Barrier</h1><p>Store屏障，是x86的&rdquo;<strong>sfence</strong>&ldquo;指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。一个实际的好例子是Disruptor中的<a href=http://code.google.com/p/disruptor/source/browse/trunk/code/src/main/com/lmax/disruptor/BatchEventProcessor.java>BatchEventProcessor</a>。当序列Sequence被一个消费者更新时，其它消费者(Consumers)和生产者（Producers）知道该消费者的进度，因此可以采取合适的动作。所以屏障之前发生的内存更新都可见了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>private volatile long sequence = RingBuffer.INITIAL_CURSOR_VALUE;
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>// from inside the run() method
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>T event = null;
</span></span><span class=line><span class=cl>long nextSequence = sequence.get() + 1L;
</span></span><span class=line><span class=cl>while (running)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    try
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        final long availableSequence = barrier.waitFor(nextSequence);
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        while (nextSequence &lt;= availableSequence)
</span></span><span class=line><span class=cl>        {
</span></span><span class=line><span class=cl>            event = ringBuffer.get(nextSequence);
</span></span><span class=line><span class=cl>            boolean endOfBatch = nextSequence == availableSequence;
</span></span><span class=line><span class=cl>            eventHandler.onEvent(event, nextSequence, endOfBatch);
</span></span><span class=line><span class=cl>            nextSequence++;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>        sequence.set(nextSequence - 1L); 
</span></span><span class=line><span class=cl>        // store barrier inserted here !!!
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    catch (final Exception ex)
</span></span><span class=line><span class=cl>    {
</span></span><span class=line><span class=cl>        exceptionHandler.handle(ex, nextSequence, event);
</span></span><span class=line><span class=cl>        sequence.set(nextSequence);
</span></span><span class=line><span class=cl>        // store barrier inserted here !!!
</span></span><span class=line><span class=cl>        nextSequence++;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h1 id=load-barrier>Load Barrier</h1><p>Load屏障，是x86上的&rdquo;<strong>ifence</strong>&ldquo;指令，强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。这使得从其它CPU暴露出来的程序状态对该CPU可见，这之后CPU可以进行后续处理。一个好例子是上面的BatchEventProcessor的sequence对象是放在屏障后被生产者或消费者使用。</p><h1 id=full-barrier>Full Barrier</h1><p>Full屏障，是x86上的&rdquo;<strong>mfence</strong>&ldquo;指令，复合了load和save屏障的功能。</p><h1 id=java内存模型>Java内存模型</h1><p><a href=http://en.wikipedia.org/wiki/Java_Memory_Model>Java内存模型</a>中<strong>volatile</strong>变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。类的<strong>final</strong>字段会在初始化后插入一个store屏障来确保final字段在构造函数完成可被使用时可见。</p><h1 id=原子指令和software-locks>原子指令和Software Locks</h1><p>原子指令，如x86上的"lock . . .&rdquo; 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序。</p><h1 id=内存屏障的性能影响>内存屏障的性能影响</h1><p>内存屏障阻碍了CPU采用优化技术来降低内存操作延迟，必须考虑因此带来的性能损失。为了达到最佳性能，最好是把要解决的问题模块化，这样处理器可以按单元执行任务，然后在任务单元的边界放上所有需要的内存屏障。采用这个方法可以让处理器不受限的执行一个任务单元。合理的内存屏障组合还有一个好处是：缓冲区在第一次被刷后开销会减少，因为再填充改缓冲区不需要额外工作了。</p><div class=blog-tags><a href=/tags/java/>Java</a>&nbsp;
<a href=/tags/concurrent-programming/>Concurrent Programming</a>&nbsp;
<a href=/tags/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/>文章翻译</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=%2fpost%2f2013%2f22-memory-barriers-or-fences%2f&amp;text=%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8b%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c&amp;via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=%2fpost%2f2013%2f22-memory-barriers-or-fences%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=%2fpost%2f2013%2f22-memory-barriers-or-fences%2f&amp;title=%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8b%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=%2fpost%2f2013%2f22-memory-barriers-or-fences%2f&amp;title=%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8b%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=%2fpost%2f2013%2f22-memory-barriers-or-fences%2f&amp;title=%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8b%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=%2fpost%2f2013%2f22-memory-barriers-or-fences%2f&amp;description=%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%b9%8b%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>See also</h4><ul><li><a href=/post/2013/31-golang-memory-model/>Go语言内存模型</a></li><li><a href=/post/2013/java-synchronousqueue-notes/>Java并发包中的同步队列SynchronousQueue实现原理</a></li><li><a href=/post/2013/resource-management-in-java/>Java的资源管理</a></li><li><a href=/post/2013/logging-in-java/>Java程序的日志</a></li><li><a href=/post/2013/java-properties-to-enviorment-variables/>将Java的Properties文件转换成环境变量</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=/post/2013/21-realtime-online-user-counter/ data-toggle=tooltip data-placement=top title=个人网站实时在线人数接口>&larr; Previous Post</a></li><li class=next><a href=/post/2013/23-arduino-1st-day/ data-toggle=tooltip data-placement=top title=Arduino初试>Next Post &rarr;</a></li></ul><div class=disqus-comments><button id=show-comments class="btn btn-default" type=button>Show <span class=disqus-comment-count data-disqus-url=post/2013/22-memory-barriers-or-fences>comments</span></button><div id=disqus_thread></div><script type=text/javascript>var disqus_config=function(){this.page.url="post/2013/22-memory-barriers-or-fences"}</script></div></div></div></div><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a href=mailto:hugozhu@gmail.com title="Email me"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://www.facebook.com/hugozhu title=Facebook><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-facebook fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://github.com/hugozhu title=GitHub><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://linkedin.com/in/username title=LinkedIn><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-linkedin fa-stack-1x fa-inverse"></i></span></a></li><li><a href=https://weibo.com/hugozhu title=Weibo><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weibo fa-stack-1x fa-inverse"></i></span></a></li><li><a href title=RSS><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="credits copyright text-muted"><a href=hugozhu.site>Hugo Zhu</a>
&nbsp;&bull;&nbsp;&copy;
2024
&nbsp;&bull;&nbsp;
<a href=/>All about Raspberry Pi</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.128.2</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=/js/main.js></script><script src=/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=/js/load-photoswipe.js></script><script type=text/javascript>$(function(){$("#show-comments").on("click",function(){var e="hugozhu";(function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="//"+e+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)})(),$(this).hide()})})</script><script id=dsq-count-scr src=//hugozhu.disqus.com/count.js async></script></body></html>