<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on All about Raspberry Pi</title><link>/post/</link><description>Recent content in Posts on All about Raspberry Pi</description><generator>Hugo</generator><language>en</language><managingEditor>hugozhu@gmail.com (Hugo Zhu)</managingEditor><webMaster>hugozhu@gmail.com (Hugo Zhu)</webMaster><lastBuildDate>Sun, 07 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml"/><item><title>使用acme_docker自动更新免费域名证书</title><link>/post/2024/76-acme-docker-auto-uptime/</link><pubDate>Sun, 07 Jul 2024 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2024/76-acme-docker-auto-uptime/</guid><description>问题和解决方案 免费域名证书需要三个月更新一次 解决方案：apisix, docker, acme.sh, dnspod Apisix https://apisix.org Apisix是优秀的开源网关，更新证书不需要重启服务，可以作为所有服务的网关
Acme Docker https://github.com/hugozhu/acme_docker/blob/main/README.md 项目已配置好使用docker来更新证书并生成apisix的json
docker-compose.yaml
version: &amp;#34;3&amp;#34; services: acme: image: neilpang/acme.sh container_name: acme #restart: always command: daemon env_file: - .env volumes: - ./cert:/acme.sh 重新申请免费证书 docker-compose up -d docker exec acme acme.sh --set-default-ca --server letsencrypt docker exec acme acme.sh --issue --dns dns_dp -d hugozhu.site -d *.hugozhu.site -d *.go.hugozhu.site docker-compose down cat hugozhu.site.json apisix上更新证书 data=$( cat &amp;#34;hugozhu.site.json&amp;#34; ) curl &amp;#39;http://127.0.0.1:9180/apisix/admin/ssls/1&amp;#39; \ -H &amp;#34;X-API-KEY: $API_KEY&amp;#34; -X PUT -d &amp;#34;$data&amp;#34;`</description></item><item><title>VidHub vs. Infuse - Which one is the best video player on iOS Platform</title><link>/post/2024/75-vidhub-infuse-which-one-is-the-best/</link><pubDate>Tue, 02 Jul 2024 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2024/75-vidhub-infuse-which-one-is-the-best/</guid><description>In this post, we are going to compare two high-profile media players : VidHub and Infuse. While they all have their own advantages and disadvantages, they are all capable of providing users with a high-quality media experience in different scenarios.
Price advantage: VidHub is free to use on all iOS/Mac/tvOS platforms, which saves users a lot of money. In comparison, the price of the Infuse is on the more expensive side, and the buyout requires 698, but the dirt area will be a little more cost-effective.</description></item><item><title>R2S使用场景：基础系统Armbian，Docker安装openwrt，USB网卡做热点，无线接入通过openwrt做路由</title><link>/post/2024/74-armbian-bridge-network-hostapd/</link><pubDate>Sun, 30 Jun 2024 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2024/74-armbian-bridge-network-hostapd/</guid><description>背景 Armbian 是一款基于 Debian 或 Ubuntu 的开源操作系统，专门针对嵌入式 ARM 平台进行优化和定制。它可以运行在多种不同的嵌入式设备上，例如树莓派、R2S，R4S，玩客云等等。Armbian 针对不同的嵌入式平台，提供了相应的硬件支持，可以让用户轻松地在这些平台上搭建自己的嵌入式系统。
刚好有一块闲置了几年的R2S卡片机和树莓派2时代的无线网卡。
方案 基于最小化配置改动，尽量用docker来部署的原则。
openwrt的docker-compose文件如下，网络设置采用docker的macvlan，使得openwrt看上去像网络上的一个独立主机
version: &amp;#39;2.4&amp;#39; services: openwrt: container_name: openwrt image: piaoyizy/openwrt-aarch64:latest privileged: true ports: - 80:80 env_file: - .env networks: macnet: ipv4_address: 192.168.1.11 sysctls: - net.ipv4.ip_forward=1 # - net.ipv4.conf.all.rp_filter=0 restart: unless-stopped logging: driver: &amp;#34;json-file&amp;#34; options: max-size: &amp;#34;20m&amp;#34; max-file: &amp;#34;2&amp;#34; # ip link set end0 promisc on networks: macnet: name: macnet ipam: driver: default config: - subnet: &amp;#39;192.168.1.0/24&amp;#39; gateway: 192.168.1.1 driver: macvlan driver_opts: parent: end0 macvlan_mode: bridge 但是这样做有一个问题，是r2s反而不能访问这个docker容器（因为内核安全问题），解决的方法是增加一个本地的桥接网口，并设置路由，本机通过这个桥接网口访问，设置如下：</description></item><item><title>Ubuntu 22 Remote Desktop Sharing Without Real Monitor</title><link>/post/2024/73-ubuntu-22-remote-desktop/</link><pubDate>Tue, 20 Feb 2024 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2024/73-ubuntu-22-remote-desktop/</guid><description>xrdp solution sudo apt-get install xserver-xorg-video-dummy sudo apt-get install xserver-xorg-core Download Microsoft Remote Desktop client /usr/share/X11/xorg.conf.d/xorg.conf
Section &amp;#34;Device&amp;#34; Identifier &amp;#34;DummyDevice&amp;#34; Driver &amp;#34;dummy&amp;#34; VideoRam 256000 EndSection Section &amp;#34;Screen&amp;#34; Identifier &amp;#34;DummyScreen&amp;#34; Device &amp;#34;DummyDevice&amp;#34; Monitor &amp;#34;DummyMonitor&amp;#34; DefaultDepth 24 SubSection &amp;#34;Display&amp;#34; Depth 24 Modes &amp;#34;1920x1080_60.0&amp;#34; EndSubSection EndSection Section &amp;#34;Monitor&amp;#34; Identifier &amp;#34;DummyMonitor&amp;#34; HorizSync 30-70 VertRefresh 50-75 ModeLine &amp;#34;1920x1080&amp;#34; 148.50 1920 2448 2492 2640 1080 1084 1089 1125 +Hsync +Vsync EndSection ln -s /usr/share/X11/xorg.conf.d/xorg.conf /etc/X11 关掉账号自动登录 非常重要！</description></item><item><title>Use Rancher to manage k8s cluster</title><link>/post/2022/73-use-rancher-to-create-k8s-cluster/</link><pubDate>Tue, 16 Aug 2022 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2022/73-use-rancher-to-create-k8s-cluster/</guid><description>必要的集群内部通讯端口要在防火墙上打开 2379, 2380, 80, 443, 22, 6443, 10250
清理干净 https://rancher.com/docs/rancher/v2.5/en/cluster-admin/cleaning-cluster-nodes/ docker rm -f $(docker ps -qa) # docker rmi -f $(docker images -q) docker volume rm $(docker volume ls -q) for mount in $(mount | grep tmpfs | grep &amp;#39;/var/lib/kubelet&amp;#39; | awk &amp;#39;{ print $3 }&amp;#39;) /var/lib/kubelet /var/lib/rancher; do sudo umount $mount; done sudo rm -rf /etc/ceph \ /etc/cni \ /etc/kubernetes \ /opt/cni \ /opt/rke \ /run/secrets/kubernetes.io \ /run/calico \ /run/flannel \ /var/lib/calico \ /var/lib/etcd \ /var/lib/cni \ /var/lib/kubelet \ /var/lib/rancher/rke/log \ /var/log/containers \ /var/log/kube-audit \ /var/log/pods \ /var/run/calico sudo ip link delete flannel.</description></item><item><title>Bash-Oneliner</title><link>/post/2022/72-bash-oneliner/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2022/72-bash-oneliner/</guid><description>https://onceupon.github.io/Bash-Oneliner/#time</description></item><item><title>用Gitlab Runner来打包并上传Harbor</title><link>/post/2022/71-gitlab-runner-using-docker-build/</link><pubDate>Mon, 16 May 2022 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2022/71-gitlab-runner-using-docker-build/</guid><description>https://docs.gitlab.com/ee/ci/docker/using_docker_build.html
docker-compose.yaml version: &amp;#39;3.6&amp;#39; services: gitlab-runner: image: &amp;#39;gitlab/gitlab-runner:latest&amp;#39; restart: always volumes: - ./config:/etc/gitlab-runner - /data/gitlab-runner:/home/gitlab-runner ./config/config.toml /root/.docker/config.json 里放docker hub的授权token
concurrent = 1 check_interval = 0 [session_server] session_timeout = 1800 [[runners]] name = &amp;#34;Dev1 Docker Runner&amp;#34; url = &amp;#34;https://gitlab.xxxx.com/&amp;#34; token = &amp;#34;xxxxxxxxxxxx&amp;#34; executor = &amp;#34;docker&amp;#34; [runners.docker] tls_verify = false image = &amp;#34;docker:20.10.15&amp;#34; privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [&amp;#34;/home/hugo/.docker/config.json:/root/.docker/config.json:ro&amp;#34;,&amp;#34;/var/run/docker.sock:/var/run/docker.sock&amp;#34;, &amp;#34;/data/gitlab-runner/cache:/home/gitlab-runner/cache&amp;#34;] shm_size = 0 cache_dir = &amp;#34;/home/gitlab-runner/cache&amp;#34; .</description></item><item><title>Google Analytics 4 简介</title><link>/post/2022/70-google-analytics-101/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2022/70-google-analytics-101/</guid><description>Google Analytics 4 简介 Google Analytics（分析）可帮助您了解人们使用您的 Web、Apple 或 Android 应用的方式。SDK 会自动收集大量事件和用户属性，您也可以定义自定义事件，以便衡量对您的业务有特殊影响的因素。收集到数据后，可通过 Firebase 控制台到信息中心中查看。通过此信息中心，您可以深入、详细地了解您的数据，包括摘要数据（如活跃用户和受众特征）和更详细的数据（如识别您最畅销的商品）。
Analytics 还集成了 Firebase 的一些其他功能。例如，它自动记录与通过通知编辑器发送的通知消息相对应的事件，并就每个广告系列的影响提供报告。
Analytics 可帮助您了解用户的行为方式，以便您就如何推广您的应用制定明智的决策。您可以查看您的广告系列在自然渠道和付费渠道的效果，以了解哪些方法对于吸引高价值用户最为有效。如果您需要执行自定义分析或者将您的数据与其他源数据联接，您可以将自己的 Analytics 数据关联到 BigQuery，从而进行更复杂的分析，例如查询大型数据集以及联接多个数据源。
网站和App用户行为跟踪技术的演进 UA （Google Universal Analytics, GA3) -&amp;gt; GA4（Google Analytics 4) https://support.google.com/analytics/answer/10270783?hl=zh-Hans
GA4是UA（GA3）的一次全新的升级，测量模型从以传统的基于会话（Session）转变为事件（Event）驱动，GA3专注于在一次会话中收集和处理用户的各种行为数据（如页面展现，事件，交易），在GA4中，一次页面展现（Pageview）也被认为是一个事件，而页面的标题（Page Title）和路径（Page Path）则是事件的参数。
三种实现方案：analytics.js -&amp;gt; gtag.js -&amp;gt; GTM (Google Tag Manager)
analytics.js已不被推荐使用，GTM是目前的最佳实践。
GTM的三个优势：
可以填入第三方追踪代码，例如 Facebook/Tiktok Pixel 追踪事件 (转化) 或其他项目时候，不用工程师改代码 有代码预览，审核发布流程，适合团队协作 UA（GA3）只有一种跟踪代码类型，但GA4有两种代码类型：GA4配置代码和GA4事件代码，其中GA4配置代码的作用域范围是页面全局，用户在页面上所有交互事件共享相同的配置。运行期GA4配置代码要在事件代码触发前执行。
如果网站页面上既有gtag.js，又有GTM跟踪代码，理论上这并不会产生问题，但要注意GTM重复配置事件触发可能导致多次同一事件多次触发；另外，gtag.js的事件参数如 “cookie_prefix”, or “allow_ad_personalization_signals”会传递到GTM里配置的GA4事件。
重要概念 Segments（受众） 建立起产品受众分层是产品精准营销的基础。受众分层是使用产品用户的具体分类，可根据地区，访问设备，年龄等用户属性来分类，每一个产品都有一个目标获取的受众群体，具体的营销活动应该根据目标受众的喜好来追求ROI最大化，用户增长首先要找到最易获取的受众群体。
Segment示例：
(客层/年龄：18-24)「AND」(客层/性别：女性) 行为：工作阶段 &amp;gt; 1「AND」行为：每位使用者交易次数 &amp;gt; 1 电子商务：每位使用者收益 &amp;gt; 10「AND」电子商务：产品 = T恤 Event（事件） https://support.</description></item><item><title>在iPad上写Blog</title><link>/post/2020/69-write-your-blog-on-ipad/</link><pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2020/69-write-your-blog-on-ipad/</guid><description>iPad的创作能力越来越强，直接修改Github上的文件就可以写Blog了，方法是在Github上建一个自动更新网站的Workflow
name: Blog of hugozhu.myalert.info on: push: branches: [ master ] jobs: checks: name: run runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: token: ${{ secrets.TOKEN }} - name: Set up Go uses: actions/setup-go@v2 with: go-version: 1.16 - name: Install gor run: | go version go install github.com/hugozhu/gor/gor@latest - name: Clone blog run: | mkdir compiled git clone https://github.com/hugozhu/hugozhu.github.com compiled - name: Compile blog run: | gor compile - name: Publish blog run: | cd compiled git status git config --global user.</description></item><item><title>把树莓派4设置成路由器和热点</title><link>/post/2020/68-turn-raspberrypi-4-to-a-router-and-wifi-ap/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2020/68-turn-raspberrypi-4-to-a-router-and-wifi-ap/</guid><description>树莓派4的性能非常好，内置千兆网卡和AC无线，非常合适做路由器和热点，加上USB 3.0的接口，做NAS也绰绰有余。
iptables # Generated by xtables-save v1.8.2 on Mon Feb 17 14:33:31 2020 *mangle :PREROUTING ACCEPT [274685:225391364] :INPUT ACCEPT [228566:199191351] :FORWARD ACCEPT [24215:22886563] :OUTPUT ACCEPT [177353:197982323] :POSTROUTING ACCEPT [223529:224189656] :SS-UDP - [0:0] -A FORWARD -i wlan0 -o eth0 -j ACCEPT -A SS-UDP -d 0.0.0.0/8 -j RETURN -A SS-UDP -d 127.0.0.0/8 -j RETURN -A SS-UDP -d 10.0.0.0/8 -j RETURN -A SS-UDP -d 169.254.0.0/16 -j RETURN -A SS-UDP -d 172.16.0.0/12 -j RETURN -A SS-UDP -d 224.</description></item><item><title>用免费的Google云服务将Github项目Webhook事件通知到钉钉</title><link>/post/2016/67-use-free-google-cloud-service-to-deliver-github-webhook-events-to-dingtalk/</link><pubDate>Sun, 15 May 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/67-use-free-google-cloud-service-to-deliver-github-webhook-events-to-dingtalk/</guid><description>本教程使用Go语言来实现
+ 准备开发环境 首先你需要下载Google AppEngine的SDK：https://cloud.google.com/appengine/downloads#Google_App_Engine_SDK_for_Go
安装好后执行goapp确认已安装好
4:30:40 Hugo-Mac-mini ~/Projects/hugozhu/godingtalk $ goapp env GOARCH=&amp;#34;amd64&amp;#34; GOBIN=&amp;#34;&amp;#34; GOEXE=&amp;#34;&amp;#34; GOHOSTARCH=&amp;#34;amd64&amp;#34; GOHOSTOS=&amp;#34;darwin&amp;#34; GOOS=&amp;#34;darwin&amp;#34; GOPATH=&amp;#34;/Users/hugozhu/Projects/hugozhu/godingtalk&amp;#34; GORACE=&amp;#34;&amp;#34; GOROOT=&amp;#34;/Users/hugozhu/Projects/share/go_appengine/goroot&amp;#34; GOTOOLDIR=&amp;#34;/Users/hugozhu/Projects/share/go_appengine/goroot/pkg/tool/darwin_amd64&amp;#34; GO15VENDOREXPERIMENT=&amp;#34;1&amp;#34; CC=&amp;#34;clang&amp;#34; GOGCCFLAGS=&amp;#34;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fno-common&amp;#34; CXX=&amp;#34;clang++&amp;#34; CGO_ENABLED=&amp;#34;1&amp;#34; Checkout代码 export GOPATH=`pwd` 14:34:49 Hugo-Mac-mini ~/Projects/hugozhu/github_alert $ go get github.com/hugozhu/godingtalk/demo/github/appengine package appengine: unrecognized import path &amp;#34;appengine&amp;#34; (import path does not begin with hostname) package appengine/memcache: unrecognized import path &amp;#34;appengine/memcache&amp;#34; (import path does not begin with hostname) package appengine/urlfetch: unrecognized import path &amp;#34;appengine/urlfetch&amp;#34; (import path does not begin with hostname) 修改配置 cd src/github.</description></item><item><title>从树莓派上发消息到手机或桌面钉钉</title><link>/post/2016/66-use-dingtalk-golang-sdk-to-send-message-on-pi/</link><pubDate>Mon, 02 May 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/66-use-dingtalk-golang-sdk-to-send-message-on-pi/</guid><description>钉钉是阿里巴巴专为中小企业和团队打造的沟通、协同的多端平台，钉钉开放平台旨在为企业提供更为丰富的办公协同解决方案。通过钉钉开放平台，企业或第三方合作伙伴可以帮助企业快速、低成本的实现高质量的移动微应用，实现生产、管理、协作、运营的移动化。
访问钉钉开放平台的文档，请戳此
下面将介绍如何使用钉钉开放平台SDK在树莓派上发送消息到手机和桌面钉钉。
准备工作 首先，你需要在钉钉上创建一个组织，点这里开始
注册好后创建微应用
获取微应用的 agentid
获取 corpid和corpsecret，非常重要
下载钉钉SDK 这里我们使用Go语言版的钉钉开放平台SDK，这样可以直接在树莓派上编译运行
export GOPATH=`pwd` go get github.com/hugozhu/godingtalk 企业应用消息发送代码 下面的代码使用钉钉开放平台的企业应用消息接口来发送消息
package main import ( &amp;#34;github.com/hugozhu/godingtalk&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { c := godingtalk.NewDingTalkClient(os.Getenv(&amp;#34;corpid&amp;#34;), os.Getenv(&amp;#34;corpsecret&amp;#34;)) c.RefreshAccessToken() err := c.SendAppMessage(os.Args[1], os.Args[2], os.Args[3]) if err != nil { log.Println(err) } } 将上面的代码保存在src/push.go里，执行go build src/push.go生成可执行文件push，并复制到~/bin目录下
消息发送脚本 在准备工作中获取到的corpid,corpsecret 和 agentid这里就有用了
创建一个push.sh文件，内容如下：
#!/bin/sh export corpid=&amp;lt;corpid&amp;gt; export corpsecret=&amp;lt;corpsecret&amp;gt; timeout 10 ~/bin/push &amp;lt;agentid&amp;gt; &amp;#34;@all&amp;#34; &amp;#34;$1&amp;#34; 使用消息发送脚本 push.sh &amp;#34;树莓派发来的钉钉消息&amp;#34; 通过这个脚本就可以在树莓派上发消息到钉钉上了</description></item><item><title>用Grafana制作树莓派上的监控大盘</title><link>/post/2016/65-running-grafana-on-raspberry-pi-3/</link><pubDate>Sun, 24 Apr 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/65-running-grafana-on-raspberry-pi-3/</guid><description>Grafana是一个优秀的开源图表系统，支持多种数据源，其中包括 InfluxDB和Prometheus
安装 export GOPATH=`pwd` go get github.com/grafana/grafana cd $GOPATH/src/github.com/grafana/grafana go run build.go setup # (only needed once to install godep) $GOPATH/bin/godep restore # (will pull down all golang lib dependencies in your current GOPATH) go run build.go build # (or &amp;#39;go build .&amp;#39;) 编译好后会在bin目录下生成grafana-server和grafana-cli
第二步需要生成资源文件，但是从源代码编译会遇到phantomjs-prebuild依赖包不存在arm版本的问题，可以直接下载windows版本解开里面的public目录到bin/public下
启动 在bin/conf下拷贝生成defaults.ini文件，执行 ./grafana-server即可
配置 用浏览器打开 http://&amp;lt;pi:ip&amp;gt;:3000 用帐号：admin，密码：admin 登录
首先要配置好Prometheus数据源：
下面是获取网络的上下行流量数据的采集脚本，通过Prometheus Push Gateway提交，可以每5分钟运行一次
DATA=`ifconfig eth1 | grep bytes | sed &amp;#39;s/:/ /g&amp;#39; | awk &amp;#39;{print &amp;#34;bytes_rx &amp;#34;$3&amp;#34;\nbytes_tx &amp;#34;$8}&amp;#39;` cat &amp;lt;&amp;lt;EOF | curl --data-binary @- http://pi3:9091/metrics/job/raspberrypi/instance/test $DATA EOF 然后在Grafana里可以按下图方式增加一个每小时网络流量的图表，increase(bytes_rx[1h])是Prometheus所支持的查询表达式。</description></item><item><title>树莓派3变身iBeacon发射器</title><link>/post/2016/63-raspberrypi-as-ibeacon-transmitter/</link><pubDate>Tue, 19 Apr 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/63-raspberrypi-as-ibeacon-transmitter/</guid><description>iBeacon是apple公司提出的“一种可以让附近手持电子设备检测到的一种新的低功耗、低成本信号传送器”的一套可用于室内定位系统的协议。iBeacon技术通过低功耗蓝牙（BLE），也就是我们所说的智能蓝牙来实现。
设置 树莓派3内置了蓝牙芯片，最新的Raspian也已经安装好bluez，所以基本上不用什么设置，就可以把树莓派3当做iBeacon基站来使用了。
通过以下命令可以确认蓝牙芯片工作正常
hugo@raspberrypi3:~ $ sudo hciconfig hci0:	Type: BR/EDR Bus: UART BD Address: B8:27:EB:BF:E0:C5 ACL MTU: 1021:8 SCO MTU: 64:1 UP RUNNING RX bytes:3841 acl:0 sco:0 events:239 errors:0 TX bytes:5213 acl:0 sco:0 commands:237 errors:0 脚本 iBeacon使用的是BLE技术，具体而言，利用的是BLE中名为“通告帧”（Advertising）的广播帧。通告帧是定期发送的帧，只要是支持BLE的设备就可以接收到。iBeacon通过在这种通告帧的有效负载部分嵌入苹果自主格式的数据来实现。 iBeacon的数据主要由四种资讯构成，分别是UUID（通用唯一标识符）、Major、Minor、Measured Power。 UUID是规定为ISO/IEC11578:1996标准的128位标识符。 Major和Minor由iBeacon发布者自行设定，都是16位的标识符。比如，连锁店可以在Major中写入区域资讯，可在Minor中写入个别店铺的ID等。另外，在家电中嵌入iBeacon功能时，可以用Major表示产品型号，用Minor表示错误代码，用来向外部通知故障。 Measured Power是iBeacon模块与接收器之间相距1m时的参考接收信号强（RSSI：Received Signal Strength Indicator）。接收器根据该参考RSSI与接收信号的强度来推算发送模块与接收器的距离。
iBeacon发射的信号格式如下：
消息头 1E 02 # Number of bytes that follow in first AD structure 01 # Flags AD type 1A # Flags value 0x1A = 000011010 bit 0 (OFF) LE Limited Discoverable Mode bit 1 (ON) LE General Discoverable Mode bit 2 (OFF) BR/EDR Not Supported bit 3 (ON) Simultaneous LE and BR/EDR to Same Device Capable (controller) bit 4 (ON) Simultaneous LE and BR/EDR to Same Device Capable (Host) 1A # Number of bytes that follow in second (and last) AD structure Vendor的标识 FF # Manufacturer specific data AD type 4C 00 # Company identifier code (0x004C == Apple) 02 # Byte 0 of iBeacon advertisement indicator 15 # Byte 1 of iBeacon advertisement indicator 通告帧信息 F6 BC 15 E0 93 90 46 67 9B E1 86 6E C8 A1 99 DC # our iBeacon proximity uuid 00 00 # Major 00 00 # Minor C8 00 # Calibrated Tx power 以下脚本会随机生成一个UUID和相应的iBeacon发射命令</description></item><item><title>在树莓派3上搭建监控系统</title><link>/post/2016/64-set-up-monitor-system-with-prometheus-on-raspberry/</link><pubDate>Sun, 17 Apr 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/64-set-up-monitor-system-with-prometheus-on-raspberry/</guid><description>之前用过tsar做监控，但没有基于浏览器的图表展示，而且tsar收集数据很频繁，容易写坏SD卡。后来一直用Xively SaaS服务，但因为服务在国外，访问速度一直不尽人意。直到今天早上读到InfoQ的一篇文章才知道了Prometheus，看了一下介绍后发现Prometheus的以下特点非常合适在树莓派上部署：
采用Go实现支持，天然支持跨平台，配置相当简单，维护和二次开发的成本小； 采集数据支持Pull和Push模式，可以自定义不同采集点的采样频率，适合轻量型应用降低能耗； 二次计算和查询方式很灵活 自带 Grafana数据可视化工具； 可配置的内存+磁盘存储大小，采用的时间序列文件和Level DB做索引效率较高，不会让监控软件本身消耗过多的树莓派计算和存储资源 监控系统架构 安装 Prometheus采集数据的主要方式是通过HTTP到指定的URL上定时采集，为了支持Push方式收集数据，我们还需要安装一个Prometheus Pushgateway作为HTTP服务器来给Prometheus提供数据，你的应用则可以通过命令行或编程接口方式将数据推送到Pushgateway
安装Prometheus 到 https://prometheus.io/download/ 选择armv7架构后可以直接下载树莓派3可运行的版本，解压后可以直接运行；缺省配置文件将监控Prometheus自身。
安装Prometheus Pushgateway 假设你在树莓派上已经安装好了Go
git clone https://github.com/prometheus/pushgateway.git cd pushgateway.git export GOPATH=`pwd` go get -d go build *.go 编译成功后在当前目录下会生成可执行文件：bindata
配置 Prometheus启动后，缺省用9090 HTTP端口，Prometheus Pushgateway则是9091 HTTP端口, 以下文件配置了每15秒定时抓取Pushgateway上的监控数据。
hugo@raspberrypi3:~/prometheus $ cat prometheus.yml # my global config global: scrape_interval: 15s # By default, scrape targets every 15 seconds. evaluation_interval: 15s # By default, scrape targets every 15 seconds. # scrape_timeout is set to the global default (10s).</description></item><item><title>树莓派3初体验</title><link>/post/2016/62-raspberrypi-3/</link><pubDate>Wed, 13 Apr 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/62-raspberrypi-3/</guid><description>树莓派基金会今年推出的新品Raspberry Pi 3已经到手，官方宣传性能比树莓派2代快50%，比树莓派1代快10倍，第一次使用的64位四核处理器（博通BCM2837）配备了ARM Cortex-A53处理器，内置了802.11 b/g/n 2.4GHz WIFI和蓝牙4.1，显卡没变，还是双核VideoCore IV（并不支持4K视频）。CPU升级也对能耗有了更高的要求，官方说法最好是使用5V 2.5A的电源输入（iPad充电器），实测在无外设的情况下，2A的电流输出也可以让Pi 3正常运行。价格和树莓派2也一样，官方售价税前35美金，国内可以在淘宝上买到，238元一枚，点此购买
我深深的认为每个程序员都需要有一块树莓派，24*7的运行在家里的网络上 ，投入成本在300人民币以内（树莓派加电源：250，SD卡：50），每年电费在10元以内。树莓派支持各种编程语言的开发，安装体验各种操作系统非常简单，丰富的外部接口，支持很多类型的传感器和控制器外设，可以让你轻松设计和实现智能硬件，技术让生活更美好~
外观 树莓派3的规格大小则和树莓派2完全一样，你甚至可以直接用树莓派2的外壳，完全贴合。
背面看略有不同，中间的芯片是1G内存，树莓派3的内存速度快了1倍，右边是CF卡插槽，树莓派2是回弹式卡槽（取出CF卡时只要往力再摁一下就会弹出），树莓派3可能为了降低成本或是因为板卡空间的问题改成了更紧凑的插入式，装上外壳后取出的时候有点费劲，我需要用瑞士军刀的镊子夹出来。
（下图是树莓派3）
安装启动 如果你不需要GUI,推荐安装Raspbian Jessie Lite，大小只有298.3M，下载完成后解压缩成img文件后用dd命令写到CF卡上去。你也可以下载NOOBS完整安装。
WIFI 编辑无线配置文件/etc/wpa_supplicant/wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 network={ ssid=&amp;#34;&amp;lt;无线AP的名称&amp;gt;&amp;#34; psk=&amp;#34;&amp;lt;无线密码&amp;gt;&amp;#34; } 如果有多个无线网络可以接入，增加network即可
修改好后如果没有自动生效连上网络可以通过以下命令强制生效
ifdown wlan0 ifup wlan0 非常重要的一点是：如果你希望无线网络一直连接，需要关闭掉无线模块的电源管理，否则没有网络流量后，WIFI会自动关闭。。。
sudo iwconfig wlan0 power off 测试wifi速度：从通过网线连接到极路由2的Mac拷贝文件到树莓派3上，内置网卡的传输速度在4MB/s左右，如果换上300Mbps的USB无线网卡EDUP EP-N1557则可以达到9MB/s左右，速度要快1倍。结论是内置的wifi模块速度只有150Mbps，如果对网络速度要求较高，最稳定的方法还是插根网线。
安装好nginx后，用ab测试最简单的HTML网页性能，树莓派3可以轻松超过1000 QPS，满足个人网站的性能需求。
CPU 树莓派3使用的4核Cortex-A53 BCM2837 SoC为了向下兼容，架构上和树莓派2使用的4核Cortex-A7 BCM2836差不多，在32位模式运行下，速度要快50~60%（时钟频率1.2GHz vs 900MHz），尽管CPU已经支持64位，官方的操作系统Raspbian还是32位，当然树莓派3内存只有1G，运行64位操作系统可能会有点累,。 如果要体验真64位系统，目前可以考虑带2G内存，千兆网口的ODROID-C2，可装Ubuntu 16.04和Android 5.1。
一般情况下，不带散热片的CPU温度在45度左右，我有个脚本会每五分钟上传一下温度：https://personal.xively.com/feeds/1480103458
Node.js 安装5.0.0
wget https://nodejs.org/dist/v5.0.0/node-v5.0.0-linux-armv7l.tar.gz tar -xvf node-v5.0.0-linux-armv7l.tar.gz cd node-v5.0.0-linux-armv7l sudo cp -R * /usr/local/ 升级</description></item><item><title>用iptables搭建稳定的加速代理</title><link>/post/2016/61-smart-router-with-iptable/</link><pubDate>Wed, 06 Apr 2016 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2016/61-smart-router-with-iptable/</guid><description>设置步骤 在阿里云中国和美国都购买一个VPS，用同样的操作系统，都安装好 shadowsocks-libev ( https://github.com/shadowsocks/shadowsocks-libev )
编辑配置文件 config.json 如下： { &amp;#34;server&amp;#34;:&amp;#34;&amp;lt;your_ip_address&amp;gt;&amp;#34;, &amp;#34;local_address&amp;#34;:&amp;#34;0.0.0.0&amp;#34;, &amp;#34;server_port&amp;#34;:10080, &amp;#34;local_port&amp;#34;:1080, &amp;#34;password&amp;#34;:&amp;#34;password&amp;#34;, &amp;#34;method&amp;#34;:&amp;#34;bf-cfb&amp;#34;, &amp;#34;timeout&amp;#34;:600 } 在美国的服务器上执行： nohup ss-server config.json &amp;amp; 在中国的服务器上执行： nohup ss-redir config.json &amp;amp; 在中国的服务器上安装好L2TP服务， /etc/xl2tpd/xl2tpd.conf 里设置好vpn ip段
[global] ipsec saref = yes listen-addr = &amp;lt;外网IP&amp;gt; [lns default] ip range = 192.168.1.10-192.168.1.20 local ip = 192.168.1.1 ;require chap = yes refuse chap = yes refuse pap = yes require authentication = yes ppp debug = yes pppoptfile = /etc/ppp/xl2tpd-options length bit = yes /etc/ppp/xl2tpd-options 里设置通过vpn接入进来的设备DNS</description></item><item><title>在树莓派上运行Docker</title><link>/post/2015/60-run-docker-on-raspberry-pi/</link><pubDate>Sun, 12 Apr 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/60-run-docker-on-raspberry-pi/</guid><description>Docker Docker是目前非常流行的代码运行容器，操作系统虚拟化，运维自动化架构和开源的解决方案。
Docker的基础是Linux容器（LXC）技术，相比传统的VM虚拟化技术, LXC更轻量，性能更好。
Docker采用Golang语言开发，在LXC基础上Docker进行了封装，简化了容器的管理。
Docker还提供了一个标准(Dockerile)来实现软件部署环境代码化，全球的开发和运维工程师可以通过官方的Docker Hub仓库分享自己创建的镜像，使用者则可以快速的把系统和应用部署到自己的环境。
树莓派二代 树莓派二代的CPU有4核，运行速度是第一代的6倍，通过Docker快速部署开发环境，开发应用，再把开发好的系统通过镜像分享和发布出去也是非常有意义的事。因为树莓派的官方操作系统Raspbian并不支持Docker，本文主要介绍下如何在树莓派二代上运行Docker的几种方法。
Arch Linux ARM Arch Linux ARM 是由开源社区维护专为ARMv6（如树莓派一代）和 ARMv7（如树莓派二代, pcDuino3）等嵌入式硬件提供内核及软件支持的Linux发行版本。
在树莓派上安装Arch Linux和Raspbian略有不同，详细步骤可以看参考链接4。 总得来说是你需要在SD卡上分两个区并格式化，一个是FAT 32(LBA)格式的引导分区(/boot)，另一个是系统根分区（/root）。然后把下载下来的文件解开来复制到这两个分区就可以了。
你也可以只在SD卡上放/boot分区（这样可以用较小的如1G的SD卡引导树莓派），在U盘上放根分区，通过USB扩展存储可以允许你存放很多的镜像文件。
安装好Arch Linux后，参考这篇文章做完基础设置。
安装docker pacman -S docker 目前安装好的版本是1.5
开机自动docker systemctl enable docker 把登录用户加到docker组 这样不需要root也能执行docker了
gpasswd -a &amp;lt;your_login&amp;gt; docker 执行docker Docker Hub上搜索rpi已经可以找到不少适合Raspberry Pi运行的镜像了，热心网友都是棒棒哒。
[hugo@alarmpi ~]$ docker -v Docker version 1.5.0, build a8a31e [hugo@alarmpi ~]$ docker search rpi NAME DESCRIPTION STARS OFFICIAL AUTOMATED resin/rpi-raspbian Base image for the Raspberry Pi. Contains .</description></item><item><title>使用树莓派搭建低成本，便携，多用户的弱网模拟器：高效测试手机App在弱网下的可用性</title><link>/post/2015/59-use-raspberrypi-to-build-an-augmented-traffic-control-system/</link><pubDate>Sat, 28 Mar 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/59-use-raspberrypi-to-build-an-augmented-traffic-control-system/</guid><description>背景 我们的手机经常会处于弱网情况下，电梯里，高铁上，在地铁站，电影院里。。。如果手机应用不针对弱网做优化，就会出现：白屏页面刷不出来，界面卡死，错误提示一堆，菊花转不停，用户抓狂。。。
移动应用开发团队应该将App在弱网下的可用性作为一个重要的性能指标，在设计和开发阶段考虑在弱网下的体验。
Linux可以使用netem或iptables来实现以下网络模拟：
packet delay 网络包延迟 packet loss 网络包丢失 packet corruption 错误的网络包 packet duplication 重复发送网络包 packet re-ordering 网络包传输顺序 bandwidth 带宽控制 Facebook最近也开源了他们的augmented traffic control: https://github.com/facebook/augmented-traffic-control 主要使用iptables和python实现，架构合理容易扩展，其控制方法允许多台手机同时使用，并应用不同的网络控制策略；因为提供了RPC接口，在其基础上二次开发也可以较方便的实现自动化弱网测试。
将树莓派设置成路由器，集成上面提到的软件+二次开发后，我们可以打造出一个低成本，便携，多用户的弱网模拟器。
硬件准备 树莓派一只 USB无线网卡（芯片使用RealTek RT5370的最方便，RT8188C, RTL8192CU的需要patch hostapd） 8G TF卡 5V/2A充电器 Micro USB线 以太网线 USB 3G网卡 + SIM卡（可选） 10000mAh 移动电源（可选） 硬件成本300~500元。
安装系统 插上后无线网卡后先执行lsusb看系统是否已经识别，我们要将无线网卡设置成AP模式，WAN口接外网，让手机通过Wifi接入上网。
hugo@raspberrypi2 ~ $ lsusb ... Bus 001 Device 005: ID 0bda:8178 Realtek Semiconductor Corp. RTL8192CU 802.11n WLAN Adapter 修改/etc/network/interfaces为以下内容，设置无线LAN的静态IP为192.168.3.1
auto lo iface lo inet loopback iface eth0 inet dhcp allow-hotplug wlan0 #iface wlan0 inet manual #wpa-roam /etc/wpa_supplicant/wpa_supplicant.</description></item><item><title>自己搭建Airplay高清音乐播放系统</title><link>/post/2015/58-diy-airplay-hifi-audio-system/</link><pubDate>Sun, 15 Mar 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/58-diy-airplay-hifi-audio-system/</guid><description>先看一下在iPhone 6 plus上用虾米播放高音质音乐的效果：
苹果的Airplay协议是通过基于RSTP（Real Time Streaming Protocol）协议通过UDP传输的无损编码音频流(Apple Lossless codec，音频流本身经过了AES加密，私钥是不公开的，这样只有苹果和其合作伙伴才能使用这个协议。但是2004年有人通过逆向工程获得了私钥并将其公开，这样我们也可以自己搭建低成本高音质的基于Airplay的音乐系统。在iPhone成为街机的时代，每个人的手机里有很多喜欢的音乐，如果在家里可以通过无线网络在音响系统里播放会方便很多。
硬件 pcDunio Acadia 或 Raspberry Pi 一只 3.5mm音频线一根，类似这种 有源音箱一对 网线一根或USB无线网卡一只 音频芯片 好的音质需要好的音源，无损音乐加好的前端输出是必不可少的。 pcDuino Acadia集成的音频芯片是业界领先的英国Wolfson（欧胜微电子）为高清音频设计的WM8962 。树莓派集成的音频芯片则是由美国Broadcom（博通）封装在主芯片BCM2835里通过PWM (pulse-width modulation) 提供的，比较简单音质一般，达不到高清音频的要求。
下面是树莓派音频口播放1kHz正弦信号的输出波形，可以看出来波形并不好。 正是因为板载音频质量差强人意，Wolfson也专为树莓派设计了基于WM5102 codec芯片的Wolfson Audio Card （售价高达$34.95，性价比不高，这块芯片也用在了魅族MX3上）。 更好的方案是使用USB声卡，如淘宝上可以购买的基于德州仪器的PCM2704的USB声卡，40多人民币。
综上，如果想DIY自己的高清音乐播放系统，只有树莓派还是不够的，可以考虑用pcDunio Acadia或额外购买USB DAC。
声音测试和调节 声音测试 首先需要用音频线把板子和有源音箱连接起来，如果线材或音箱质量不够好，会立刻听到背景噪音，实测树莓派的背景噪音比pcDuino Acadia要大一些。
注：普通用户不一定有权限使用系统音频设备，所以以下测试需要root或audio group里的用户。
首先可以用speaker-test命令测试是否能出声。
hugo@raspberrypi2 ~ $ sudo speaker-test speaker-test 1.0.25 Playback device is default Stream parameters are 48000Hz, S16_LE, 1 channels Using 16 octaves of pink noise Rate set to 48000Hz (requested 48000Hz) Buffer size range from 512 to 32768 Period size range from 512 to 32768 Using max buffer size 32768 Periods = 4 was set period_size = 8192 was set buffer_size = 32768 0 - Front Left Time per period = 2.</description></item><item><title>在树莓派上用Node.js监视网页变化并通知手机</title><link>/post/2015/57-use-node-module-phantom-to-monitor-webpage-updates/</link><pubDate>Sat, 07 Mar 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/57-use-node-module-phantom-to-monitor-webpage-updates/</guid><description>最近互联网理财很流行， 好的理财产品一出来很快就抢光了。有24x7运行的低功耗树莓派在就可以帮你检查网页是否有更新并将更新的内容通知到你的手机上。
安装phantomjs 从 https://github.com/piksel/phantomjs-raspberrypi 下载已经编译好的phatomjs，并复制到$PATH下
安装Node.js 在树莓派上编译Node.js非常非常耗时。。。你也可以下载已经编译好的node和npm
wget https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2015/02/node-v0.12.0-linux-arm-pi.tar.gz tar -zxvf node-v0.12.0-linux-arm-pi.tar.gz cd node-v0.12.0-linux-arm-pi sudo cp -R * /usr/local/ 执行npm install phantom安装phantom模块，这个模块要求phantomjs被安装在$PATH下。
编写监视网页的脚本 var phantom = require(&amp;#39;phantom&amp;#39;); phantom.create(function (ph) { ph.createPage(function (page) { page.open(&amp;#39;http://8.wacai.com/list/fund&amp;#39;, function(status) { if (status!=&amp;#39;success&amp;#39;) { console.log(&amp;#39;network error&amp;#39;); } else { // page.includeJs(&amp;#34;http://code.jquery.com/jquery-1.11.2.min.js&amp;#34;, function() { var data = page.evaluate(function(){ var str = &amp;#34;&amp;#34;; $(&amp;#34;.fundItem&amp;#34;).each(function(index) { txt = $(this).text().trim().replace(/\s+/g,&amp;#34; &amp;#34;); str = str + &amp;#34;\n&amp;#34;+ index + &amp;#34; : &amp;#34; + txt; }) return str; }, function(result) { console.</description></item><item><title>用16M的SD卡启动树莓派，在U盘上安装和运行Linux</title><link>/post/2015/56-boot-raspberrypi-from-16m-sdcard-and-install-raspbian-on-usb-sticker/</link><pubDate>Thu, 05 Mar 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/56-boot-raspberrypi-from-16m-sdcard-and-install-raspbian-on-usb-sticker/</guid><description>树莓派官方的操作系统Raspbian最少需要4G的SDCard，如果你恰好有比较小的SD卡怎么办呢？设计上树莓派只能从SD卡引导启动，但我们可以在SD卡上装一个最小的引导系统，然后把树莓派引导到U盘上启动。SD卡连续运行，读写比较频繁也容易损坏（我已经坏掉3张了。。。），相比之下U盘价格便宜些，读写速度可以比SD卡还高。
制作引导SD卡 这个引导系统只需要16M容量的SD卡，先把SD卡格式化成FAT（windows），然后拷贝下面的文件到根目录。
git clone https://github.com/hugozhu/mini_raspbian_boot 修改 cmdline.txt 中的 root=/dev/mmcblk0p2 为 root=/dev/sda2 以指定用U盘启动
dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait cgroup_enable=memory 安装操作系统Raspbian到U盘 方法和安装到SD卡一样，在Mac上使用 dd 命令安装，在Windows上可以用win32diskimager：
sudo dd bs=1m if=2015-01-31-raspbian.img of=/dev/disk4 #/dev/disk4 扩展分区 如果你的U盘容量大于4G，那么上一步安装完后，你的U盘只能看到4G空间，大容量的SD卡的这个问题可以通过自带的raspi-config命令来解决。 Linux下可以用fdisk来解决，我的方法是把该U盘插到已经正常启动的树莓派的USB口上，正常识别后，执行sudo fdisk /dev/sda
按p后打印出分区表： /dev/sda1 8192 122879 57344 c W95 FAT32 (LBA) /dev/sda2 122880 6399999 3138560 83 Linux 记住/dev/sda2的起始点122880'，然后按d，删除掉二个分区，接着按n重新创建一个分区，起始点就设置为122880`，结束点可以设置为最大
最后按w保存新的分区表
插上引导SD卡和系统U盘后树莓派就可以愉快的运行起来了，如果U盘的速度足够快，你会发现系统还变快了。
参考文章 http://www.raspberrypi.org/boot-from-a-16mb-sd-card/</description></item><item><title>用Telegram和树莓派交互</title><link>/post/2015/55-use-telegram-to-chat-with-raspberrypi/</link><pubDate>Fri, 27 Feb 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/55-use-telegram-to-chat-with-raspberrypi/</guid><description>如果你的树莓派不能通过路由器端口转发直接从家庭网络外访问，你还可以用类似聊天App一样的方式来和防火墙后的树莓派轻松交互，通过命令来控制树莓派。
Telegram Telegram是一个跨平台的即时通讯软件，客户端和通讯及加密协议完全公开且开源。官方有正式发布Android，iOS，Mac OS X， Web等客户端版本；Telegram允许多端同时登录。我们在手机上安装Telegram客户端，同时在树莓派上用同一个帐号或另一个帐号也登录Telegram，那么就可以用手机和树莓派聊天了，更高级的一些用法可以是把树莓派帐号加到群聊中，实现类似微软小冰的功能；也可以由树莓派主动向你的手机Push消息实现提醒功能。
安装telegram-cli Linux的Telegram客户端telegram-cli源代码在 https://github.com/vysheng/tg，按照Readme在树莓派上编译好。telegram-cli支持消息事件对lua脚本中的函数进行回调，支持的函数列表在：https://github.com/vysheng/tg/blob/master/README-LUA，也支持外部程序通过telegram-cli侦听的端口发送交互命令（一次连接只能一个命令）
Lua交互脚本 脚本命名为：tg_raspberrypi.lua
now = os.time() chat = &amp;#34;树莓派通知&amp;#34; -- telegram的会话名称 safe_commands = {} safe_commands[&amp;#34;uptime&amp;#34;] = &amp;#34;uptime&amp;#34; safe_commands[&amp;#34;w&amp;#34;] = &amp;#34;w&amp;#34; safe_commands[&amp;#34;ps&amp;#34;] = &amp;#34;ps ax&amp;#34; safe_commands[&amp;#34;netstat&amp;#34;] = &amp;#34;netstat -na&amp;#34; safe_commands[&amp;#34;df&amp;#34;] = &amp;#34;df&amp;#34; safe_commands[&amp;#34;ss&amp;#34;] = &amp;#34;ss&amp;#34; safe_commands[&amp;#34;free&amp;#34;] = &amp;#34;free&amp;#34; function on_msg_receive (msg) if msg.out then return end if msg.text then -- mark_read(msg.from.print_name)	-- vardump(msg) cmd = string.lower(trim(msg.text)) if cmd == &amp;#34;ping&amp;#34; then send_msg (chat, &amp;#39;pong&amp;#39;, ok_cb, false) elseif safe_commands[cmd] ~= nil then send_msg (chat, exec(safe_commands[cmd]), ok_cb, false) end end end function on_our_id (id) end function on_secret_chat_created (peer) end function on_user_update (user) end function on_chat_update (user) end function on_get_difference_end () end function on_binlog_replay_end () end function exec(cmd) local output = &amp;#34;&amp;#34; f = assert (io.</description></item><item><title>用树莓派2代打造智能家庭路由</title><link>/post/2015/54-raspberrypi2-pptp-redsocks2-chinadns/</link><pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/54-raspberrypi2-pptp-redsocks2-chinadns/</guid><description>家里的宽带上下行都有10Mbps了吧？除了可以BT下载外还能让你的移动设备在外的时候也能科学上网。
区别于在海外架设VPN服务：
国内和大部分国外网站都可以直连而不降低速度；不像海外VPN所有流量（国内和国外网站）都要经过海外服务器，速度有一定的延迟 这个方案代理可以使用免费的Goagent服务；或低成本的ssh帐号；而租用海外VPS服务器自建服务或购买VPN帐号费用较高些； 利用的是家里的宽带，只有树莓派的硬件成本，没有主机托管成本； 假设家里的路由器IP地址为:192.168.1.1，树莓派2的IP地址为:192.168.1.3，以下是需要安装和设置步骤。
PPTP和L2TP VPN Server 首先在树莓派上安装和设置VPN服务器，移动设备就可以通过运营商网络连接回家里的树莓派（iPhone和Android都内置了PPTP和L2TP客户端），这样移动设备将以树莓派为路由访问网站，通过一些设置我们可以让树莓派提供科学上网服务。
关于PPTP和L2TP VPN设置和安装可以参考： http://hugozhu.myalert.info/2013/03/01/setup-l2tp-pptp-openvpn-on-ubuntu.html
但在树莓派上安装L2TP时不能直接apt-get install openswan，需要手动下载来安装，原因是因为最新的版本在协议上有些不兼容：
wget http://snapshot.raspbian.org/201403301125/raspbian/pool/main/o/openswan/openswan_2.6.37-3_armhf.deb sudo dpkg -i openswan_2.6.37-3_armhf.deb 假设VPN服务端的local ip我们设置为192.168.3.1，PPTP客户端IP分配区间为：192.168.3.200~192.168.3.210，L2TP 客户端IP分配区间为：192.168.3.100~192.168.3.110，我们可以通过iptables对IP来源为192.168.3.0/24网段的流量做特殊的处理以达到科学上网的目的。
完成这一步后，需要在路由器上设置端口转发，使得使用运营商网络如移动4G的手机可以通过PPTP或L2TP连到树莓派上。
PPTP需要设置的端口转发 - tcp: 1723
L2TP需要设置的端口转发 - tcp: 50, udp: 500,4500,1701
两种VPN服务相比较：PPTP拨号速度比较快，但是不安全；L2TP有加密，相对安全。
Redsocks2 redsocks2是一个透明TCP代理，其实现使用了libevent库，性能较好，其最大的特点是如果目标IP可以直连则不会转发流量给加密代理，如果IP不能直连（通过连接超时判断）则会将流量转发给加密代理。这样可以将最少的流量转发到代理上，访问一般的国外网站如yahoo.com也不会经过代理而减速，在配置方面则做到了零配置，不需要手工维护网站名单。代理也能支持很多中类型，如socks5, shadowsocks, goagent, http-proxy等，redsocks2安装和配置可以见链接： http://github.com/hugozhu/redsocks
这里我们假设redsocks2的端口使用12345
iptables 使用iptables我们可以将VPN客户端192.168.3.0/24的流量转发到redsocks5的端口12345
sudo iptables -F sudo iptables -X sudo iptables -t nat -F sudo iptables -t nat -X sudo iptables -t nat -A PREROUTING -s 192.168.3.0/24 -p tcp --dport 80 -j REDIRECT --to-ports 12345 #转发VPN客户端的HTTP流量到端口12345 sudo iptables -t nat -A PREROUTING -s 192.</description></item><item><title>零佣金的券商靠什么赚钱？</title><link>/post/2015/53-robinhood-zero-commission-brokerage/</link><pubDate>Tue, 10 Feb 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015/53-robinhood-zero-commission-brokerage/</guid><description>最近一家叫Robinhood的创业公司推出了零佣金的股票交易服务公测，用户可以通过iOS上的专用App交易。
这家公司的两个创始人斯坦福大学毕业后去了纽约给华尔街的大型股票经济公司做交易系统，做了几年后突然有一天发现券商公司对每一笔交易付出的成本微乎其微，但要收取每个客户多达10美金的佣金。。。于是他们毅然决定辞职，回到硅谷创业去了。
公司打出的口号是就是零佣金，如果你交易的资金来源于自己，那么买入和卖出交易，以及银行转入和转出（不包括电汇）都是免费的。
零佣金对资金不那么充裕的年轻人来说非常有吸引力。那么问题来了，这家公司靠什么赚钱呢？
交易过股票的人大概都知道，券商会提供融资服务给流动资金不充足的投资者，融资交易（Securities Margin Trading）就是投资者以资金或证券作为质押，向券商借入资金用于证券买卖，并在约定的期限内偿还借款本金和利息。相应的还有融券服务，融券交易是投资者以资金或证券作为质押，向券商借入证券卖出，在约定的期限内，买入相同数量和品种的证券归还券商并支付相应的融券费用。所以Robinhood首先可以通过融资融券服务盈利；
对于投资者在Robinhood账户里的未购买股票的闲余资金，Robinhood可以通过金融市场获得一部分利息收入；
提供收费接口给小型的量化和对冲基金；
目前Robinhood已经完成了千万美元的风险投资，现阶段提供颠覆性的交易体验，吸引更多年轻的新投资者，赢得用户的信任显然更为重要。用户多了，盈利就不是问题了。。。
App界面
创始人
参考文档 http://techcrunch.cn/2014/09/25/robinhood-stock-app/ https://robinhoodapp.zendesk.com/hc/en-us/articles/202853769-How-does-Robinhood-make-money- http://baike.baidu.com/view/431144.htm?fromtitle=融资融券&amp;amp;fromid=1628138&amp;amp;type=syn</description></item><item><title>First post!</title><link>/post/2015-01-04-first-post/</link><pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2015-01-04-first-post/</guid><description>This is my first post, how exciting!</description></item><item><title>使用Gradle生成包含所有依赖库(.jar或.aar)的aar包</title><link>/post/2014/52-assemble-aar-with-all-dependencies-with-gradle/</link><pubDate>Wed, 05 Nov 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/52-assemble-aar-with-all-dependencies-with-gradle/</guid><description>Android Library项目中如果使用Android Gradle plugin打aar包，通过maven依赖的库，或者是local依赖的aar都不会包含在生成的aar包里，如果项目是发布一个SDK，为了方便开发者使用，我们倾向于生成一个包含所有依赖库以及.so等文件的aar包。
通过反复研究和测试，以下Gradle脚本能满足需求，如果需要对代码运行ProGuard混淆，则需要使用Gradle 2.1
方法是为项目增加一个sub project（如pkg_project）专门用于打包，该项目中build.gradle内容如下：
apply plugin: &amp;#39;java&amp;#39; version = 1.0 buildscript { repositories { mavenCentral() } dependencies { classpath &amp;#39;com.android.tools.build:gradle:19.1.0&amp;#39; } } repositories { mavenCentral() } dependencies { compile project(&amp;#39;:&amp;lt;your_library_project&amp;gt;&amp;#39;) //此处填写需要打包的Android Library Project name } task sync_jars() &amp;lt;&amp;lt; { //把所有依赖的.jar库都拷贝到build/aar/libs下 copy { into buildDir.getPath() +&amp;#34;/aar/libs&amp;#34; from configurations.compile.findAll { it.getName().endsWith(&amp;#34;.jar&amp;#34;) } } } task sync_aars(dependsOn:&amp;#39;:&amp;lt;your_library_project&amp;gt;:assembleRelease&amp;#39;) &amp;lt;&amp;lt; { //把所有依赖的.aar库里包含的classes.jar都拷贝到build/aar/libs下，并重命名以不被覆盖 def jar_name def aar_path def dest_dir = buildDir.getPath()+&amp;#34;/aar&amp;#34; configurations.compile.findAll { it.</description></item><item><title>常用Linux命令</title><link>/post/2014/51-useful-linux-command/</link><pubDate>Thu, 04 Sep 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/51-useful-linux-command/</guid><description>拷贝文件 如果想事实看到拷贝的速度可以用rsync -aP</description></item><item><title>简单手机应用同步协议设计和实现</title><link>/post/2014/49-fast-sync-between-mobile-phone-and-server/</link><pubDate>Wed, 27 Aug 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/49-fast-sync-between-mobile-phone-and-server/</guid><description>版本：Ver 0.3
在手机上我们需要持久化应用的一些数据(典型的如本地的设置信息)，同时又希望能重装应用或换一台手机登录后能把这些数据再同步回来。业界有SyncMl标准，覆盖的功能很完善，正因为要保证兼容性，开源的实现都较重。如何借鉴这个标准自己来实现一个多端双向同步可扩展的功能呢？
App使用同步协议可以将原本必须在线操作的功能（如：删除一个联系人，修改一个联系人的备注信息）也可以在断网情况下完成。
我们假设一些前提：
同一时刻只有一端（iPhone，iPad或其他移动设备）能和服务器同步； 客户端和服务端的时间一致或误差较小；可在长连建立时通过协议记录时间差 客户端保存全量数据（对于客户端只保存部分数据的情况后面再做讨论）； 应用场景 通讯录同步 最近联系人 App客户端设置 最近会话列表 黑名单 群设置 群成员 用户的一些设置和开关 名词解释 LCID - Local Unique Identifiers， 客户端生成的记录ID，客户端唯一； GUID - Global Unique Identifiers， 服务端生成的记录ID，全局唯一； Anchor - 同步锚点，可以使用递增的序列号或时间戳来表示，用来发现两端数据变化的部分； Session - 同步会话，由客户端发起，Session Id唯一。 客户端表设计 每条记录包含两个同步用的字段：
status － 用来标识记录的状态
Status 含义 0 本地新增 -1 标记删除 1 本地更新 9 已同步 anchor － 用来记录服务端同步过来的时间戳。
服务端表设计 modified － 记录在服务端的修改时间
双向同步流程示例 1. Client 增加2条记录 id key value status modified anchor 1 Foo Bar 0 1 0 2 Hello World 0 2 0 客户端新增记录时，需要将Status设为0</description></item><item><title>使用Gradle生成一个App的不同版本，且可以同时安装在一个手机上</title><link>/post/2014/50-use-gradle-to-customize-apk-build/</link><pubDate>Sun, 03 Aug 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/50-use-gradle-to-customize-apk-build/</guid><description>背景 开发一个App一般会生成内测版和正式版，甚至还会有不同渠道的版本，不同版本的配置可能会不一样，比如内测版会需要记录完整的日志。
Android手机对于同样的Application Id的App只能安装一个版本，如果我们需要同时安装内测版和正式版，就必须修改其中一个版本的Application Id。
解决方案 Gradle支持buildTypes和productFlavors两种定制方法，这里只介绍通过buildType的解决方案。通过productFlavors则可有效解决渠道包，arm，x86等分平台以及付费版和广告版的打包问题。
修改debug版的包名 配置如下：
android { buildTypes { release { ... } debug { applicationIdSuffix &amp;#39;.debug&amp;#39; ... } } } 修正资源文件里的包名 如果你的项目里使用了自定义的View，且有自定义的属性时，会需要修正一下xml命名空间里的包名。
android.applicationVariants.all { variant -&amp;gt; def buildType = variant.buildType def encoding = java.nio.charset.Charset.defaultCharset().toString() if (buildType.applicationIdSuffix) { def defaultPackageId = variant.packageName.replaceAll(buildType.applicationIdSuffix,&amp;#39;&amp;#39;) variant.mergeResources.doLast { def dir = file(&amp;#34;${buildDir}/intermediates/res/${variant.dirName}/layout&amp;#34;) dir.listFiles().each { f-&amp;gt; String content = f.getText(encoding) content = content.replaceAll(&amp;#34;res/&amp;#34;+defaultPackageId, &amp;#34;res/&amp;#34;+variant.packageName) f.write(content, encoding) } } } } 定制APK的应用名称 如果同时安装两个版本，那么最好能从应用名称上来区别一下，一般我们在AndroidManifest.</description></item><item><title>安装第三方App到电视盒子</title><link>/post/2014/48-install-3rd-party-app-on-tv-box/</link><pubDate>Sat, 26 Jul 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/48-install-3rd-party-app-on-tv-box/</guid><description>安装第三方App方法1 准备一个U盘，注意用FAT格式（Windows能读写就OK） 将需要安装的App下载到U盘，文件后缀名必须是.apk 将U盘插入电视盒子，然后通过盒子自身带的文件管理App安装：如Magic Box：应用－－&amp;gt; 本地播放，进入后选中U盘上的.apk文件即可安装 安装第三方App方法2 如果盒子不带USB盘，还可以用adb远程安装 adb connect &amp;lt;your_magic_box_ip&amp;gt; adb install &amp;lt;you_app_to_install&amp;gt;.apk 直播和回放App 在电脑上用浏览器下载：http://app.shafa.com/shafa.apk 到U盘 按方法1安装好后，在“应用“中找到“沙发管家” 启动“沙发管家”，安装直播App：如“龙龙直播”，也有支持回放的App，如“电视猫视频”等。</description></item><item><title>Gradle的Properties</title><link>/post/2014/47-use-gradle-properties-to-set-alternative-android-build-tools/</link><pubDate>Wed, 23 Jul 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/47-use-gradle-properties-to-set-alternative-android-build-tools/</guid><description>问题背景 团队一起在开发一个Android项目，工程师有的使用Eclipse，有个使用Intellij IDEA，有的使用Android Studio。每个人安装的Android SDK build-tools可能都不一样，有的是19.0.3，有的是19.1.0，不同版本的build-tools对Gradle Plugin也有相应的要求，如19.0.3对应的是com.android.tools.build:gradle:0.10.+，19.1.0对应的是com.android.tools.build:gradle:0.12.+，下面是一个典型的build.gradle配置文件。
buildscript { repositories { mavenCentral() } dependencies { classpath &amp;#39;com.android.tools.build:gradle:0.10.+&amp;#39; } } apply plugin: &amp;#39;android-library&amp;#39; android { compileSdkVersion 19 buildToolsVersion 19.0.3 defaultConfig { minSdkVersion 8 targetSdkVersion 19 } } 在合作开发中遇到的一个尴尬的问题是，IDEA最新版还不能很好的支持Gradle Plugin 0.12+，而Android Studio最新版则要求使用0.12+。大家又共用一个Git仓库。可能的解决方案是，从Git checkout出来的项目需要有一个基础的版本号，但是开发者可以在本地通过一处文件（不check in到git）来重载版本号。
解决方案 Gradle支持三种Properties, 这三种Properties的作用域和初始化阶段都不一样，下面分别列出了其部分特点。:
System Properties：
可通过gradle.properties文件，环境变量或命令行-D参数设置	2. 可在setting.gradle或build.gradle中动态修改，在setting.gradle中的修改对buildscript block可见； 所有工程可见，不建议在build.gradle中修改 多子工程项目中，子工程的gradle.properties会被忽略掉，只有root工程的gradle.properties有效； Project Properties：
可通过gradle.properties文件，环境变量或命令行-P参数设置，优先级是: 可在build.gradle中动态修改，但引用不存在的project properties会立即抛错 动态修改过的project properties在buildscript block中不可见 Project ext properties：
可在项目的build.gradle中声明和使用，本工程和子工程可见 不能在setting.gradle中访问 如果有多处设置，加载次序如下（注意：gradle 2.0是这样的, 1.10~1.12有bug）, 后面的覆盖前面的设置</description></item><item><title>Android异步编程</title><link>/post/2014/46-async-android/</link><pubDate>Sun, 29 Jun 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/46-async-android/</guid><description>Android的线程和内存模型 Android操作系统在boot后，会启动一个Zygote(受精卵)进程，Zygote进程负责创建大部分应用程序进程。Zygote进程启动加载核心程序库和数据结构到内存后会创建一个Dalvik虚拟机（DVM）进程－-SystemServer，此进程会包含大部分的系统服务（包括管理Activity的服务ActivityManagerService），SystemServer初始化后，Zygote进程会侦听本地的socket端口, 等待进一步的指令。当新的app被启动时，Zygote会为这个app创建一个DVM&amp;mdash;-直接fork出一个子进程，这种架构的好处是同时启动多个App时，多个App进程可以访问共享内存。
Android App的进程也是一个DVM，内部有许多线程在执行，比如，主UI线程（Main Thread），垃圾回收线程等。其中主UI线程负责执行我们写的应用代码。对于只做很少的I/O操作或耗时操作的App，单一线程开发模式问题不大，但是如果有大量IO或者CPU计算的任务，我们就必须在其他线程内完成了。
因为主UI线程需要根据硬件刷新率[^3]同步用户界面的重绘。手机应用体验流畅要求界面帧率[^3]达到每秒60，也就是说每16.67毫秒就需要重绘一帧，这意味着如果我们在主线程上执行的任务超过16毫秒，就会出现丢帧现象，也就是界面会开始变卡。。。
Android异步执行任务的方法有以下几种：
AsyncTask AsyncTask是最常用的异步方法，功能结构设计的也很丰富，给使用者足够的控制，使用上主要是将异步执行的任务放在下面方法里。
protected Result doInBackground(Params... params) 然后调用.execute(params)方法即可。
AsyncTask的执行逻辑在API Level 3只能串行执行， 在API Level 4改成了最多128个线程的线程池执行，API Level 11则改成了缺省所有的AsyncTask是在一个线程中顺序执行的，这样可以保证执行和提交的次序一致，如果希望能并发的执行，可以用下面的方法在线程池内执行：
task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, params); AsyncTask.THREAD_POOL_EXECUTOR是ThreadPoolExecutor的一个实例，配置是最少5个线程，最多128个。如果需要自己来配置线程池大小，你可以传递自己配置的一个实例到上述方法。
使用AsyncTask需要注意的几个问题：
碎片化问题 因为不同版本的Android AsyncTask缺省执行逻辑并不一样，可能在不同机型上表现不一致。如果要自己控制AsyncTask的并发度，解决这个问题的建议是复制Android SDK的AsyncTask源码自己实现一个AsyncTask。
Activity生命周期问题 Activity可能早于AsyncTask执行完被销毁，如果AsyncTask还继续执行，有可能会浪费资源，并且如果AsyncTask里引用了Activity或部分的View Hierarchy，还会造成引用的对象不会被垃圾回收而引起内存泄漏。通常AsyncTask会定义为Activity的一个匿名inner class，这会建立一个隐式的引用到Activity。
解决的方法是：
在Activity里的onPause方法里及时取消不需要再执行的AsyncTask（这种方法在切换到横屏时会重启异步任务，有点浪费） 更好的是使用retained headless fragment来解决生命周期问题，具体演示代码见参考链接 Async比较合适的是较短的（1，2秒），CPU密集计算或读写文件等阻塞IO操作。耗时较长的网络调用用Async不是最合适的。
Handler &amp;amp; HandlerThread Handler的异步编程是基于消息队列模型的。执行任务的线程称之为Looper线程，其他线程则将需要异步执行的任务发送给Looper线程&amp;ndash;插入其消息队列，方法有：post（较方便使用，但每次需要创建新对象）或sendMessage（较高效，复用消息实例，适合执行大量类似的异步任务）
Looper Looper和它的名字意思一样就是Looper线程会永远循环，当没有消息的时候，Looper线程（消费者）会使用(Object.wait)方法等待其他线程（生产者）插入新的任务消息，这时候其他线程(Object.notify)
Android的主线程其实就是一个Looper线程。
需要注意的是，使用Handler和AsyncTask一样，要注意匿名inner class对Activity的隐式引用而造成内存泄漏，所以使用的时候要记得清理；
解决方法是使用对使用的Activity中的View对象用Weak Reference，并处理当View对象为null的情况。
Handler适合更长一点的（&amp;gt;2秒）的异步任务处理。
Loader Loader在Android编程框架中被广泛用于后台加载数据（从文件，数据库甚至网络）。
AsyncTaskLoader 具体的Loader实现。
CursorLoader 用户数据库数据后台加载。
Loader在使用上比较大的优势是和Activity的部分解耦，更见到的生命周期管理。
IntentService IntentService是Service的一个实现类。其内部实现包含了一个HandlerThread，当任务提交给IntentService时，会被加到队列并顺序处理。
public class MyIntentService extends IntentService { public MyIntentService() { super(&amp;#34;thread-name&amp;#34;); } protected void onHandleIntent(Intent intent) { // executes on the background HandlerThread.</description></item><item><title>提高Android开发效率的小贴士</title><link>/post/2014/45-android-development-productivity-tips/</link><pubDate>Mon, 10 Feb 2014 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2014/45-android-development-productivity-tips/</guid><description>查看日志 adb logcat 下面命令将只显示错误日志，和所有Tag＝mytag的调试日志，-C 会用不同颜色区分不同级别的日志，但只有Android 4.3以后才支持。
adb logcat [-C] *:E &amp;lt;mytag&amp;gt;:D 远程调试 adb over TCP 首先在手机或Pad上执行以下命令（要求root）
su setprop service.adb.tcp.port 5555 stop adbd start adbd 再执行下面命令则可以看到手机的网络地址
netcfg | grep wlan 在电脑上则执行
adb connect &amp;lt;mobile_phone_ip&amp;gt; 5555 adb shell 安装运行
gradle installDebug &amp;amp;&amp;amp; adb shell am start -n com.laiwang.protocol.android/.MainActivity Over</description></item><item><title>拷贝Android应用的数据</title><link>/post/2013/44-copy-android-app-data/</link><pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/44-copy-android-app-data/</guid><description>有root权限 adb shell su -c cat /data/data/app.package.name/databases/application.sqlite | sed &amp;#39;s/\r$//&amp;#39; &amp;gt; application.sqlite 应用可调试的话 adb shell run-as app.package.name \ cp /data/data/package.name/databases/application.sqlite /sdcard/ exit adb pull /sdcard/application.sqlite ~/ 使用备份方法 adb backup -f ~/data.ab -noapk app.package.name dd if=data.ab bs=1 skip=24 | python -c &amp;#34;import zlib,sys;sys.stdout.write(zlib.decompress(sys.stdin.read()))&amp;#34; | tar -xvf - 参考链接 http://blog.shvetsov.com/2013/02/access-android-app-data-without-root.html</description></item><item><title>使用夏普GP2Y1010AU0F灰尘传感器检测空气质量</title><link>/post/2013/42-sharp-gp2y1010au0f-optical-dust-sensor/</link><pubDate>Sun, 21 Jul 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/42-sharp-gp2y1010au0f-optical-dust-sensor/</guid><description>夏普GP2Y1010AU0F灰尘传感器价格较便宜，能检测出室内空气中的灰尘和烟尘含量。另外还有韩国SYHITECH生产的DSM501A粉尘传感器也有类似功能。
检测原理 其原理如下图，传感器中心有个洞可以让空气自由流过，定向发射LED光，通过检测经过空气中灰尘折射过后的光线来判断灰尘的含量。
电路图 因为数据是通过pin 5的电压模拟信号输出的，而树莓派的引脚不支持模拟信号直接读取（需要增加数模转换芯片），所以先用Arduino来实验。
Arduino 代码 根据电路图， 把Arduino和传感器连接起来：
Sharp pin 1 (V-LED) =&amp;gt; 5V 串联1个150欧姆的电阻（最好在电阻一侧和GND之间再串联一个220uf的电容） Sharp pin 2 (LED-GND) =&amp;gt; GND Sharp pin 3 (LED) =&amp;gt; Arduino PIN 2 （开关LED） Sharp pin 4 (S-GND) =&amp;gt; GND Sharp pin 5 (Vo) =&amp;gt; Arduino A0 pin （空气质量数据通过电压模拟信号输出） Sharp pin 6 (Vcc) =&amp;gt; 5V /* Interface to Sharp GP2Y1010AU0F Particle Sensor Program by Christopher Nafis Written April 2012 http://www.sparkfun.com/datasheets/Sensors/gp2y1010au_e.pdf http://sensorapp.net/?p=479 Sharp pin 1 (V-LED) =&amp;gt; 5V (connected to 150ohm resister) Sharp pin 2 (LED-GND) =&amp;gt; Arduino GND pin Sharp pin 3 (LED) =&amp;gt; Arduino pin 2 Sharp pin 4 (S-GND) =&amp;gt; Arduino GND pin Sharp pin 5 (Vo) =&amp;gt; Arduino A0 pin Sharp pin 6 (Vcc) =&amp;gt; 5V */ #include &amp;lt;SPI.</description></item><item><title>在树莓派上使用Phantomjs自动登录微博</title><link>/post/2013/41-use-phantomjs-on-raspberry-pi-to-login-weibo/</link><pubDate>Sun, 21 Jul 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/41-use-phantomjs-on-raspberry-pi-to-login-weibo/</guid><description>使用过新浪开放平台的朋友都知道用户对小应用（用户数较少的）的授权Token很容易过期，自动续期要求授权过的用户在过期前重新打开授权页。如果你想实现一个自动备份自己微博的App，就不得每天（周）自己去访问授权页（想死的心都有了吧？）。这里介绍一种通过脚本自动登录微博获取最新oAuth token的方法（需要微博登录名和密码），合适自己玩。将脚本部署在树莓派上后，我再也不用每周都去登录一次授权页了，只是收到报警消息后（经常是帐号被冻结了）需要手动处理一下。
Phantomjs Phantomjs 是一个开源的，没有界面可运行在命令行，跨平台，基于WebKit的全功能浏览器，可以用来做网站自动化测试。从源代码编译比较费时间，可以直接下载二进制版本，树莓派的版本在这里可下载。Phantomjs下载好了后就一个可执行文件，依赖非常少，我很喜欢这种方式。
代码 以下代码使用提供的微博用户名和密码登录，获得Token后还会打开微博首页看帐号是否被冻结了。
var page = require(&amp;#39;webpage&amp;#39;).create(), system = require(&amp;#39;system&amp;#39;), fs = require(&amp;#39;fs&amp;#39;), address; var weibo_userid = system.args[1] var weibo_passwd = system.args[2] var startUrl = &amp;#34;https://api.weibo.com/oauth2/authorize?client_id=&amp;lt;your_app_key&amp;gt;&amp;amp;redirect_uri=&amp;lt;your_return_url&amp;gt;/&amp;amp;response_type=token&amp;#34;; var verify_weibo_freeze = false; page.onResourceReceived = function (res,network) { if (res.stage == &amp;#34;end&amp;#34;) { // console.log(&amp;#34;\t&amp;lt;-&amp;#34; + res.url); if (res.url.indexOf(&amp;#34;authorize?client_id&amp;#34;)&amp;gt;0) { startUrl = res.url } if (res.url.indexOf(&amp;#34;?access_token&amp;#34;)&amp;gt;0) { var pos1 = res.url.indexOf(&amp;#34;access_token=&amp;#34;) var pos2 = res.url.indexOf(&amp;#34;&amp;amp;&amp;#34;) var access_token = res.url.substring(pos1+&amp;#34;access_token=&amp;#34;.length, pos2) console.</description></item><item><title>在Mac上使用Sublime 3写Go代码</title><link>/post/2013/40-try-out-sublime-3-beta-on-mac/</link><pubDate>Thu, 11 Jul 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/40-try-out-sublime-3-beta-on-mac/</guid><description>Sublime 是一个相当好用的文本编辑器，界面简洁，功能强大。最近Sublime 3 Beta 出来了, 体验了一下，发现启动速度比之前快了很多。
下载安装 下载地址： http://www.sublimetext.com/3
安装Package Control Sublime 支持插件来丰富其功能，package control 本身也是一个插件，可以用来管理其他插件，所以我们要先安装Package Control，Sublime 3需要安装Pacakge Control Alpha.
cd &amp;#34;Library/Application Support/Sublime Text 3&amp;#34; cd Packages/ git clone https://github.com/wbond/sublime_package_control.git &amp;#34;Package Control&amp;#34; cd &amp;#34;Package Control&amp;#34; git checkout python3 安装GoSublime 重启Sublime后
按cmd+shift+p (OS X)或press ctrl+shift+p (Windows, Linux) 在弹出的输入框中输入 PacInstall 选择 Package Control: Install Package 在稍后弹出的输入框内输入&amp;quot;Gosublime&amp;quot;，选择安装 好了，就这样可以开始写Go代码了。
Tips 我的Sublime配置
{ &amp;#34;font_face&amp;#34;: &amp;#34;Microsoft YaHei&amp;#34;, &amp;#34;font_options&amp;#34;: [ ], &amp;#34;font_size&amp;#34;: 18.0, &amp;#34;line_padding_top&amp;#34;: 0 } 按快捷键Shift + Command + L可以按列编辑</description></item><item><title>替换树莓派的U盘</title><link>/post/2013/39-replace-usb-disk-on-raspberry-pi/</link><pubDate>Thu, 11 Jul 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/39-replace-usb-disk-on-raspberry-pi/</guid><description>除了SD卡上的存储，树莓派还可以使用U盘来做存储，有时候我们可能需要替换已有的U盘为更大容量的。在Mac上可以采用下面的方法：
备份已有的U盘，把U盘从树莓派上拔下来插在Mac上，找出U盘对应的盘符（下例为/dev/disk2）
20:51:19 hugozhu-mac-mini ~ $ diskutil list /dev/disk0 #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *500.1 GB disk0 1: EFI 209.7 MB disk0s1 2: Apple_HFS Macintosh HD 499.2 GB disk0s2 3: Apple_Boot Recovery HD 650.0 MB disk0s3 /dev/disk2 #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *2.1 GB disk2 使用 dd 命令把U盘拷贝到raspberrypi.img
sudo dd if=/dev/disk2 of=raspberrypi.img conv=notrunc 从Mac上取下旧U盘，把新的U盘插入同一个USB口，注意新U盘容量要大于旧的
sudo dd of=/dev/disk2 if=raspberrypi.img conv=notrunc 把新U盘插入树莓派，并mount上，用以下命令把U盘的多余空间用起来
resize2fs /dev/sda</description></item><item><title>Java并发中正确使用volatile</title><link>/post/2013/38-java-volatile-variable/</link><pubDate>Sun, 30 Jun 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/38-java-volatile-variable/</guid><description>前几天并发编程群里有同学对volatile的用法提出了疑问，刚好我记得Twitter有关实时搜索的这个PPT对这个问题解释的很清晰并有一个实际的应用场景，于是周末把这个问题摘录了一些和并发相关的内容如下：
并发 - 定义 悲观锁 - Pressimistic locking 一个线性在执行一个操作时持有对一个资源的独占锁。（互斥） 一般用在冲突比较可能发生的场景下 乐观锁 - Optimistic locking 尝试采用原子操作，而不需要持有锁；冲突可被检测，如果发生冲突，具有相应的重试逻辑 通常用在冲突较少发生的场景下 非阻塞算法 - Non-blocking algorithm 算法确保对线程间竞争共享资源时候，不会因为互斥而使任一线程的执行无限延迟； 无锁算法 - Lock-free algorithm 如果系统整个流程的执行是无阻塞的(系统某一部分可能被短暂阻塞)，这种非阻塞算法就是无锁的。 无锁算法比传统的基于锁的算法对系统的开销更小，且更容易在多核多CPU处理器上扩展； 在实时系统中可以避免锁带来的延迟； CAS (compare and swap)或LL/SC(load linked/store conditional)，以及内存屏障相关的指令经常被用在算法实现中。 无等待算法 - Wait-free algorithm 如果每个线程的执行都是无阻塞的，这种非阻塞算法就是无等待的（比无锁算法更好） Java的并发 Java的内存模型并不保证一个线程可以一直以程序执行的顺序看到另一个线程对变量的修改，除非两个线程都跨越了同一个内存屏障。（Safe publication） Java内存模型 代码顺序规则 一个线程内的每个动作 happens-before 同一个线程内在代码顺序上在其后的所有动作 volatile变量规则 对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入 传递性 如果A happens-before B, B happens-before C，那 A happens-before C Safe publication案例 class VolatileExample { int x = 0; volatile int b = 0; private void write() { x = 5; b = 1; } private void read() { int dummy = b; while (x!</description></item><item><title>在Android上使用tcpdump</title><link>/post/2013/37-tcpdump_on_android/</link><pubDate>Mon, 24 Jun 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/37-tcpdump_on_android/</guid><description>tcpdump工具是分析网络协议和数据包的利器，也可以在Android上使用（需要root）。
首先在android上安装tcpdump
wget http://www.strazzere.com/android/tcpdump adb push tcpdump /data/local/tmp/tcpdump adb chmod 755 /data/local/tmp/tcpdump 然后使用root用户启动tcpdump，在android上进行相应的操作后，按ctrl+c中断
adb shell shell@android:/ $ su root@android:/ # /data/local/tmp/tcpdump -h tcpdump version 3.9.8 libpcap version 0.9.8 Usage: tcpdump [-aAdDeflLnNOpqRStuUvxX] [-c count] [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -i interface ] [ -M secret ] [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -Z user ] [ expression ] root@android:/ # /data/local/tmp/tcpdump -p -vv -s 0 w /sdcard/capture.</description></item><item><title>使用Ping来检查网络连通性</title><link>/post/2013/36-use-ping-to-check-network-connectivity/</link><pubDate>Sat, 01 Jun 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/36-use-ping-to-check-network-connectivity/</guid><description>树莓派使用了一个无线网卡连接家里的无线路由器，在实际使用过程中发现连续运行多天后会掉线，而且掉线后基本上就再也连不上网了，需要重启树莓派才能恢复，十分麻烦。
假设无线路由器IP是192.168.1.1，于是每隔15分钟检查一下，是否能从树莓派上ping通路由器；如果不能则重启无线网络，脚本如下：
network.sh
#!/bin/bash export PATH=/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin ping_count() { count=0 `timeout 5 ping 192.168.1.1 | while read LINE; do { if [[ &amp;#34;${LINE}&amp;#34; =~ &amp;#34;64 bytes from&amp;#34; ]]; then let &amp;#34;count = $count + 1&amp;#34; echo &amp;#34;export count=$count&amp;#34; fi } done` echo $count } if [[ $(ping_count) &amp;lt; 1 ]]; then ifconfig wlan0 ifconfig wlan0 down sleep 1 ifconfig wlan0 up sleep 1 netcfg -r wlan0-Hugo-Nas sleep 5 if [[ $(ping_count) &amp;lt; 1 ]]; then echo &amp;#34;Fatal error: wifi is down, rebooting now.</description></item><item><title>树莓派的GPIO接口输出电流限制</title><link>/post/2013/35-understanding-output/</link><pubDate>Tue, 14 May 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/35-understanding-output/</guid><description>树莓派提供了一个连接头让我们访问CPU的17个GPIO接口，如下图
这些接口可配置成输入或输出。本文主要讨论GPIO引脚作为输出时电流的限制。
阻抗 (impendance) 阻抗和和电阻的区别（resistance）在于电阻的阻值是固定的，不会随着电流变化，阻抗则不然，可能随着外部变化，如电流或频率变化。从另一个角度来说，电阻是线性的，但阻抗不是。比如放大器的阻抗会随着输出的信号频率变化。
树莓派的的每个GPIO引脚都有一个寄存器可以设置引脚的驱动强度，也就是在保持输出电压为逻辑0和1的情况下，可以改变阻抗的大小从而改变GPIO引脚的输出电流大小。
通过如下电路测量相同电流下不同阻抗对应的GPIO电压输出（其中用到了一个电位器调节电流保持恒定）：
通过计算后，下表是当输出电流为2，4 … 16mA时，对应的阻抗大小以及如果发生短路时的短路电流大小。
可以看出短路电流都是超过16mA的。
一个发光二极管压降约为1.52.0v，工作电流为310v
GPIO引脚的电流是通过板上的3.3V电压调整器输出的，树莓派是按平均每个引脚3mA来设计的，所以总的电流不能超过17 * 3 = 51mA。
结论 树莓派引脚电流大小的限制是：每个引脚最大输出电流为16毫安(mA)，且同一时刻所有引脚的总输出电流不超过51毫安
参考链接 http://www.thebox.myzen.co.uk/Raspberry/Understanding_Outputs.html</description></item><item><title>使用8位移位寄存器74HC595扩展树莓派的IO端口</title><link>/post/2013/34-use-74hc595-8-bit-shift-register-with-raspberry-pi/</link><pubDate>Mon, 13 May 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/34-use-74hc595-8-bit-shift-register-with-raspberry-pi/</guid><description>树莓派的GPIO接口数目有限，驱动一个步进电机需要占用4个， 一个Nokia 5110液晶也要占4个， 传感器输入至少需要一个，多玩几个外设后接口就不够用了。如果接口可以复用就可以让树莓派驱动更多的外设了，本文讨论如何使用74HC595集成电路芯片来扩展树莓派的I/O接口。
芯片介绍 SN74HC595N是德州仪器公司生产的集成电路芯片，是一个8位串行输入变串行输出或并行输出移位寄存器，具有高阻关断，高电平和低电平三态输出。在IO扩充上，可以最多串联15片，也就是高达120个IO扩充。
（注意到芯片上的小凹槽了吗，拿芯片的时候以这个为参考物就不会搞反了）
接口的常用命名方式有以下两种：
接口代号(编号) 说明 接口代号(编号) 说明 Q7&amp;rsquo;(9) serial data output QH&amp;rsquo; (9) serial data output MR (10) Master Reset (Active Low) SRCLR (10) Shift register CLeaR SH_CP (11) shift register clock input SRCLK (11) Shift Register CLocK input ST_CP (12) storage register clock input RCLK (12) storage Register CLocK input OE (13) output enable input (Active Low) OE (13) Output Enable DS (14) serial data input SER (14) SERial data input Qx (15，1-7) data output Qx (15，1-7) data output 控制流程 如果要在8个引脚输出01010101</description></item><item><title>树莓派网站容灾：利用DNSPod，Google App Engine和Github</title><link>/post/2013/33-use-google-app-engine-failover-your-blog-between-raspberrypi-and-github/</link><pubDate>Mon, 22 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/33-use-google-app-engine-failover-your-blog-between-raspberrypi-and-github/</guid><description>背景介绍 把网站托管在树莓派上后如果家里停电或是宽带故障，会造成网站中断。本文提供一个免费的解决方案（前提是你需要有自己的一个域名，并由DNSPod解析）
DNSPod 首先需要在DNSPod里设置好需要failover的域名CNAME：比如hugozhu.myalert.info
其中默认指向pi.myalert.info, 这是一个域名的A Record，会由运行在树莓派上的脚本来更新动态IP，国外则指向github。当停电时我们需要自动把｀默认｀这条纪录修改成github。
使用下面命令获得相应CNAME的domain_id：
curl -k https://dnsapi.cn/Domain.List -d &amp;#34;login_email=xxx&amp;amp;login_password=xxx&amp;#34; 使用下面命令获得相应CNAME的record_id：
curl -k https://dnsapi.cn/Record.List -d &amp;#34;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;#34; Google App Engine 切换DNS脚本 package dnspod import ( &amp;#34;io/ioutil&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;net/url&amp;#34; &amp;#34;strings&amp;#34; ) const ( login_email = &amp;#34;&amp;lt;your_login_email&amp;gt;&amp;#34; login_password = &amp;#34;&amp;lt;your_login_password&amp;gt;&amp;#34; format = &amp;#34;json&amp;#34; domain_id = &amp;#34;&amp;lt;domain_id&amp;gt;&amp;#34; record_id = &amp;#34;&amp;lt;record_id&amp;gt;&amp;#34; sub_domain = &amp;#34;&amp;lt;your_subdomain&amp;gt;&amp;#34; record_type = &amp;#34;CNAME&amp;#34; record_line = &amp;#34;默认&amp;#34; ttl = &amp;#34;600&amp;#34; ) func Update(client *http.Client, cname string) string { body := url.</description></item><item><title>使用Goroutine和Channel实现按键超时交互</title><link>/post/2013/32-use-goroutine-and-channel-to-implement-interaction-with-timeout/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/32-use-goroutine-and-channel-to-implement-interaction-with-timeout/</guid><description>背景介绍 前面的文章（见参考链接）已经介绍了如何使用按键作为树莓派的输入。在实际应用中可以通过按下按键循环显示预先设定的脚本输出到显示屏幕，需求如下：
如果按键不被触动，则定时5秒执行脚本获取最新内容显示； 因为不同的脚本获取内容速度会不一样，我们要求如果超过500ms脚本还未返回，需要在屏幕上显示“loading…”这样的过渡内容，如果脚本在500ms内返回，则不显示。 使用Goroutine和Channel可以很方便的实现这个需求。
代码 var screen_chan chan int var switch_chan = make(chan bool) func main() { //a goroutine： 检查按键是否被按 go func() { last_time := time.Now().UnixNano() / 1000000 btn_pushed := 0 total_mode := 3 for msg := range WiringPiISR(PIN_GPIO_6, INT_EDGE_FALLING) { if msg &amp;gt; -1 { n := time.Now().UnixNano() / 1000000 delta := n - last_time if delta &amp;gt; 300 { //如果两次按键变化的间隔时间&amp;lt;300ms，是因为接触信号不稳定可以忽略掉 last_time = n btn_pushed++ screen_chan &amp;lt;- btn_pushed % total_mode } } } }() //a goroutine： 根据管道消息刷新屏幕 go loop_update_display() //选择确实的屏幕内容脚本编号 screen_chan &amp;lt;- 0 //a goroutine: 定时5s向管道发送更新屏幕内容的信号 ticker := time.</description></item><item><title>Go语言内存模型</title><link>/post/2013/31-golang-memory-model/</link><pubDate>Sat, 20 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/31-golang-memory-model/</guid><description>名词定义 执行体 - Go里的Goroutine或Java中的Thread
背景介绍 内存模型的目的是为了定义清楚变量的读写在不同执行体里的可见性。理解内存模型在并发编程中非常重要，因为代码的执行顺序和书写的逻辑顺序并不会完全一致，甚至在编译期间编译器也有可能重排代码以最优化CPU执行, 另外还因为有CPU缓存的存在，内存的数据不一定会及时更新，这样对内存中的同一个变量读和写也不一定和期望一样。
和Java的内存模型规范类似，Go语言也有一个内存模型，相对JMM来说，Go的内存模型比较简单，Go的并发模型是基于CSP（Communicating Sequential Process）的，不同的Goroutine通过一种叫Channel的数据结构来通信；Java的并发模型则基于多线程和共享内存，有较多的概念（violatie, lock, final, construct, thread, atomic等）和场景，当然java.util.concurrent并发工具包大大简化了Java并发编程。
Go内存模型规范了在什么条件下一个Goroutine对某个变量的修改一定对其它Goroutine可见。
Happens Before 在一个单独的Goroutine里，对变量的读写和代码的书写顺序一致。比如以下的代码:
package main import ( &amp;#34;log&amp;#34; ) var a, b, c int func main() { a = 1 b = 2 c = a + 2 log.Println(a, b, c) } 尽管在编译期和执行期，编译器和CPU都有可能重排代码，比如，先执行b=2，再执行a=1，但c=a+2是保证在a=1后执行的。这样最后的执行结果一定是1 2 3，不会是1 2 2。但下面的代码则可能会输出0 0 0，1 2 2, 0 2 3 (b=2比a=1先执行), 1 2 3等各种可能。
package main import ( &amp;#34;log&amp;#34; ) var a, b, c int func main() { go func() { a = 1 b = 2 }() go func() { c = a + 2 }() log.</description></item><item><title>树莓派I2C编程</title><link>/post/2013/30-raspberrypi-i2c-programming/</link><pubDate>Thu, 18 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/30-raspberrypi-i2c-programming/</guid><description>(！未完！)
除了SPI协议外，树莓派还支持I2C。I2C是为了连接低速周边装置设计的，只需要用两根线（SDA和SCL，也就是树莓派的端口8和9-wiringPi编号）。
I2C 上图是一个主控使用I2C驱动3个设备的示意图
参考链接 http://zh.wikipedia.org/wiki/I²C https://projects.drogon.net/raspberry-pi/wiringpi/i2c-library/</description></item><item><title>使用Go语言在树莓派上编程</title><link>/post/2013/29-use-wiringpi-go-binding/</link><pubDate>Sun, 14 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/29-use-wiringpi-go-binding/</guid><description>WiringPi是树莓派上比较好的一个开发库，是用C语言写的。使用cgo，我们可以在Go语言里方便的调用WiringPI的函数，于是我包装了一个WiringPi-Go，目前支持wiringPi的基本功能，硬件SPI协议驱动Nokia 5110屏幕，以及中断，未来还会增加PWM和I2C协议的支持。
下面是一个完整的使用例子，结合了之前的两个电路：链接1，链接2
通过push button可以切换液晶屏显示不同脚本的输出内容。
lcd_switch.go
package main import ( . &amp;#34;github.com/hugozhu/rpi&amp;#34; &amp;#34;github.com/hugozhu/rpi/pcd8544&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os/exec&amp;#34; &amp;#34;time&amp;#34; ) const ( DIN = PIN_MOSI SCLK = PIN_SCLK DC = PIN_GPIO_2 RST = PIN_GPIO_0 CS = PIN_CE0 PUSHBUTTON = PIN_GPIO_6 CONTRAST = 40 //may need tweak for each Nokia 5110 screen ) var screen_chan chan int var TOTAL_MODES = 3 func init() { WiringPiSetup() pcd8544.LCDInit(SCLK, DIN, DC, CS, RST, CONTRAST) screen_chan = make(chan int, 1) } func main() { //a goroutine to check button push event go func() { last_time := time.</description></item><item><title>使用tsar记录和监控树莓派CPU温度</title><link>/post/2013/28-use-tsar-to-monitor-raspberry-pi/</link><pubDate>Sat, 13 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/28-use-tsar-to-monitor-raspberry-pi/</guid><description>夏天到了，树莓派的CPU温度也开始节节攀升，虽然我们也可以用云服务cosm来监控，但每5分钟采样一次精度不够高，每分钟采样一次则上传次数又太多了点。最好的方法还是使用tsar这样的工具本地高频（如每1分钟）采样，然后再定时将5分钟的均值上传到cosm绘图。
Tsar是淘宝的一个用来收集服务器系统和应用信息的采集报告工具，如收集服务器的系统信息（cpu，mem等），以及应用数据（nginx、swift等），收集到的数据存储在服务器磁盘上，可以随时查询历史信息，也可以将数据发送到nagios报警。Tsar能够比较方便的增加模块，只需要按照tsar的要求编写数据的采集函数和展现函数，就可以把自定义的模块加入到tsar中。
更新 [2013-04-14] mod_rpi已经被合并到了主干代码：https://github.com/alibaba/tsar/blob/master/modules/mod_rpi.c 只需要增加文件：/etc/tsar/conf.d/rpi.conf，内容为以下即可开始使用mod_rpi模块：
mod_rpi on ####add it to tsar default output output_stdio_mod mod_rpi mod_rpi模块开发方法 首先按照安装说明，见https://github.com/alibaba/tsar将tsar和tsardevel安装好。
首先运行下面的命令生成mod_rpi模块：
hugo@raspberrypi2 ~/projects/tsardevel $ tsardevel rpi build:make install:make install uninstall:make uninstall hugo@raspberrypi2 ~/projects/tsardevel $ ls rpi Makefile mod_rpi.c mod_rpi.conf 然后修改mod_rpi.c，增加读取CPU温度的逻辑：
/* * (C) 2010-2011 Alibaba Group Holding Limited * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.</description></item><item><title>Raspberry Pi的GPIO中断编程</title><link>/post/2013/27-interrupts-with-gpio-pins/</link><pubDate>Mon, 08 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/27-interrupts-with-gpio-pins/</guid><description>背景介绍 树莓派的GPIO引脚不仅可以输出高低电平，也可以当做输入端口（可以想象成键盘输入），当GPIO接入的是高电平，GPIO的值可以认为是1，如果是低电平则是0。如下图所示，可以使用一个Push Button开关按键来控制GPIO 25（BCM Numbering）的高低电平以达到控制的目的。
GPIO 25和VCC（3.3V）之间通过R1（10K欧姆）和R2（1K欧姆）上拉电阻相连，当按键未被按下时，GPIO 25上拉到VCC，程序可以读到1，当按键按下时，GPIO 25被下拉电阻R2拉到GND（0V），程序可以读到0。如果不加R1，而GPIO 25不小心被设置成输出低电平时，将直接和VCC相连而造成短路，这样可能会烧掉这个引脚，所以加上限流电阻R1后，即使发生这样的情况，也不会出现短路情况。
应用 如果我们需要根据GPIO 25的值来控制树莓派，比如按下按钮时希望点亮某个LED或在液晶上显示当前时间，就需要通过程序来获取状态的变化。
一种常见的做法是在循环里不断读取该引脚的状态，当发生对应的变化的时执行控制逻辑，但显而易见，这种做法很消耗CPU，如果在循环增加sleep(1000)这样的调用，又很容易错过按键变化。较好的做法则是通过中断来实现。
最新的树莓派Raspbian和Arch Linux内核都已经包含了GPIO的中断处理支持。但使用前需要将指定GPIO引脚输出，方法如下：
首先可以通过命令echo 25 &amp;gt; /sys/class/gpio/export导出GPIO 25端口，执行成功后在相应的目录下看到以下文件，得益于Linux下一切都是文件的设计理念，GPIO的状态可以通过value文件来获取，这样就可以利用Linux的poll/epoll来获取value文件的变化(这点和Linux高性能网络编程是类似的)。
root@raspberrypi2 ~/projects/interrupt_test # ls -l /sys/class/gpio/gpio25/ total 0 -rw-r--r-- 1 root root 4096 Apr 8 23:56 active_low -rw-r--r-- 1 root root 4096 Apr 8 22:29 direction -rw-r--r-- 1 root root 4096 Apr 8 22:29 edge drwxr-xr-x 2 root root 0 Apr 8 23:56 power lrwxrwxrwx 1 root root 0 Apr 8 23:56 subsystem -&amp;gt; .</description></item><item><title>备份Raspberry Pi</title><link>/post/2013/26-backup-raspberry-pi/</link><pubDate>Mon, 08 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/26-backup-raspberry-pi/</guid><description>树莓派的操作系统安装在SD卡，使用一段时间后还是很有必要备份一下，以防哪天SD卡就坏了。
备份的目的地最方便的还是使用网络存储，我使用的是西部数据的MyBooklive3T网络硬盘。挺不错的一个产品，功能基本满足我的需求。
准备好备份目标盘，将Nas的备份目录mount到树莓派:
mkdir /mnt/backup mount -t cifs //mybooklive/Public/Backup /mnt/backup -o guest 完整备份 确定相应的SD卡设备ID
root@raspberrypi2 ~/bin # fdisk -l Disk /dev/mmcblk0: 1973 MB, 1973420032 bytes, 3854336 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x0004f23a Device Boot Start End Blocks Id System /dev/mmcblk0p1 * 2048 186367 92160 c W95 FAT32 (LBA) /dev/mmcblk0p2 186368 3667967 1740800 83 Linux Disk /dev/sda: 2107 MB, 2107637760 bytes, 4116480 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 执行备份</description></item><item><title>在Raspberry Pi上使用硬件SPI</title><link>/post/2013/25-get-spi-working-on-raspberry-pi-spi/</link><pubDate>Fri, 05 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/25-get-spi-working-on-raspberry-pi-spi/</guid><description>什么是SPI SPI (Serial Peripheral Interface)，是一种高速，全双工，同步的通信总线协议，基于SPI的设备需要4根线：
SDO / MOSI - 主设备数据输出，从设备数据输入 SDI / MISO - 主设备数据输入，从设备数据输出 SCLK / CLK - 时钟信号，由主设备产生 CS / SS - 从设备使能信号，由主设备控制 通过CS，主设备可以控制和哪个从设备通信。
Bit Banging Bit-banging是一种用软件替代专职硬件的串行通信的技术。软件直接对微处理器的管脚的状态进行设置和采样，其功能涵盖诸如：时钟，电平，同步等所有参数。与此不同的是（传统的串行通信技术中），专职硬件诸如 modem、UART 或者 位移寄存器等一般是用来处理这些参数并且提供一个（缓存）的数据接口，软件在这种情况下同信号处理无关。
bit-banging 具有明显优点诸如：让相同的设备运行不同的协议而只需很小的（甚至不需）硬件的改动。借助很少的额外设备，我们也许可以从数字管脚（数字终端）可以得到视频信号。
bit-banging 也有一些明显的缺点。在软件仿真的过程中消耗的能量比同样功能的专职硬件大。微处理器过忙地从管脚采样和发送采样信号到管脚。在同等微处理器处理能力下，系统常常会有些噪音。
在Rasperry Pi上使用Bit Banging在实际情况下有可能因为操作系统调度造成时钟信号不稳定而使设备收到错误的消息，具体的表现就是Nokia 5110屏在长时间运行过程中出现白屏或花屏现象，如下图：
采用硬件SPI，由Pi的管脚14号Pin（左边倒数第二个）SCLK发出一定频率的时钟信号。经过测试，这种方法产生的时钟信号比Bit Banging软件模拟产生的信号要稳定很多。
软件模拟时钟信号波形 硬件SPI时钟信号波形 测试Pi的硬件SPI 确认内核支持 root@raspberrypi2 ~/projects/spi_test # ls -la /dev/spi* crw------- 1 root root 153, 0 Jan 1 1970 /dev/spidev0.0 crw------- 1 root root 153, 1 Jan 1 1970 /dev/spidev0.</description></item><item><title>在Raspberry Pi上使用Google Channel服务搭建实时应用</title><link>/post/2013/24-google-channel-service/</link><pubDate>Wed, 03 Apr 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/24-google-channel-service/</guid><description>前面提到了有关个人网站的实时在线人数问题，本文要讨论的是如何自己来实现一个这样的统计服务。因为网站也同时部署在Github上，海外用户访问Github镜像网站的访问日志Pi是拿不到的，这怎么办？
Google Channel Service Google Channel Service允许应用和GAE (Google App Engine) 保持一个长连接，允许应用实时发送消息给JavaScript客户端，而不用让客户端用效率很低的定时轮询获取新消息。这个服务是允许有多个发布者和多个订阅者，也能创建多个主题来关联发布者和订阅者。
使用这个服务分两步：
客户端请求服务器端（部署在GAE上）获取一个Channel的Token： 客户端根据Channel Token和服务器建立长连接，并开始接收消息，这时其它的客户端（或服务器端）可以想这个通道发送消息 在线人数统计实现 在页面上部署beacon 通常的网站流量统计是依赖部署在页面上的beacon（Javascript或图片标签）来实现的，这样做的好处是可以直接过滤掉一些机器流量，并且可以将日志集中存储在日志收集服务器上，和网站分离开。
于是可以利用GAE实现一个简单的Beacon服务，这里采用Go语言来实现，用Java或Python也是可以的。
package counter import ( &amp;#34;encoding/base64&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;appengine&amp;#34; &amp;#34;appengine/channel&amp;#34; ) var GIF []byte const ( TOPIC = &amp;#34;counter&amp;#34; ) func init() { GIF, _ = base64.StdEncoding.DecodeString(&amp;#34;R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;#34;) http.HandleFunc(&amp;#34;/beacon.gif&amp;#34;, handler) http.HandleFunc(&amp;#34;/new_token&amp;#34;, handler_new_token)	} func handler(w http.ResponseWriter, r *http.Request) { context := appengine.NewContext(r) now := time.Now() expire := now.AddDate(30, 0, 0) zcookie, _ := r.</description></item><item><title>Arduino初试</title><link>/post/2013/23-arduino-1st-day/</link><pubDate>Thu, 28 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/23-arduino-1st-day/</guid><description>今天拿到一块Arduino UNO R3板，迫不及待就开始试用了。相比Raspberry Pi是一个全能的电脑，Arduino则是个硬件开源的单片机，因为开源，资料和配件网上就很很多了，也就容易让初学者上手了。
Arduino特点:
开源，硬件标准化，配套传感器等模块很多； 结构简单 实时系统，稳定，启动只要0.5秒 Arduino IDE 下载Arduino IDE
上电测试 用USB线接在电脑USB口，然后在GND和PIN 13上插一个二极管，注意二极管正极插在PIN 13上, 如下图： (注：还应该串联一个300欧姆的限流电阻才保险！)
上传代码 在Arduino IDE编辑好下面的代码，然后点Upload后就会运行了，会看到LED一闪一闪。
/* Blink Turns on an LED on for one second, then off for one second, repeatedly. This example code is in the public domain. */ // Pin 13 has an LED connected on most Arduino boards. // give it a name: int led = 13; // the setup routine runs once when you press reset: void setup() { // initialize the digital pin as an output.</description></item><item><title>并发编程之内存屏障</title><link>/post/2013/22-memory-barriers-or-fences/</link><pubDate>Thu, 28 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/22-memory-barriers-or-fences/</guid><description>原文地址：http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html 或 http://ifeve.com/memory-barriersfences/
关键词：Load Barrier, Store Barrier, Full Barrier
本文我将和大家讨论并发编程中最基础的一项技术：内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。
CPU使用了很多优化技术来达成一个事实：CPU执行单元的速度要远超主存访问速度。在我上一篇文章 &amp;ldquo;Write Combing - 合并写&amp;quot;中我已经介绍了其中的一项技术。CPU避免内存访问延迟最常见的技术是将指令管道化，然后尽量重排这些管道的执行以最大利用缓存而把因为缓存未命中引起的延迟降到最小。
当一个程序执行时指令是否被重排并不重要，只要最终的结果是一样的。例如，在一个循环里，如果循环体内没用到这个计数器，循环的计数器什么时候更新（在循环开始，中间还是最后）并不重要。编译器和CPU可以自由的重排指令以最佳的利用CPU，只要下一次循环前更新该计数器即可。并且在循环执行中，这个变量可能一直存在寄存器上，并没有被推到缓存或主存，这样这个变量对其他CPU来说一直都是不可见的。
CPU核内部包含了多个执行单元。例如，现代Intel CPU包含了6个执行单元，可以组合进行算术运算，逻辑条件判断及内存操作。每个执行单元可以执行上述任务的某种组合。这些执行单元是并行执行的，这样指令也就是在并行执行。但如果站在另一个CPU角度看，这也就产生了程序顺序的另一种不确定性。
最后，当一个缓存失效发生时，现代CPU可以先假设一个内存载入的值并根据这个假设值继续执行，直到内存载入返回确切的值。
CPU核 | V 寄存器 | V 执行单元 -&amp;gt; Load/Store缓冲区-&amp;gt;L1 Cache ---&amp;gt;L3 Cache--&amp;gt;内存控制器--&amp;gt;主存 | | +-&amp;gt; Write Combine缓冲区-&amp;gt;L2 Cache ---+ 代码顺序并不是真正的执行顺序，CPU和编译器可以各种优化只要有空间提高性能。缓存和主存的读取会利用load, store和write-combining缓冲区来缓冲和重排。这些缓冲区是查找速度很快的关联队列，当一个后来发生的load需要读取上一个store的值，而该值还没有到达缓存，查找是必需的，上图描绘的是一个简化的现代多核CPU，从上图可以看出执行单元可以利用本地寄存器和缓冲区来管理和缓存子系统的交互。
在多线程环境里需要使用技术来使得程序结果尽快可见。这篇文章里我不会涉及到 Cache Conherence 的概念。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为内存屏障或内存栅栏。
内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。
大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。相对来说Intel CPU的强内存模型比DEC Alpha的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。因为x86处理器是在多线程编程中最常见的，下面我尽量用x86的架构来阐述。
Store Barrier Store屏障，是x86的&amp;rdquo;sfence&amp;ldquo;指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。一个实际的好例子是Disruptor中的BatchEventProcessor。当序列Sequence被一个消费者更新时，其它消费者(Consumers)和生产者（Producers）知道该消费者的进度，因此可以采取合适的动作。所以屏障之前发生的内存更新都可见了。
private volatile long sequence = RingBuffer.INITIAL_CURSOR_VALUE; // from inside the run() method T event = null; long nextSequence = sequence.</description></item><item><title>个人网站实时在线人数接口</title><link>/post/2013/21-realtime-online-user-counter/</link><pubDate>Wed, 27 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/21-realtime-online-user-counter/</guid><description>感觉把个人网站正在访问的在线人数显示在Nokia 5110液晶屏挺好玩，就稍微研究了一下如何提取实时在线人数。
实现方法 Google Analytics Google Analytics具有很强大的实时流量分析功能，不过网站主必须登陆到后台才能看，但并没有提供Open API，所以就不能用这个服务了。
日志分析 不修改网站通过web服务器的日志分析，用一个脚本统计15分钟内日志的Unique IP可以粗略的获得一个在线人数。 但多个用户可能通过一个IP过来，这种做法肯定不精确。一般我们可以通过在页面上部署Javascript脚本，由Javascript为每一个浏览器产生一个独特的持久化Cookie，用这个Cookie代替IP来统计。但用Raspberry Pi来做这件事情会拖慢网站，于是一种方案是采用免费的Google App Engine来实现，打算有空来实现一个。
CNZZ CNZZ也提供了15分钟内的在线人数统计功能。分析CNZZ的计数器代码后发现如下方法可以提取到在线人数:
curl -s &amp;#34;http://online.cnzz.com/online/online.php?id=[your_cnzz_id]&amp;amp;h=[your_cnzz_server_id].cnzz.com&amp;amp;on=1&amp;amp;s=line&amp;#34; | sed -e &amp;#39;s/.*当前在线\[\([0-9]\).*/\1/g&amp;#39; 于是先通过上面的脚本提取在线人数并上传到Cosm，Cosm有个触发器功能可以当在线人数超过某个值后发Twitter或HTTP Post到指定URL，并通过程序显示在液晶屏上。</description></item><item><title>升级版电子钟 - 如何使用Raspberry Pi驱动Nokia 5110液晶屏</title><link>/post/2013/20-raspberry-pi-drive-nokia-5110/</link><pubDate>Sun, 24 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/20-raspberry-pi-drive-nokia-5110/</guid><description>Nokia 5110屏比前面介绍过的1602液晶屏功能好很多，淘宝上买价格相差不大（二手5110 12块左右, 全新1602 8块左右），Nokia 5110最少只需要占用4个GPIO引脚：
带蓝色背光 使用Philips PCD8544 LCD控制器（通过SPI接口） 84x48点阵，可显示100多个字符 硬件准备 树莓派 Nokia 5110 拆机屏 或 焊好的？ 注意不要买裸屏，需要带电路板的 杜邦线 母对母8条 8P排针 用来焊接5110屏幕PCB板 电烙铁 电路 5110电路板有8个引脚，使用排针（如下图）将其焊上，方便后面用杜邦线连接，如果不会焊也可以买焊接好的。
RST —— 复位 接GPIO 0 CE —— 片选 接GPIO 1 或 不接 DC —— 数据/指令选择 接GPIO 2 DIN —— 串行数据线 接GPIO 3 CLK —— 串行时钟线 接GPIO 5 （因为我的GPIO 4已经接了一个DHT11传感器） VCC —— 电源输入 接3.3v BL —— 背光控制端 接3.3v GND —— 地线 接地 PS. 编号规范看这里 VCC, BK, GND可以接在面包板电源上</description></item><item><title>如何使用Raspberry Pi在1602液晶屏上显示当前时间--电子钟</title><link>/post/2013/19-raspberry-pi-drive-1602-lcd/</link><pubDate>Sat, 23 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/19-raspberry-pi-drive-1602-lcd/</guid><description>硬件准备 需要以下硬件：
树莓派 面包板 1602液晶屏一块 10K电位器 杜邦线 排针 面包板电源 1602 LCD液晶屏 LCD1602液晶屏提供了16列x2行的ASCII字符显示能力，工作电压5V，提供4位数据与8位数据两种工作模式，因为Raspberry Pi的GPIO口数量很有限，所以使用4位数据模式。LCD1602液晶屏模块提供了16个引脚，我们只需接其中的12个即可&amp;ndash;请参考GPIO命名规则：
VSS，接地，RPi PIN 6 VDD，接5V电源，PRi PIN 2 VO，液晶对比度调节，接电位器中间的引脚 RS，寄存器选择，接GPIO 14，RPi PIN 8 RW，读写选择，接地，表示写模式，PRi PIN 6 EN，使能信号，接GPIO 15，RPi PIN 10 D0，数据位0，4位工作模式下不用，不接 D1，数据位1，4位工作模式下不用，不接 D2，数据位2，4位工作模式下不用，不接 D3，数据位3，4位工作模式下不用，不接 D4，数据位4，接GPIO 17，RPi PIN 11 D5，数据位5，接GPIO 18，RPi PIN 12 D6，数据位6，接GPIO 27，RPi PIN 13 D7，数据位7，接GPIO 22，RPi PIN 15 A，液晶屏背光+，接5V，RPi PIN 2 K，液晶屏背光-，接地，RPi PIN 6 注意事项 电源VDD最后接上 排针焊接在液晶屏时注意不要虚焊，也可以用万用表测量一下 RW脚注意一定要接地 调节电位器可以调节液晶对比度 电路图 代码 #!/usr/bin/python # # based on code from lrvick and LiquidCrystal # lrvic - https://github.</description></item><item><title>Raspberry Pi GPIO的编号规范</title><link>/post/2013/19-raspberry-pi-gpio-port-naming/</link><pubDate>Fri, 22 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/19-raspberry-pi-gpio-port-naming/</guid><description>树莓派和普通电脑不一样的地方在于它还带了17个可编程的GPIO（General Purpose Input/Output），可以用来驱动各种外设（如传感器，步进电机等）。但GPIO的编号方法有些混乱，不同的API（如wiringPi，RPi.GPIO等）对GPIO的端口号编号并不一样，下面则用图表标明了对应的叫法，这样在看程序例子的时候可以确定物理是哪个接口。
GPIO库 wiringPi C，有Perl, PHP, Ruby, Node.JS和**Golang**的扩展，支持wiringPi Pin和BCM GPIO两种编号 RPi.GPIO Python，支持Board Pin和BCM GPIO两种编号 Webiopi，Python, 使用BCM GPIO编号 WiringPi-Go, Go语言，支持以上三种编号 编号规范 第一列是wiringPi API中的缺省编号，wiringPiSetup()采用这列编号 第二列（Name）往往是转接板的编号 第三列是树莓派板子上的自然编号（左边引脚为1-15，右边引脚为2-26），RPi.GPIO.setmode(GPIO.BOARD)采用这列编号 树莓派主芯片提供商Broadcom的编号方法，相当于调用了WiringPiSetupGpio()或RPi.GPIO.setmode(GPIO.BCM)采用这列编号 wiringPi Pin Name Board Pin BCM GPIO 0 GPIO 0 11 17 1 GPIO 1 12 18 2 GPIO 2 13 21 3 GPIO 3 15 22 4 GPIO 4 16 23 5 GPIO 5 18 24 6 GPIO 6 22 25 7 GPIO 7 7 4 8 SDA 3 0 9 SCL 5 1 10 CE0 24 8 11 CE1 26 7 12 MOSI 19 10 13 MISO 21 9 14 SCLK 23 11 15 TXD 8 14 16 RXD 10 15 Rev.</description></item><item><title>如何使用Raspberry Pi测量室内温度和湿度并绘制曲线</title><link>/post/2013/03-17-interfacing-temperature-and-humidity-sensor-with-raspberry-pi/</link><pubDate>Sun, 17 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/03-17-interfacing-temperature-and-humidity-sensor-with-raspberry-pi/</guid><description>硬件准备 需要以下硬件：
可以工作的树莓派一个 面包板和公对母杜邦线 10K 电位器一个 DHT11温度和湿度传感器一个或DHT22 传感器电路及原理 DHT11传感器外观 参数 湿度测量范围：20％～90%RH(0－50℃温度补偿）； 温度测量范围：0～+50℃； 湿度测量精度：±5.0%RH 温度测量精度：±2.0℃ 响应时间：&amp;lt;5s； 电路图 DHT11一共4根引脚，左边第一根接电源5V (Pin 1)，第二根为数据接口，接 Pin 7，第三根不接，第四根接地；在Pin 1和Pin7 之间还需要并联10K的电阻，以保持读数稳定。
安装好的样子： 读取温度和湿度的代码 数据读取流图：
#include &amp;lt;wiringPi.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; #define MAX_TIME 85 #define DHT11PIN 7 int dht11_val[5]={0,0,0,0,0}; int errors=0; void dht11_read_val() { uint8_t lststate=HIGH; uint8_t counter=0; uint8_t j=0,i; float farenheit; for(i=0;i&amp;lt;5;i++) dht11_val[i]=0; pinMode(DHT11PIN,OUTPUT); digitalWrite(DHT11PIN,LOW); delay(18); digitalWrite(DHT11PIN,HIGH); delayMicroseconds(40); pinMode(DHT11PIN,INPUT); for(i=0;i&amp;lt;MAX_TIME;i++) { counter=0; while(digitalRead(DHT11PIN)==lststate){ counter++; delayMicroseconds(1); if(counter==255) break; } lststate=digitalRead(DHT11PIN); if(counter==255) break; // top 3 transistions are ignored if((i&amp;gt;=4)&amp;amp;&amp;amp;(i%2==0)){ dht11_val[j/8]&amp;lt;&amp;lt;=1; if(counter&amp;gt;16) dht11_val[j/8]|=1; j++; } } // verify cheksum and print the verified data if((j&amp;gt;=40)&amp;amp;&amp;amp;(dht11_val[4]==((dht11_val[0]+dht11_val[1]+dht11_val[2]+dht11_val[3])&amp;amp; 0xFF))) { //farenheit=dht11_val[2]*9.</description></item><item><title>如何使用Raspberry Pi控制步进电机旋转高清摄像头并拍照</title><link>/post/2013/03-16-use-raspberry-pi-control-step-motor-rotate-webcam/</link><pubDate>Sat, 16 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/03-16-use-raspberry-pi-control-step-motor-rotate-webcam/</guid><description>硬件准备 需要以下硬件：
可以工作的树莓派一个 母对母1P杜邦线6根 DC 5V4相28YBJ-48步进电机一个 UL2003芯片步进电机驱动板一块 安装 按下图将步进电机接到驱动板上，也就是白色的接口
步进电机电源 步进电机需要5V电压驱动，而树莓派的GPIO接口中已有5V输出，将图中的Pin 2（最右上角那个）5V，接到驱动板的5V正极，Pin 6接到5V负级，电源部分则搞定。
步进电机驱动线路 驱动板上有IN1, IN2, IN3, IN4四个接口，根据资料得知这四个接口依次设置为低电平就可以驱动，我们分别用杜邦线将GPIO 17（Pin 11），GPIO 18（Pin 12）, GPIO 21（Pin 13）, GPIO 22（Pin 15）和IN1，IN2，IN3，IN4一一相连。 注意不同的GPIO驱动程序对端口的编号不一定一样（至少有三种叫法：Board，Broadcom，GPIO）
驱动原理：（每次将四个GPIO端口按下表依次设置好电平后，可以sleep几十毫秒来控制转速）
序列 GPIO 17 GPIO 18 GPIO 21 GPIO 22 0 LOW HIGH HIGH HIGH 1 HIGH LOW HIGH HIGH 2 HIGH HIGH LOW HIGH 3 HIGH HIGH HIGH LOW 4 LOW HIGH HIGH HIGH … 安装摄像头 本来是希望用3D打印机来制作齿轮和支架来完成这部分工作的，但因为打印机还没到货，所以先用乐高积木来做了, 刚好乐高积木可以插在步进电机中轴上，而且很牢靠，还不用密封带了。
摄像头如下图用两根导线固定在乐高积木上：
然后用各种积木搭个底座把电机固定起来，并留两个洞口可以将驱动线和摄像头的USB线穿出，这样表面上比较整齐，USB线也不会因为牵扯影响转动。</description></item><item><title>如何在Raspberry Pi上用LED闪烁提示网站首页新访客</title><link>/post/2013/vistor-on-homepage-led-indicator/</link><pubDate>Wed, 13 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/vistor-on-homepage-led-indicator/</guid><description>本方法只适合小网站，主要是好玩。Raspberry Pi不是很合适需要实时控制的系统（比如，飞行器，遥控小车），因为Linux内核要多任务，应用程序的优先级不能保持最高，会带来延时，但做些实时性要求不高的系统还是可以的。
硬件安装 需要以下硬件：
可以工作的树莓派一个 1P杜邦线2条 面包板一个 面包板跳线 或 单排针 两根 发光二极管一个 300欧姆的电阻一个 GPIO接口 用杜邦线将上图的3.3V输出和GPIO 23引出（板子正面朝上，GPIO引脚在左上角），将电阻和LED串联起来（电阻防止LED电流过大烧掉），注意二极管的两根脚不一样长，长脚的接正级，这样GPIO 23如果输出高电平，二极管就不发光了，输出低电平就亮啦！
都接好了后的样子如下：
GPIO接口编程 WiringPi An implementation of most of the Arduino Wiring functions for the Raspberry Pi。 代码地址在： https://github.com/wiringPi
安装：
git clone https://github.com/WiringPi/WiringPi cd WiringPi/wiringPi sudo make install	让二极管闪一下的示例代码：
#include &amp;lt;wiringPi.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main (int argc, char* argv[]) { int pinNumber = 4; if (-1 == wiringPiSetup()) { printf(&amp;#34;failed to setup wiringPi&amp;#34;); return 1; }	pinMode(pinNumber, OUTPUT); digitalWrite(pinNumber, 1); delay(200); digitalWrite(pinNumber, 0); delay(200); return 0;	} WiringPi也有Python, Perl, PHP, Ruby的接口包装，按这里，怎么没有Go的呢。。。</description></item><item><title>在Raspberry Pi上安装ArchLinux</title><link>/post/2013/setup-archliunx-on-raspberry-pi/</link><pubDate>Sat, 09 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/setup-archliunx-on-raspberry-pi/</guid><description>介绍 之前买的Raspberry Pi因为要跑这个网站，不能经常拔下来玩别的，所以又买了一个，这次安装的是Arch Linux。这个发行版安装好后非常基础，占用的空间也只有600M不到，比较合适已有Linux基础的同学玩。初学者可以玩官方推荐的Raspbian。
Arch Linux特点：
启动快，上电后只要3s完成启动 安装完没有图形界面，干净 面向开发者的系统 包管理系统pacman很好用，一个命令就可以完成各种操作 ArchLinux缺省账号和密码是root/root，弄好了后要记得修改root密码 从中国用下载包很快，比Raspbian的源快多了 增加sudo用户 useradd hugo passwd hugo mkdir /home/hugo chown hugo:hugo /home/hugo pacman -S sudo visudo 执行visudo把新用户设置成管理员（增加sudo权限），最后面增加下面一行：
hugo ALL=(ALL) NOPASSWD: ALL USB盘 插上USB盘后，ArchLinux并不会自动mount，手动mount的过程如下: 插上USB前后执行两次 lsblk -o name,kname,uuid，那么输出上多出的那行就是该USB的设备名，或UUID，找到该行后就可以执行mount命令了（注意sda这个符号不同机器可能不一样）
[root@raspberrypi2 ~]# lsblk -o name,kname,uuid NAME KNAME UUID sda sda 001B-9622 mmcblk0 mmcblk0 ├─mmcblk0p1 mmcblk0p1 44C8-CEF1 └─mmcblk0p2 mmcblk0p2 fcee8534-f5f0-42ee-83ac-f943f878ee67 mkdir /mnt/usb mount /dev/sda /mnt/usb 或 mount -U 001B-9622 /mnt/usb 格式化整个USB盘可以用mkfs.ext4 /dev/sda 然后在/etc/fstab里增加一行，以后重启就会自动mount了：
/dev/sda /mnt/usb ext4 defaults,noatime 0 0 还可以测试一下SD卡和USB盘的读写性能：</description></item><item><title>如何封杀尝试Raspberry Pi SSH密码的来源IP</title><link>/post/2013/block_failed_ssh_attempts_with_iptable/</link><pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/block_failed_ssh_attempts_with_iptable/</guid><description>Raspberry Pi整天开着，如果用缺省SSH端口对外开放，就会经常遇到扫描SSH密码的肉鸡。虽然密码不是很简单，但还是感觉很不安全的。
系统的ssh登录日志文件在：/var/log/auth.log，登录失败时会记录以下格式的日志：
Mar 7 10:31:51 raspberrypi sshd[24510]: Failed password for root from 221.8.19.129 port 4066 ssh2 Mar 7 10:31:55 raspberrypi sshd[24514]: Failed password for root from 221.8.19.129 port 4079 ssh2 Mar 7 10:31:56 raspberrypi sshd[24518]: Failed password for sshd from 221.8.19.129 port 4080 ssh2 Mar 7 10:32:26 raspberrypi sshd[24522]: Failed password for sshd from 221.8.19.129 port 4149 ssh2 用最简单的Shell脚本来解决这个问题：
guard.sh #!/bin/bash last_ip=&amp;quot;&amp;quot; tail -f /var/log/auth | while read LINE; do { if [[ &amp;quot;${LINE}&amp;quot; =~ &amp;quot;Failed&amp;quot; ]]; then ip=&amp;quot;$(echo ${LINE} | awk '{print $(NF-3)}')&amp;quot; if [[ &amp;quot;$last_ip&amp;quot; == &amp;quot;$ip&amp;quot; ]]; then echo &amp;quot;block $ip&amp;quot; #curl -s --data-ascii &amp;quot;uuid=&amp;lt;my iphone's uuid&amp;gt;&amp;quot; --data &amp;quot;body=${LINE}&amp;quot; http://raspberrypi/pushme iptables -A INPUT -s &amp;quot;$ip&amp;quot; -j DROP fi last_ip=$ip echo $LINE fi } done 用root用户执行以下命令，也可以放到启动脚本里：/etc/rc.</description></item><item><title>Raspberry Pi做BT下载机+高清播放器</title><link>/post/2013/raspberry-pi-with-xmbc/</link><pubDate>Wed, 06 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/raspberry-pi-with-xmbc/</guid><description>介绍 首先高清播放器功能只是Raspberry Pi的一个小功能，如果你只需要高清播放功能又不想折腾，那还是买个山寨的的更简单。。。
Raspberry Pi的图形处理器规格：Broadcom VideoCore IV, OpenGL ES 2.0, 1080p 30 h.264/MPEG-4 AVC 高清解码器，内存和CPU共享（可设置成256M），性能还是很强劲的。HDMI支持640x350和1920×1200（1080P）的分辨率。安装了XBMC，基本上可以实现包括Airplay在内的Apple TV上的大部分功能，但价格只有其一半不到，可以播放下载的视频或观看在线视频，如一搜，优酷，搜狐视频，奇艺等。
外设 除了Pi单片机外，你还需要以下外设附件：
5V-1A左右的电源，可以用iPhone或iPad的充电电源，或手机的充电器，电流最少要800毫安 micro USB线一根，和Kindle以及大多数android手机充电USB线一样 HDMI线一根，接电视机 SD卡一张，最少2G Raspbmc Raspbmc 是专为在Raspberry Pi上运行XBMC的定制Linux。最小化的安装，减少了不必要的软件和资源占用，简化了安装和配置，没有Linux知识也可以上手。这个版本的维护者是一个19岁的小朋友Sam Nazarko。有时间折腾的同学可以自己编译XMBC安装。
特点： 免费，开源 支持多语言 支持1080P回放 支持直接播放NFS，SMB，FTP,HTTP或USB硬盘的有视频文件，支持大多数格式 支持AirPlay或AirTune功能，可以把iPhone/iPad上的视频或音乐通过Pi投放到电视上，这点和Apple TV功能一样 支持GPIO 基于Debian，可以从Debian的软件源安装其它软件 支持1080P DTS软解，这个不少播放器是不支持的，需要额外License 内置了以下服务: Samba TVHeadend Server FTP Server SSH Server 安装 Windows下载安装程序，运行即可。
Linux/Mac:
curl -O http://svn.stmlabs.com/svn/raspbmc/testing/installers/python/install.py chmod +x install.py sudo python install.py 或直接下载安装包安装
下载 你可以在Pi上外接一个USB移动硬盘，但要注意硬盘要有自己电源，也可以mount网络上的硬盘分区。然后运行transmission软件下载视频。
Transmission 安装
sudo apt-get install transmission-daemon sudo /etc/init.d/transmission-daemon stop sudo nano /etc/transmission-daemon/settings.</description></item><item><title>Java并发包中的同步队列SynchronousQueue实现原理</title><link>/post/2013/java-synchronousqueue-notes/</link><pubDate>Tue, 05 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/java-synchronousqueue-notes/</guid><description>介绍 Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。
不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。
SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。
实现原理 同步队列的实现方法有许多：
阻塞算法实现 阻塞算法实现通常在内部采用一个锁来保证多个线程中的put()和take()方法是串行执行的。采用锁的开销是比较大的，还会存在一种情况是线程A持有线程B需要的锁，B必须一直等待A释放锁，即使A可能一段时间内因为B的优先级比较高而得不到时间片运行。所以在高性能的应用中我们常常希望规避锁的使用。
public class NativeSynchronousQueue&amp;lt;E&amp;gt; { boolean putting = false; E item = null; public synchronized E take() throws InterruptedException { while (item == null) wait(); E e = item; item = null; notifyAll(); return e; } public synchronized void put(E e) throws InterruptedException { if (e==null) return; while (putting) wait(); putting = true; item = e; notifyAll(); while (item!=null) wait(); putting = false; notifyAll(); } } 信号量实现 经典同步队列实现采用了三个信号量，代码很简单，比较容易理解：</description></item><item><title>OpenVPN使用多个端口</title><link>/post/2013/openvpn-multiple-ports/</link><pubDate>Sat, 02 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/openvpn-multiple-ports/</guid><description>Openvpn本身不能设置多个端口，使用iptables可以解决这个问题 （假设openvpn本来56788端口）：
for port in {56780..56787} do iptables -t nat -A PREROUTING -p tcp -d &amp;lt;your_external_ip&amp;gt; --dport $port -j REDIRECT --to-port 56788 done</description></item><item><title>Java的资源管理</title><link>/post/2013/resource-management-in-java/</link><pubDate>Fri, 01 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/resource-management-in-java/</guid><description>Overview Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。
try-catch-finally Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &amp;ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如FindBugs可以帮助发现此类问题。
首先我们来看一段文件操作代码：
private void copy(String from, String to) throws IOException { FileInputStream in = null; FileOutputStream out = null; in = new FileInputStream(from); out = new FileOutputStream(to); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } 一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-文件描述符，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。
File descriptor Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。
较为正确的代码应该是：
private void copy(String src, String dest) throws IOException { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); int c; while ((c = in.</description></item><item><title>在Ubuntu上配置L2TP，PPTP和OpenVPN服务</title><link>/post/2013/setup-l2tp-pptp-openvpn-on-ubuntu/</link><pubDate>Fri, 01 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/setup-l2tp-pptp-openvpn-on-ubuntu/</guid><description>Overview MacOS, Windows, iOS都内置支持PPTP，L2TP；OpenVPN需要安装客户端，手机上一般不支持。
先打开内核的IP转发，修改 /etc/sysctl.conf
net.ipv4.ip_forward=1 执行下面命令以生效
sudo sysctl -p PPTP 安装pptpd
apt-get install pptpd 编辑 /etc/pptpd.conf，下面两行取消注释
localip 192.168.0.1 remoteip 192.168.0.234-238,192.168.0.245 这行注释掉
#logwtmp 从文件 /etc/pptpd.conf 中找到配置选项文件，如下为：/etc/ppp/pptpd-options
grep options /etc/pptpd.conf # Specifies the location of the PPP options file. # By default PPP looks in '/etc/ppp/options' option /etc/ppp/pptpd-options # option in the pppd options file, or run bcrelay. 编辑 /etc/ppp/pptpd-options，增加以下内容，最后两项为推给VPN客户端的DNS服务器IP
mtu 1492 name pptpd refuse-pap refuse-chap refuse-mschap require-mschap-v2 require-mppe-128 proxyarp lock nobsdcomp novj novjccomp nologfd ms-dns 8.</description></item><item><title>Java程序的日志</title><link>/post/2013/logging-in-java/</link><pubDate>Thu, 28 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/logging-in-java/</guid><description>Overview 一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。
一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：
对程序运行情况的记录和监控； 在必要时可详细了解程序内部的运行状态； 对系统性能的影响尽量小； 日志规范 程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。 首先我们有必要了解一下Linux普遍使用的Syslog标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。
下面是部分常见的Syslog模块类型：
模块ID 关键词 描述 0 kern 内核消息 1 user 用户级别消息 2 mail 邮件系统 3 daemon 系统后台守护程序 4 auth 安全/鉴权消息 5 syslog syslogd内部产生的日志消息 … 以及Syslog严重程度划分：
代码 严重程度 关键词 描述 0 Emergency emerg(panic) 紧急，系统已经不稳定了 1 Alert alert 需要立刻采取措施 2 Critical crit 严重情况 3 Error err (error) 系统出错 4 Warning warning(warn) 系统警告 5 Notice notice 系统仍然正常，但值得注意 6 Informational info 正常系统通告 7 Debug debug 系统调试信息 在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。</description></item><item><title>在线广告系统架构变迁</title><link>/post/2013/the-evolution-of-online-advertsing-system/</link><pubDate>Thu, 28 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/the-evolution-of-online-advertsing-system/</guid><description>Overview （未完）
广告按业务划分有以下几类：
展示广告（Banner广告） 搜索广告（关键词广告） 按计费模式有：
CPT: 按有效广告展示天数计费，可定价或竞价； CPM: 按有效广告展现次数计费，可定价或竞价； CPC: 按有效点击次数计费； CPS: 按效果计费，如，按成交订单额，按流量带来的有效下载或安装次数计费； 广告系统按结构可划分为以下子系统：
广告投送服务器 广告数据库及业务系统 用户行为跟踪系统 日志传输系统 流式数据分析和计算平台 离线数据分析和计算平台 从展示广告到搜索广告再到社会化广告 早期的互联网广告以展示广告为主，业务模式和在报纸，期刊上刊登广告相似，广告主按其广告的展现次数或时长来付费。直到1998年有个叫GoTo的公司（后公司改名为Overture，2005年被Yahoo收购）开始提供关键词广告，这是一种简单高效的定向广告，广告主可以按与其业务相关的关键词购买搜索流量，按访客的点击计费，和早期的展示广告相比这无疑是一个巨大的进步，通过关键词将用户和广告关联起来，而不是在广告位上一直展现同样的广告或随机的展现。随后Google迅速的采用了这个方法将自身的搜索流量变现，并不断优化和壮大，最终形成了Google的Adword产品，早期Google并不为搜索用户建立个性化数据，因此可用于定向的数据比较有限，于是Google又推出了AdSense产品，将触角伸向了全网，通过AdSense的合作网站，Google可以采集到访客在这些网站的访问足迹，并利用这些数据提高其广告的相关性；随着以Facebook为代表的社交网络的兴起，这些网站有个特点就是自身就具备了比较完善的用户个性化数据，利用这些数据，网站可以将定向技术使用到展示广告，这使展示广告迎来了第二春，广告产业对数据的应用价值有了极大的兴趣，也催化了大数据的技术广泛应用。近年来一种新的广告业务模式&amp;ndash;“实时竞价广告交易系统”也逐渐被网站主和广告主接受，其核心目的是让每次广告展现都创造出尽可能多的回报，以自动化的方式系统使用实时数据和竞价信息将广告空间分配给那一时刻出价最高的销售渠道。
广告系统的架构变迁 早期的展示广告系统因为业务数据量不大，广告位按时长售卖。系统架构上比较简单。系统核心为关系数据库，广告主通过业务系统管理广告数据：账户设置，广告计划，预算，推广单元，广告创意等；通过审核后可以投放的数据进入广告投放服务器。简单的广告系统可以完全围绕数据库来实现。投放服务器直接访问数据库获取需要投放的广告数据，并通过缓存来提高性能，减少对数据库的压力。
图[简单的广告系统架构]
当广告系统里的广告主越来越多，广告位的流量越来越大，直接访问数据库的做法不能满足性能和扩展性的要求，主要原因是传统的关系数据库的设计目标是通用的需求。这种情况下广告系统可以定时将广告数据从数据库中导出，生成的数据文件通过网络传到投放服务器，投放服务器将数据文件载入内存供快速访问，当用户打开网站页面时候，部署在广告位的代码（可部署在客户端或服务器端）将参数传给广告投放服务器，投放服务器按一定策略和逻辑取出需要展现给用户的广告数据，按接口规范直接返回给用户浏览器渲染，或返回给调用广告引擎的服务器端程序，再由服务器端程序将广告嵌入内容页面。
图[改进后的简单的广告系统架构]
对于大多数中小网站，广告是其运营收入重要的一部分，在网站上部署广告一般有下面几种方法：
接入大型广告网络 这是最简单的一种方式，不占用网站的服务器资源，只需要在网站广告位嵌入广告网络提供的广告代码即可。
Google AdSense Google AdSense 是一种获取收入的快速简便的方法，适合于各种规模的网站发布商。它可以在网站的内容网页上展示相关性较高的 Google广告，并且这些广告不会过分夸张醒目。由于这些所展示的广告内容同用户在您的网站上查找的内容相关，因此，最终您的内容网页不仅仅会为您带来很好的经济效益，还能够得以充实网站内容页面。google根据网站上显示的广告被点击的次数支付佣金，当某个月底佣金累计达到100美元时即可向发布商支付广告佣金。
Google AdSense开创了一个新的广告模式吧。以前的很多广告商，主要靠在各种页面，高频率的轰炸网友的眼球，而不管这个网友对广告内容是不是感兴趣。但是AdSense却通过分析网页内容后，提供一些和内容相关的文字广告（也会有个别图片广告），因为内容相关的广告更容易引起读者的兴趣，使广告成为一种真正有用的信息，而且也不会给网友太多的骚扰。
阿里妈妈 阿里妈妈是阿里巴巴集团旗下的网站联盟，将网站主与淘宝卖家之间搭起了一座桥梁，依托自身强大的技术研发能力，对商品实现今精准投放，不断改进投放内容与形式，让双方利益都得到最大化，营造了一个良性循环的生态圈。
百度联盟 百度联盟隶属于全球最大的中文搜索引擎百度。一直致力于帮助合作伙伴挖掘互联网流量的媒体价值，帮助推广客户拓展精准有效的投放通路，是现今国内颇具规模的广告联盟。
使用第三方广告托管系统 使用第三方广告托管系统相对于接入一个广告网络相比还可以展现自身的广告。
百度广告管家 百度广告管家是在线媒体广告管理系统，提供了广告投放管理、收益优化、定向投放、广告托管、广告数据统计报告等功能，几乎涵盖了目前所有网站站长的广告管理需求。登录百度广告管家，看到广告投放管理可以支持对固定、弹窗、漂浮三种类型的广告位投放的管理操作，并支持提供按地域、接入方式、日期、浏览器、浏览器语言、操作系统、来源域、分辨率、被访URL等定向投放方式的管理。广告计费方式提供按日、按展现、按点击三大主流计费方式。
部署开源广告系统 通过部署开源的广告系统可以对广告投放有较大的控制权，但为此需要消耗带宽和服务器成本，以及广告系统二次开发和维护成本。
OpenX OpenX是一个用PHP开发的开源广告管理与跟踪系统，适合各类网站使用，能够管理每个广告主拥有的多种任何尺寸横幅广告，按天查看，详细和概要统计并通过电子邮件发送报表给广告主。
自主开发 大型的互联网公司一般会选择自主开发广告系统与自身业务相结合，如百度，淘宝。也有一些独立的广告联盟或新创的广告公司（如在无线广告领域）会选择自主开发。
广告系统模块 广告投放服务器 广告投放服务器的规模是和流量以及广告数据量成正比的。当广告数据规模较小时，一台服务器的内存就能放下所有数据，如果同时这台服务器也能承担所有广告请求流量，那投放系统就能简化到一台机器；如果一台服务器不能承担所有流量，那么可以复制出同样的多台服务器共同承担广告请求流量，并在这个集群前使用负载均衡设备将流量均匀的分配给集群内的服务器；如果数据量太大以致于单机存不下所有数据，那么可以将广告数据按一定维度分区，存在一组服务器上，这组服务器提供不同分区的访问，对外则通过统一的接口供访问，调用者首先根据分区维度的参数值确定该分区的服务器，再向该服务器直接调用。
随着软硬件的不断升级和优化，现代的普通商用服务器单台每秒可处理几千次的广告请求。在实现上选用高性能的Web服务器，如Nginx或Lighttpd，可以支撑大量并发连接，降低处理每个广告请求的系统消耗。如果对性能的有极端的要求，有些广告系统甚至会自主开发Web服务器（如采用Erlang，C语言等），或裁剪通用开源Web服务器不需要的功能，而只保留核心功能。
K/V内存数据库 广告投放服务器对性能要求非常高，从收到广告请求到返回广告数据只有十几毫秒的时间完成决策和数据封装，而数据在内存中的读取速度相对最快，所以在广告投放服务器中，需要投放的广告数据都会保存在基于K/V的内存数据库中供快速读取。内存数据库和关系数据库中的数据通过消息队列保持同步，开源的K/V数据库有Memcache和Redis等。
关系数据库 广告系统需要采用关系数据库来存储结构化的数据，如：广告计划，推广单元，创意等。这些是至关重要的核心数据，对数据安全性要求很高，要求即使在出现硬件损坏的情况下，客户的数据仍然能保证完整。业界一般采用两种方法存储这些核心数据：采用商业关系数据库如：Oracle，或采用开源数据库如：Mysql或Postgresql。商业数据库功能完善，但价格往往不菲，当广告系统规模变大后，成比例上升的软件成本不可小觑，所以会逐渐转向采用开源的Mysql，其高可用性则通过多个集群及实时复制技术来保证。
在广告系统中对广告数据的管理会通过一个或多个基于Web的应用来实现。通常采用J2EE或LAMP开发框架来开发。随着互联网广告的广泛和深入使用，广告的业务系统功能也越来越多且复杂，从架构上广告业务系统也朝着服务化和开放方向发展。
消息中间件 广告数据在关系数据库的更新需要反应到投放服务器中的内存数据库，从而更新访客看到的广告。一般来说广告主对数据同步的延迟是有一定要求的，现代的广告系统也越来越往实时同步方向发展。
CDN 对于带有图片或视频等富媒体内容的广告创意，为了让访客的浏览器能较快的下载广告内容，需要将这些内容文件放在离访客地理位置较近的服务器上，这正是CDN系统的优势，广告系统往往需要租用或自己搭建CDN系统。
RPC框架 大型广告系统在实现服务化后，需要进行分布式通信的服务器越来越多，采用较好的RPC框架，可使得系统各个模块之间的通信方法标准化, 简化业务开发。
介绍一下Facebook开源的Thrift框架。Thrift是一种高效的、支持多种编程语言的远程服务调用的框架。互联网上比较流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。Thrift则采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。</description></item><item><title>使用Github合作开发项目</title><link>/post/2013/collaborating-development-with-github/</link><pubDate>Wed, 27 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/collaborating-development-with-github/</guid><description>本文大部分内容来自： https://help.github.com/categories/63/articles
Github上合作开发最好的方式是“Fork + Pull Request”。比如我最近需要一个静态Blog生成器，市面上有很多Ruby实现的，但我想要一个Go语言的实现，Github上找到了一个 https://github.com/wendal/gor ，测试了一下已有的功能基本能满足了，就用上了。
但实际使用过程中发现了一个问题，如果在URL中有中文，生成的URL如下没有做URL安全编码：
http://hugozhu.myalert.info/2013/02/27/在Pi和Github上搭建自己的个人博客.html 还有一种情况是如果URL中有空格，如：
http://hugozhu.myalert.info//2013//02/25/Java properties to enviorment variables.html 浏览器遇到这种URL时，会主动进行编码，但这里有两个问题：
遇到中文时，浏览器是用GBK还是UTF-8还是其它字符集编码后再发送给服务器呢？ 遇到空格时，编码成+还是%20呢？ 不同浏览器实现可能不一样，在不同操作系统上也可能不一样（可能和用户设置的缺省语言有关），这样有些用户可能会遭遇404错误了，实际上我在服务器的错误日志上的确看到这样的错误 日志：
2013/02/27 20:41:33 [error] 7791#0: *3285 open() &amp;quot;.../2013/02/25/Java+properties+to+enviorment+variables.html&amp;quot; failed (2: No such file or directory), client: 221.179.193.78, server: hugozhu.myalert.info, request: &amp;quot;GET /2013/02/25/Java+properties+to+enviorment+variables.html HTTP/1.1&amp;quot;, host: &amp;quot;hugozhu.myalert.info&amp;quot; 于是我需要动手修改代码：
首先需要做的就是Fork一下原项目到自己的代码仓库： https://github.com/hugozhu/gor 修改好代码并提交到自己的仓库： https://github.com/hugozhu/gor/commit/db2784623d9df4d0652436efdbfbb9caccdc1e1d 在你的代码仓库页面上点Pull Request: 选择好你刚提交好的Commits，然后点发送; 原项目的维护者就会收到这个Pull Request: https://github.com/wendal/gor/pull/14 如果你提交的代码足够好，维护者可以合并到项目主干上； 记住下一次本地修改代码前要先Merge一下原作者新提交的改动; 如下：
git remote add upstream https://github.com/wendal/gor git fetch upstream git checkout master git merge upstream/master 到此为止就完成了一次合作开发。</description></item><item><title>在Pi和Github上搭建自己的个人博客</title><link>/post/2013/how-to-host-personal-blog-on-github/</link><pubDate>Wed, 27 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/how-to-host-personal-blog-on-github/</guid><description>方法如下： 本站同时托管在家里的Raspberry Pi和Github Pages上，并同步保持更新，海外用户会访问Github，国内用户则会访问Pi，不同线路解析域名hugozhu.myalert.info到不同的服务器是通过DnsPod的服务实现的，这么好的服务还是免费的，这里推荐一下。
因为Github Pages只能支持静态网页，你需要一个能生成静态网页的博客生成引擎。我使用的是gor ， 也可以使用ruhoh，Google一下还有很多。
静态页面博客的好处： 性能是最好的，很合适用Raspberry Pi来做服务器，节省资源； 文章可以用Markdown格式来编写，采用Github来做版本控制，我的Blog仓库在 http://github.com/hugozhu/blog ，数据安全很好，误删除也不担心了； 很容易找到托管环境，方便迁移； 用Gor在Pi上生成速度很快；再用Nginx提供Web服务，可以直接在Pi上写Blog； 大繁至简 Github设置 在你的仓库里增加一个your_github_id.github.com，比如我的github ID是hugozhu，相应的仓库名就是hugozhu.github.com，这个仓库也就是网站的根目录了，在这里放生成好的静态文件 如果你需要用自己的域名，而不是Github提供的，可以在根目录下增加一个CNAME文件,文件内容则是你的域名，在DnsPod上需要建一个CNAME记录，将你的域名指向your_github_id.github.com. 也就是github原来分配给你的，完成这个设置后，访问your_github_id.github.com会跳转到你的域名； 每次更新后，Github会在10分钟内生效。 更新博客 Gor的使用详细说明可见 https://github.com/wendal/gor 我的整个网站的内容也通过Github开源了: https://github.com/hugozhu/blog 以我的网站为例：
git clone https://github.com/hugozhu/blog Cloning into 'blog'... remote: Counting objects: 190, done. remote: Compressing objects: 100% (146/146), done. remote: Total 190 (delta 81), reused 132 (delta 23) Receiving objects: 100% (190/190), 155.48 KiB | 171 KiB/s, done. Resolving deltas: 100% (81/81), done. cd blog gor compile 2013/02/27 13:17:19 gor.</description></item><item><title>动态DNS程序</title><link>/post/2013/dynamic-dns-script/</link><pubDate>Tue, 26 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/dynamic-dns-script/</guid><description>动态根据宽带public ip更新dnspod登记的域名 按照 https://gist.github.com/833369 逻辑重新用Go实现了，用更少的内存开销在Raspberry Pi上跑。
替换上你的Email，密码，域名ID，记录ID等参数，就可以运行了。 会在后台一直运行，每隔30秒检查一遍IP，如果修改了就更新IP。
获得domain_id可以用：
curl curl -k https://dnsapi.cn/Domain.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;quot; 获得record_id：
curl -k https://dnsapi.cn/Record.List -d &amp;quot;login_email=xxx&amp;amp;login_password=xxx&amp;amp;domain_id=xxx&amp;quot;</description></item><item><title>系统调试和分析工具</title><link>/post/2013/linux_perf_tools/</link><pubDate>Tue, 26 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/linux_perf_tools/</guid><description>Linux下的调试和分析工具集</description></item><item><title>将Java的Properties文件转换成环境变量</title><link>/post/2013/java-properties-to-enviorment-variables/</link><pubDate>Mon, 25 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/java-properties-to-enviorment-variables/</guid><description>Overview 在Java程序中使用properties文件很方便，但有时候需要和脚本配合使用时，需要把properties文件内的多个变量转换成环境变量，本文提供一个转换脚本示范：
比如env.properties如下（=附近可以有空格，也可以有空行）
MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk MYSQL_USER = root MYSQL_PASS = 执行下面的脚本后就相当于
export MYSQL_URL=&amp;quot;//localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;quot; export MYSQL_USER=&amp;quot;root&amp;quot; export MYSQL_PASS=&amp;quot;&amp;quot; env.sh脚本代码
#!/bin/bash property_file=env.properties get_prop(){ propfile=$1 key=$2 grep &amp;quot;^${2}=&amp;quot; ${1}| sed &amp;quot;s%${2}=\(.*\)%\1%&amp;quot; } trim() { trimmed=$1 trimmed=${trimmed%% } trimmed=${trimmed## } echo &amp;quot;$trimmed&amp;quot; } `grep -v &amp;quot;^#&amp;quot; $property_file | sed -e '/^$/d' | while read line do key=$(echo $line | awk -F &amp;quot;=&amp;quot; '{print $1}') trimmed_key=$(trim $key) trimmed_val=$(trim $(get_prop $property_file &amp;quot;$key&amp;quot;) echo &amp;quot;export $trimmed_key=\&amp;quot;$trimmed_val\&amp;quot;)&amp;quot; done`</description></item></channel></rss>