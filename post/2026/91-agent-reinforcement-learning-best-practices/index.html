<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Agent强化学习的最佳实践：并行任务处理与性能优化 - Hugo Zhu's Blog</title>
<meta name=description content="从单线程到高性能并发：构建可扩展的AI Agent系统"><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","name":"All about Raspberry Pi","url":"https:\/\/hugozhu.site\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Organization","name":"","url":"https:\/\/hugozhu.site\/"}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https:\/\/hugozhu.site\/","name":"home"}},{"@type":"ListItem","position":3,"item":{"@id":"https:\/\/hugozhu.site\/post\/2026\/91-agent-reinforcement-learning-best-practices\/","name":"Agent强化学习的最佳实践：并行任务处理与性能优化"}}]}</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"Article","author":{"name":""},"headline":"Agent强化学习的最佳实践：并行任务处理与性能优化","description":"在2026年的AI应用场景中，Agent系统已经成为解决复杂任务的核心技术。无论是代码生成助手、自动化运维系统，还是智能客服机器人，如何让Agent高效地处理多个任务并从经验中学习，直接决定了系统的实用性和用户体验。本文将深入探讨Agent强化学习的工程实践，重点解决一个关键问题：如何让Agent并行处理任务以提升性能？\n","inLanguage":"en","wordCount":1901,"datePublished":"2026-01-03T00:00:00\u002b00:00","dateModified":"2026-01-03T00:00:00\u002b00:00","image":"https:\/\/hugozhu.site\/img\/pi.png","keywords":["AI, reinforcement-learning, AI-agents, machine-learning, performance-optimization, parallel-processing, python"],"mainEntityOfPage":"https:\/\/hugozhu.site\/post\/2026\/91-agent-reinforcement-learning-best-practices\/","publisher":{"@type":"Organization","name":"https:\/\/hugozhu.site\/","logo":{"@type":"ImageObject","url":"https:\/\/hugozhu.site\/img\/pi.png","height":60,"width":60}}}</script><meta property="og:title" content="Agent强化学习的最佳实践：并行任务处理与性能优化"><meta property="og:description" content="从单线程到高性能并发：构建可扩展的AI Agent系统"><meta property="og:image" content="https://hugozhu.site/img/pi.png"><meta property="og:url" content="https://hugozhu.site/post/2026/91-agent-reinforcement-learning-best-practices/"><meta property="og:type" content="website"><meta property="og:site_name" content="All about Raspberry Pi"><meta name=twitter:title content="Agent强化学习的最佳实践：并行任务处理与性能优化"><meta name=twitter:description content="从单线程到高性能并发：构建可扩展的AI Agent系统"><meta name=twitter:image content="https://hugozhu.site/img/pi.png"><meta name=twitter:card content="summary_large_image"><link href=https://hugozhu.site/img/pi.ico rel=icon type=image/x-icon><meta name=generator content="Hugo 0.145.0"><link rel=alternate href=https://hugozhu.site/index.xml type=application/rss+xml title="All about Raspberry Pi"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v6.6.0/css/all.css integrity=sha384-h/hnnw1Bi4nbpD6kE7nYfCXzovi622sY5WBxww8ARKwpdLj5kUWjRuyiXaD1U2JT crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css integrity=sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu crossorigin=anonymous><link rel=stylesheet href=https://hugozhu.site/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><link rel=stylesheet href=https://hugozhu.site/css/highlight.min.css><link rel=stylesheet href=https://hugozhu.site/css/codeblock.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css integrity=sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css integrity=sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R crossorigin=anonymous><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-W88HDMN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","GTM-W88HDMN")}</script></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class=container-fluid><div class=navbar-header><button type=button class=navbar-toggle data-toggle=collapse data-target=#main-navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=https://hugozhu.site/>All about Raspberry Pi</a></div><div class="collapse navbar-collapse" id=main-navbar><ul class="nav navbar-nav navbar-right"><li><a title=Blog href=/>Blog</a></li><li class=navlinks-container><a class=navlinks-parent role=button tabindex=0>Tools</a><div class=navlinks-children><a href=https://nddapp.com/json-encoder.html>HTML Tools</a>
<a href=https://www.birme.net/>Imaeg Resizing</a>
<a href=https://jwt.io/>JWT Token Tool</a></div></li><li><a title=About href=/page/about/>About</a></li><li><a title=Tags href=/tags>Tags</a></li><li><a href=#modalSearch data-toggle=modal data-target=#modalSearch style=outline:none><span class="hidden-sm hidden-md hidden-lg">Search</span> <span id=searchGlyph class="glyphicon glyphicon-search"></span></a></li></ul></div><div class=avatar-container><div class=avatar-img-border><a title="All about Raspberry Pi" href=https://hugozhu.site/><img class=avatar-img src=https://hugozhu.site/img/pi.png alt="All about Raspberry Pi"></a></div></div></div></nav><div id=modalSearch class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><button type=button class=close data-dismiss=modal>&#215;</button><h4 class=modal-title>Search All about Raspberry Pi</h4></div><div class=modal-body><gcse:search></gcse:search></div><div class=modal-footer><button type=button class="btn btn-default" data-dismiss=modal>Close</button></div></div></div></div><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header class=header-section><div class="intro-header no-img"><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><h1>Agent强化学习的最佳实践：并行任务处理与性能优化</h1><h2 class=post-subheading>从单线程到高性能并发：构建可扩展的AI Agent系统</h2><span class=post-meta><i class="fas fa-calendar"></i>&nbsp;Posted on January 3, 2026
&nbsp;|&nbsp;<i class="fas fa-clock"></i>&nbsp;9&nbsp;minutes
&nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;1901&nbsp;words</span></div></div></div></div></div></header><div class=container role=main><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role=main class=blog-post><h4><i>目录:</i></h4><nav id=TableOfContents><ul><li><a href=#为什么agent需要并行处理能力>为什么Agent需要并行处理能力？</a></li><li><a href=#核心概念agent的任务并行架构>核心概念：Agent的任务并行架构</a><ul><li><a href=#1-任务级并行-vs-推理级并行>1. 任务级并行 vs 推理级并行</a></li><li><a href=#2-异步agent架构设计>2. 异步Agent架构设计</a></li></ul></li><li><a href=#实践1基于asyncio的并行agent实现>实践1：基于asyncio的并行Agent实现</a></li><li><a href=#实践2智能任务调度与优先级管理>实践2：智能任务调度与优先级管理</a></li><li><a href=#实践3强化学习优化任务调度策略>实践3：强化学习优化任务调度策略</a><ul><li><a href=#强化学习框架集成>强化学习框架集成</a></li><li><a href=#强化学习带来的性能提升>强化学习带来的性能提升</a></li></ul></li><li><a href=#实践4分布式agent集群>实践4：分布式Agent集群</a></li><li><a href=#性能优化技巧总结>性能优化技巧总结</a><ul><li><a href=#1-批处理batching>1. 批处理（Batching）</a></li><li><a href=#2-缓存caching>2. 缓存（Caching）</a></li><li><a href=#3-推测执行speculative-execution>3. 推测执行（Speculative Execution）</a></li><li><a href=#4-模型选择策略>4. 模型选择策略</a></li></ul></li><li><a href=#监控与调试>监控与调试</a></li><li><a href=#未来展望>未来展望</a></li><li><a href=#总结>总结</a></li></ul></nav><p>在2026年的AI应用场景中，Agent系统已经成为解决复杂任务的核心技术。无论是代码生成助手、自动化运维系统，还是智能客服机器人，如何让Agent高效地处理多个任务并从经验中学习，直接决定了系统的实用性和用户体验。本文将深入探讨Agent强化学习的工程实践，重点解决一个关键问题：<strong>如何让Agent并行处理任务以提升性能？</strong></p><h2 id=为什么agent需要并行处理能力>为什么Agent需要并行处理能力？</h2><p>传统的单线程Agent面临三大性能瓶颈：</p><ol><li><strong>I/O等待时间</strong>：Agent调用LLM API、数据库查询、文件操作时，大量时间浪费在等待响应上</li><li><strong>任务队列堆积</strong>：当用户请求量增加时，串行处理导致响应时间线性增长</li><li><strong>资源利用率低</strong>：现代服务器拥有多核CPU和高并发I/O能力，单线程Agent无法充分利用</li></ol><p>一个真实案例：某代码审查Agent在串行模式下处理10个Pull Request需要5分钟，而通过并行优化后可以降低到45秒——性能提升超过6倍。</p><h2 id=核心概念agent的任务并行架构>核心概念：Agent的任务并行架构</h2><h3 id=1-任务级并行-vs-推理级并行>1. 任务级并行 vs 推理级并行</h3><p>在设计并行Agent时，首先要区分两种并行策略：</p><p><strong>任务级并行</strong>（Task-level Parallelism）：</p><ul><li>同时处理多个独立的用户请求或子任务</li><li>适用于：批量数据处理、多用户服务、工作流拆分</li><li>关键挑战：任务调度、状态隔离、结果聚合</li></ul><p><strong>推理级并行</strong>（Inference-level Parallelism）：</p><ul><li>在单个任务内部并行化推理步骤</li><li>适用于：工具调用、多模型集成、Monte Carlo树搜索</li><li>关键挑战：依赖管理、计算图优化、内存控制</li></ul><p>本文重点讨论任务级并行，因为这是提升Agent系统吞吐量的最直接方式。</p><h3 id=2-异步agent架构设计>2. 异步Agent架构设计</h3><p>一个高性能的并行Agent系统通常采用以下架构：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────────┐
</span></span><span class=line><span class=cl>│ Task Queue  │  ← 用户请求进入队列
</span></span><span class=line><span class=cl>└──────┬──────┘
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       ▼
</span></span><span class=line><span class=cl>┌─────────────────────────────┐
</span></span><span class=line><span class=cl>│   Task Scheduler            │  ← 智能调度器
</span></span><span class=line><span class=cl>│   - Priority Management     │
</span></span><span class=line><span class=cl>│   - Load Balancing          │
</span></span><span class=line><span class=cl>│   - Dependency Resolution   │
</span></span><span class=line><span class=cl>└──────┬──────────────────────┘
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       ▼
</span></span><span class=line><span class=cl>┌──────────────────────────────────────┐
</span></span><span class=line><span class=cl>│     Agent Worker Pool                │
</span></span><span class=line><span class=cl>│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐   │
</span></span><span class=line><span class=cl>│  │ W1  │ │ W2  │ │ W3  │ │ W4  │   │ ← 并发Worker
</span></span><span class=line><span class=cl>│  └─────┘ └─────┘ └─────┘ └─────┘   │
</span></span><span class=line><span class=cl>└──────┬───────────────────────────────┘
</span></span><span class=line><span class=cl>       │
</span></span><span class=line><span class=cl>       ▼
</span></span><span class=line><span class=cl>┌─────────────────────────────┐
</span></span><span class=line><span class=cl>│   Shared Context Store      │  ← 共享上下文和学习经验
</span></span><span class=line><span class=cl>│   - Vector Database         │
</span></span><span class=line><span class=cl>│   - Experience Replay Buffer│
</span></span><span class=line><span class=cl>└─────────────────────────────┘
</span></span></code></pre></div><h2 id=实践1基于asyncio的并行agent实现>实践1：基于asyncio的并行Agent实现</h2><p>让我们从一个简单但完整的例子开始，展示如何使用Python的asyncio构建并行Agent：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>List</span><span class=p>,</span> <span class=n>Dict</span><span class=p>,</span> <span class=n>Any</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>dataclasses</span> <span class=kn>import</span> <span class=n>dataclass</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>enum</span> <span class=kn>import</span> <span class=n>Enum</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TaskStatus</span><span class=p>(</span><span class=n>Enum</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>PENDING</span> <span class=o>=</span> <span class=s2>&#34;pending&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>RUNNING</span> <span class=o>=</span> <span class=s2>&#34;running&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>COMPLETED</span> <span class=o>=</span> <span class=s2>&#34;completed&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>FAILED</span> <span class=o>=</span> <span class=s2>&#34;failed&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@dataclass</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AgentTask</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Agent任务定义&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>task_id</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>prompt</span><span class=p>:</span> <span class=nb>str</span>
</span></span><span class=line><span class=cl>    <span class=n>priority</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>:</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span><span class=p>:</span> <span class=n>TaskStatus</span> <span class=o>=</span> <span class=n>TaskStatus</span><span class=o>.</span><span class=n>PENDING</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span><span class=p>:</span> <span class=n>Any</span> <span class=o>=</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ParallelAgent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;支持并行任务处理的Agent实现&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>max_concurrent_tasks</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>max_concurrent_tasks</span> <span class=o>=</span> <span class=n>max_concurrent_tasks</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>task_queue</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>Queue</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>active_tasks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>results</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 模拟的经验回放缓冲区（用于强化学习）</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>experience_buffer</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>process_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Any</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        处理单个任务的核心逻辑
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        在真实场景中，这里会调用LLM API、执行工具、搜索知识库等
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>task</span><span class=o>.</span><span class=n>status</span> <span class=o>=</span> <span class=n>TaskStatus</span><span class=o>.</span><span class=n>RUNNING</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 模拟LLM推理延迟（实际应该是await llm_client.generate()）</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mf>1.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 模拟任务处理</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;Processed: </span><span class=si>{</span><span class=n>task</span><span class=o>.</span><span class=n>prompt</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 记录经验用于后续学习</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_record_experience</span><span class=p>(</span><span class=n>task</span><span class=p>,</span> <span class=n>result</span><span class=p>,</span> <span class=n>reward</span><span class=o>=</span><span class=mf>1.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>task</span><span class=o>.</span><span class=n>status</span> <span class=o>=</span> <span class=n>TaskStatus</span><span class=o>.</span><span class=n>COMPLETED</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span><span class=o>.</span><span class=n>result</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span><span class=o>.</span><span class=n>status</span> <span class=o>=</span> <span class=n>TaskStatus</span><span class=o>.</span><span class=n>FAILED</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span><span class=o>.</span><span class=n>result</span> <span class=o>=</span> <span class=nb>str</span><span class=p>(</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_record_experience</span><span class=p>(</span><span class=n>task</span><span class=p>,</span> <span class=kc>None</span><span class=p>,</span> <span class=n>reward</span><span class=o>=-</span><span class=mf>1.0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_record_experience</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>,</span> <span class=n>result</span><span class=p>:</span> <span class=n>Any</span><span class=p>,</span> <span class=n>reward</span><span class=p>:</span> <span class=nb>float</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;记录任务执行经验用于强化学习&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>experience</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;state&#39;</span><span class=p>:</span> <span class=n>task</span><span class=o>.</span><span class=n>context</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;action&#39;</span><span class=p>:</span> <span class=n>task</span><span class=o>.</span><span class=n>prompt</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;reward&#39;</span><span class=p>:</span> <span class=n>reward</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;next_state&#39;</span><span class=p>:</span> <span class=n>result</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;timestamp&#39;</span><span class=p>:</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>experience_buffer</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>experience</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 保持缓冲区大小</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>experience_buffer</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>10000</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>experience_buffer</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>worker</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;工作协程，持续从队列获取任务并处理&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span> <span class=o>=</span> <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>task_queue</span><span class=o>.</span><span class=n>get</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>task</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>  <span class=c1># 停止信号</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>process_task</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>results</span><span class=p>[</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>]</span> <span class=o>=</span> <span class=n>task</span><span class=o>.</span><span class=n>result</span>
</span></span><span class=line><span class=cl>            <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Task </span><span class=si>{</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=si>}</span><span class=s2> failed: </span><span class=si>{</span><span class=n>e</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>active_tasks</span><span class=o>.</span><span class=n>discard</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>task_queue</span><span class=o>.</span><span class=n>task_done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>submit_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;提交任务到队列&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>active_tasks</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>task_queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>run</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>AgentTask</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        运行Agent处理所有任务
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            tasks: 待处理的任务列表
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        Returns:
</span></span></span><span class=line><span class=cl><span class=s2>            任务ID到结果的映射
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 创建worker池</span>
</span></span><span class=line><span class=cl>        <span class=n>workers</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>worker</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>max_concurrent_tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 提交所有任务</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>task</span> <span class=ow>in</span> <span class=n>tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>submit_task</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 等待所有任务完成</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>task_queue</span><span class=o>.</span><span class=n>join</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 停止workers</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=n>workers</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>task_queue</span><span class=o>.</span><span class=n>put</span><span class=p>(</span><span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=o>*</span><span class=n>workers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>results</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用示例</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 创建并行Agent</span>
</span></span><span class=line><span class=cl>    <span class=n>agent</span> <span class=o>=</span> <span class=n>ParallelAgent</span><span class=p>(</span><span class=n>max_concurrent_tasks</span><span class=o>=</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 准备10个任务</span>
</span></span><span class=line><span class=cl>    <span class=n>tasks</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=n>AgentTask</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>task_id</span><span class=o>=</span><span class=sa>f</span><span class=s2>&#34;task_</span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>prompt</span><span class=o>=</span><span class=sa>f</span><span class=s2>&#34;Analyze code file </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>context</span><span class=o>=</span><span class=p>{</span><span class=s2>&#34;file_id&#34;</span><span class=p>:</span> <span class=n>i</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 执行并计时</span>
</span></span><span class=line><span class=cl>    <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span> <span class=o>=</span> <span class=k>await</span> <span class=n>agent</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>elapsed_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Processed </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>results</span><span class=p>)</span><span class=si>}</span><span class=s2> tasks in </span><span class=si>{</span><span class=n>elapsed_time</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2> seconds&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Average time per task: </span><span class=si>{</span><span class=n>elapsed_time</span><span class=o>/</span><span class=nb>len</span><span class=p>(</span><span class=n>results</span><span class=p>)</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2> seconds&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Experience buffer size: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>agent</span><span class=o>.</span><span class=n>experience_buffer</span><span class=p>)</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 运行</span>
</span></span><span class=line><span class=cl><span class=c1># asyncio.run(main())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><p><strong>性能对比</strong>：</p><ul><li>串行处理10个任务：10秒（每个1秒）</li><li>并行处理（5个worker）：2秒（两批并行）</li><li><strong>性能提升：5倍</strong></li></ul><h2 id=实践2智能任务调度与优先级管理>实践2：智能任务调度与优先级管理</h2><p>在真实场景中，任务之间往往有优先级差异和依赖关系。简单的FIFO队列无法满足需求，我们需要更智能的调度器：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>Optional</span><span class=p>,</span> <span class=n>Set</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>defaultdict</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TaskScheduler</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    智能任务调度器
</span></span></span><span class=line><span class=cl><span class=s2>    - 支持优先级调度
</span></span></span><span class=line><span class=cl><span class=s2>    - 处理任务依赖关系
</span></span></span><span class=line><span class=cl><span class=s2>    - 动态负载均衡
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>priority_queue</span> <span class=o>=</span> <span class=p>[]</span>  <span class=c1># 优先级队列（最小堆）</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>task_counter</span> <span class=o>=</span> <span class=mi>0</span>  <span class=c1># 用于打破优先级相同时的tie</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 任务依赖图</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>  <span class=c1># task_id -&gt; set of dependencies</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>dependents</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>set</span><span class=p>)</span>    <span class=c1># task_id -&gt; set of dependents</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 已完成任务集合</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>completed_tasks</span> <span class=o>=</span> <span class=nb>set</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>add_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>,</span> <span class=n>depends_on</span><span class=p>:</span> <span class=n>Optional</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>None</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        添加任务到调度器
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            task: Agent任务
</span></span></span><span class=line><span class=cl><span class=s2>            depends_on: 依赖的任务ID列表
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>depends_on</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=p>[</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>]</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>depends_on</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>dep_id</span> <span class=ow>in</span> <span class=n>depends_on</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>dependents</span><span class=p>[</span><span class=n>dep_id</span><span class=p>]</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 如果没有未完成的依赖，立即加入优先级队列</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_can_schedule</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>_enqueue</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_can_schedule</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;检查任务是否可以调度（所有依赖都已完成）&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>deps</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>task_id</span><span class=p>,</span> <span class=nb>set</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>deps</span><span class=o>.</span><span class=n>issubset</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>completed_tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_enqueue</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;将任务加入优先级队列&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 使用负优先级实现最大堆（Python heapq是最小堆）</span>
</span></span><span class=line><span class=cl>        <span class=c1># task_counter确保相同优先级的任务按FIFO顺序</span>
</span></span><span class=line><span class=cl>        <span class=n>heapq</span><span class=o>.</span><span class=n>heappush</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>priority_queue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=p>(</span><span class=o>-</span><span class=n>task</span><span class=o>.</span><span class=n>priority</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>task_counter</span><span class=p>,</span> <span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>task_counter</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_next_task</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Optional</span><span class=p>[</span><span class=n>AgentTask</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;获取下一个应该执行的任务&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=ow>not</span> <span class=bp>self</span><span class=o>.</span><span class=n>priority_queue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>_</span><span class=p>,</span> <span class=n>_</span><span class=p>,</span> <span class=n>task</span> <span class=o>=</span> <span class=n>heapq</span><span class=o>.</span><span class=n>heappop</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>priority_queue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>task</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>mark_completed</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task_id</span><span class=p>:</span> <span class=nb>str</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        标记任务完成，并检查是否可以解锁依赖任务
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        这是强化学习中的关键步骤：完成一个任务后，
</span></span></span><span class=line><span class=cl><span class=s2>        评估哪些后续任务可以被触发
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>completed_tasks</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>task_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 查找所有依赖此任务的任务</span>
</span></span><span class=line><span class=cl>        <span class=n>newly_ready</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>dependent_id</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>dependents</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>task_id</span><span class=p>,</span> <span class=nb>set</span><span class=p>()):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>_can_schedule</span><span class=p>(</span><span class=n>dependent_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>newly_ready</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>dependent_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>newly_ready</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>get_metrics</span><span class=p>(</span><span class=bp>self</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;获取调度器性能指标&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;pending_tasks&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>priority_queue</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;completed_tasks&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>completed_tasks</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;dependency_chains&#39;</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>dependencies</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用示例：处理有依赖关系的任务</span>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>example_with_dependencies</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span> <span class=o>=</span> <span class=n>TaskScheduler</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>agent</span> <span class=o>=</span> <span class=n>ParallelAgent</span><span class=p>(</span><span class=n>max_concurrent_tasks</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 任务DAG：</span>
</span></span><span class=line><span class=cl>    <span class=c1># task_1 → task_3 → task_5</span>
</span></span><span class=line><span class=cl>    <span class=c1># task_2 → task_4 → task_5</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tasks</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;task_1&#39;</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>(</span><span class=s1>&#39;task_1&#39;</span><span class=p>,</span> <span class=s1>&#39;Read file A&#39;</span><span class=p>,</span> <span class=n>priority</span><span class=o>=</span><span class=mi>10</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;task_2&#39;</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>(</span><span class=s1>&#39;task_2&#39;</span><span class=p>,</span> <span class=s1>&#39;Read file B&#39;</span><span class=p>,</span> <span class=n>priority</span><span class=o>=</span><span class=mi>10</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;task_3&#39;</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>(</span><span class=s1>&#39;task_3&#39;</span><span class=p>,</span> <span class=s1>&#39;Analyze A&#39;</span><span class=p>,</span> <span class=n>priority</span><span class=o>=</span><span class=mi>5</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;task_4&#39;</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>(</span><span class=s1>&#39;task_4&#39;</span><span class=p>,</span> <span class=s1>&#39;Analyze B&#39;</span><span class=p>,</span> <span class=n>priority</span><span class=o>=</span><span class=mi>5</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;task_5&#39;</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>(</span><span class=s1>&#39;task_5&#39;</span><span class=p>,</span> <span class=s1>&#39;Merge results&#39;</span><span class=p>,</span> <span class=n>priority</span><span class=o>=</span><span class=mi>1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 添加任务及其依赖关系</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=n>tasks</span><span class=p>[</span><span class=s1>&#39;task_1&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=n>tasks</span><span class=p>[</span><span class=s1>&#39;task_2&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=n>tasks</span><span class=p>[</span><span class=s1>&#39;task_3&#39;</span><span class=p>],</span> <span class=n>depends_on</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;task_1&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=n>tasks</span><span class=p>[</span><span class=s1>&#39;task_4&#39;</span><span class=p>],</span> <span class=n>depends_on</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;task_2&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>scheduler</span><span class=o>.</span><span class=n>add_task</span><span class=p>(</span><span class=n>tasks</span><span class=p>[</span><span class=s1>&#39;task_5&#39;</span><span class=p>],</span> <span class=n>depends_on</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;task_3&#39;</span><span class=p>,</span> <span class=s1>&#39;task_4&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 执行任务（带依赖解析）</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>task</span> <span class=o>=</span> <span class=n>scheduler</span><span class=o>.</span><span class=n>get_next_task</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>task</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>agent</span><span class=o>.</span><span class=n>process_task</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 标记完成并解锁依赖任务</span>
</span></span><span class=line><span class=cl>        <span class=n>newly_ready_ids</span> <span class=o>=</span> <span class=n>scheduler</span><span class=o>.</span><span class=n>mark_completed</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>task_id</span> <span class=ow>in</span> <span class=n>newly_ready_ids</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>scheduler</span><span class=o>.</span><span class=n>_enqueue</span><span class=p>(</span><span class=n>tasks</span><span class=p>[</span><span class=n>task_id</span><span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>scheduler</span><span class=o>.</span><span class=n>get_metrics</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><p><strong>调度策略的关键点</strong>：</p><ol><li><strong>优先级倒置问题</strong>：高优先级任务依赖低优先级任务时，需要动态提升低优先级任务的优先级</li><li><strong>死锁检测</strong>：循环依赖会导致所有任务无法调度，需要在添加任务时检测</li><li><strong>资源感知调度</strong>：不同任务消耗的内存、GPU资源不同，调度器应该考虑资源约束</li></ol><h2 id=实践3强化学习优化任务调度策略>实践3：强化学习优化任务调度策略</h2><p>前面我们实现了基本的并行处理和静态调度，但真正的"强化学习"体现在Agent能从历史经验中学习更优的调度策略。</p><h3 id=强化学习框架集成>强化学习框架集成</h3><p>我们可以将任务调度问题建模为马尔可夫决策过程（MDP）：</p><ul><li><strong>状态（State）</strong>：当前任务队列状态、系统负载、历史完成时间统计</li><li><strong>动作（Action）</strong>：选择下一个要执行的任务</li><li><strong>奖励（Reward）</strong>：负的任务完成时间 + 用户满意度评分</li><li><strong>策略（Policy）</strong>：从状态到动作的映射，由神经网络学习</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch.nn</span> <span class=k>as</span> <span class=nn>nn</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>torch.optim</span> <span class=k>as</span> <span class=nn>optim</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>collections</span> <span class=kn>import</span> <span class=n>deque</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SchedulerStateEncoder</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;将调度器状态编码为向量&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@staticmethod</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>encode</span><span class=p>(</span><span class=n>scheduler</span><span class=p>:</span> <span class=n>TaskScheduler</span><span class=p>,</span> <span class=n>system_metrics</span><span class=p>:</span> <span class=n>Dict</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        编码当前调度器状态
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        返回特征向量：
</span></span></span><span class=line><span class=cl><span class=s2>        - 队列长度
</span></span></span><span class=line><span class=cl><span class=s2>        - 平均任务优先级
</span></span></span><span class=line><span class=cl><span class=s2>        - 系统CPU/内存使用率
</span></span></span><span class=line><span class=cl><span class=s2>        - 最近10个任务的平均完成时间
</span></span></span><span class=line><span class=cl><span class=s2>        - 待处理依赖关系数量
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>metrics</span> <span class=o>=</span> <span class=n>scheduler</span><span class=o>.</span><span class=n>get_metrics</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>features</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>metrics</span><span class=p>[</span><span class=s1>&#39;pending_tasks&#39;</span><span class=p>]</span> <span class=o>/</span> <span class=mf>100.0</span><span class=p>,</span>  <span class=c1># 归一化</span>
</span></span><span class=line><span class=cl>            <span class=n>metrics</span><span class=p>[</span><span class=s1>&#39;completed_tasks&#39;</span><span class=p>]</span> <span class=o>/</span> <span class=mf>1000.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>metrics</span><span class=p>[</span><span class=s1>&#39;dependency_chains&#39;</span><span class=p>]</span> <span class=o>/</span> <span class=mf>50.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>system_metrics</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;cpu_usage&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>/</span> <span class=mf>100.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>system_metrics</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;memory_usage&#39;</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>/</span> <span class=mf>100.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>system_metrics</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;avg_completion_time&#39;</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>)</span> <span class=o>/</span> <span class=mf>10.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>features</span><span class=p>,</span> <span class=n>dtype</span><span class=o>=</span><span class=n>np</span><span class=o>.</span><span class=n>float32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DQNSchedulerPolicy</span><span class=p>(</span><span class=n>nn</span><span class=o>.</span><span class=n>Module</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    使用DQN学习任务调度策略
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    输入：调度器状态向量
</span></span></span><span class=line><span class=cl><span class=s2>    输出：每个候选任务的Q值
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state_dim</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>action_dim</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>hidden_dim</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>128</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>network</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>Sequential</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>state_dim</span><span class=p>,</span> <span class=n>hidden_dim</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>hidden_dim</span><span class=p>,</span> <span class=n>hidden_dim</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=n>nn</span><span class=o>.</span><span class=n>ReLU</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>            <span class=n>nn</span><span class=o>.</span><span class=n>Linear</span><span class=p>(</span><span class=n>hidden_dim</span><span class=p>,</span> <span class=n>action_dim</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>forward</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>state</span><span class=p>:</span> <span class=n>torch</span><span class=o>.</span><span class=n>Tensor</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>torch</span><span class=o>.</span><span class=n>Tensor</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        前向传播：给定状态，输出所有动作的Q值
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        Args:
</span></span></span><span class=line><span class=cl><span class=s2>            state: 状态向量 [batch_size, state_dim]
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        Returns:
</span></span></span><span class=line><span class=cl><span class=s2>            Q值向量 [batch_size, action_dim]
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>network</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>RLScheduler</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    基于强化学习的自适应任务调度器
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    通过在线学习不断优化调度策略，降低平均任务完成时间
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>state_dim</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>6</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>max_tasks</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>learning_rate</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.001</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>gamma</span><span class=p>:</span> <span class=nb>float</span> <span class=o>=</span> <span class=mf>0.99</span>
</span></span><span class=line><span class=cl>    <span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state_dim</span> <span class=o>=</span> <span class=n>state_dim</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>action_dim</span> <span class=o>=</span> <span class=n>max_tasks</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Q网络（主网络和目标网络）</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>q_network</span> <span class=o>=</span> <span class=n>DQNSchedulerPolicy</span><span class=p>(</span><span class=n>state_dim</span><span class=p>,</span> <span class=n>max_tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>target_network</span> <span class=o>=</span> <span class=n>DQNSchedulerPolicy</span><span class=p>(</span><span class=n>state_dim</span><span class=p>,</span> <span class=n>max_tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>target_network</span><span class=o>.</span><span class=n>load_state_dict</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>q_network</span><span class=o>.</span><span class=n>state_dict</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>optimizer</span> <span class=o>=</span> <span class=n>optim</span><span class=o>.</span><span class=n>Adam</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>q_network</span><span class=o>.</span><span class=n>parameters</span><span class=p>(),</span> <span class=n>lr</span><span class=o>=</span><span class=n>learning_rate</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>gamma</span> <span class=o>=</span> <span class=n>gamma</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 经验回放缓冲区</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>replay_buffer</span> <span class=o>=</span> <span class=n>deque</span><span class=p>(</span><span class=n>maxlen</span><span class=o>=</span><span class=mi>10000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>batch_size</span> <span class=o>=</span> <span class=mi>64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># ε-greedy探索策略</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>epsilon</span> <span class=o>=</span> <span class=mf>1.0</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>epsilon_decay</span> <span class=o>=</span> <span class=mf>0.995</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>epsilon_min</span> <span class=o>=</span> <span class=mf>0.01</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>select_action</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>available_tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>AgentTask</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        根据当前状态选择任务（动作）
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        使用ε-greedy策略平衡探索与利用
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>()</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>epsilon</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 探索：随机选择</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>available_tasks</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 利用：选择Q值最高的动作</span>
</span></span><span class=line><span class=cl>            <span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>no_grad</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=n>state_tensor</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>FloatTensor</span><span class=p>(</span><span class=n>state</span><span class=p>)</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>q_values</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>q_network</span><span class=p>(</span><span class=n>state_tensor</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 只考虑可用任务的Q值</span>
</span></span><span class=line><span class=cl>                <span class=n>valid_q_values</span> <span class=o>=</span> <span class=n>q_values</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=n>available_tasks</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>torch</span><span class=o>.</span><span class=n>argmax</span><span class=p>(</span><span class=n>valid_q_values</span><span class=p>)</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>store_experience</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>action</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>reward</span><span class=p>:</span> <span class=nb>float</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>next_state</span><span class=p>:</span> <span class=n>np</span><span class=o>.</span><span class=n>ndarray</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>done</span><span class=p>:</span> <span class=nb>bool</span>
</span></span><span class=line><span class=cl>    <span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;存储经验到回放缓冲区&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>replay_buffer</span><span class=o>.</span><span class=n>append</span><span class=p>((</span><span class=n>state</span><span class=p>,</span> <span class=n>action</span><span class=p>,</span> <span class=n>reward</span><span class=p>,</span> <span class=n>next_state</span><span class=p>,</span> <span class=n>done</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>train_step</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;执行一次训练步骤&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>replay_buffer</span><span class=p>)</span> <span class=o>&lt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>batch_size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 从经验回放缓冲区采样</span>
</span></span><span class=line><span class=cl>        <span class=n>batch</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>replay_buffer</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>batch_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>states</span><span class=p>,</span> <span class=n>actions</span><span class=p>,</span> <span class=n>rewards</span><span class=p>,</span> <span class=n>next_states</span><span class=p>,</span> <span class=n>dones</span> <span class=o>=</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>batch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>states</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>FloatTensor</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>states</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>actions</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>LongTensor</span><span class=p>(</span><span class=n>actions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>rewards</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>FloatTensor</span><span class=p>(</span><span class=n>rewards</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>next_states</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>FloatTensor</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>array</span><span class=p>(</span><span class=n>next_states</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>dones</span> <span class=o>=</span> <span class=n>torch</span><span class=o>.</span><span class=n>FloatTensor</span><span class=p>(</span><span class=n>dones</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 计算当前Q值</span>
</span></span><span class=line><span class=cl>        <span class=n>current_q_values</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>q_network</span><span class=p>(</span><span class=n>states</span><span class=p>)</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>actions</span><span class=o>.</span><span class=n>unsqueeze</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 计算目标Q值（使用目标网络）</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>torch</span><span class=o>.</span><span class=n>no_grad</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>next_q_values</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>target_network</span><span class=p>(</span><span class=n>next_states</span><span class=p>)</span><span class=o>.</span><span class=n>max</span><span class=p>(</span><span class=mi>1</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>target_q_values</span> <span class=o>=</span> <span class=n>rewards</span> <span class=o>+</span> <span class=p>(</span><span class=mi>1</span> <span class=o>-</span> <span class=n>dones</span><span class=p>)</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>gamma</span> <span class=o>*</span> <span class=n>next_q_values</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 计算损失并反向传播</span>
</span></span><span class=line><span class=cl>        <span class=n>loss</span> <span class=o>=</span> <span class=n>nn</span><span class=o>.</span><span class=n>MSELoss</span><span class=p>()(</span><span class=n>current_q_values</span><span class=o>.</span><span class=n>squeeze</span><span class=p>(),</span> <span class=n>target_q_values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>optimizer</span><span class=o>.</span><span class=n>zero_grad</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>loss</span><span class=o>.</span><span class=n>backward</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>optimizer</span><span class=o>.</span><span class=n>step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 衰减探索率</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>epsilon</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>epsilon_min</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>epsilon</span> <span class=o>*</span> <span class=bp>self</span><span class=o>.</span><span class=n>epsilon_decay</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>loss</span><span class=o>.</span><span class=n>item</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>update_target_network</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;定期更新目标网络&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>target_network</span><span class=o>.</span><span class=n>load_state_dict</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>q_network</span><span class=o>.</span><span class=n>state_dict</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 集成到Agent系统</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>RLEnhancedAgent</span><span class=p>(</span><span class=n>ParallelAgent</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;集成强化学习调度策略的Agent&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>max_concurrent_tasks</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>5</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>max_concurrent_tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>rl_scheduler</span> <span class=o>=</span> <span class=n>RLScheduler</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>state_encoder</span> <span class=o>=</span> <span class=n>SchedulerStateEncoder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 性能指标追踪</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>episode_rewards</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>episode_completion_times</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>run_with_rl</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>AgentTask</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        使用强化学习调度策略运行Agent
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        在执行过程中在线学习最优调度策略
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>pending_tasks</span> <span class=o>=</span> <span class=n>tasks</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>completed_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>episode_start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>pending_tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 编码当前状态</span>
</span></span><span class=line><span class=cl>            <span class=n>system_metrics</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;cpu_usage&#39;</span><span class=p>:</span> <span class=mf>50.0</span><span class=p>,</span>  <span class=c1># 实际应从系统获取</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;memory_usage&#39;</span><span class=p>:</span> <span class=mf>60.0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s1>&#39;avg_completion_time&#39;</span><span class=p>:</span> <span class=mf>2.0</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>state</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>state_encoder</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>scheduler</span><span class=p>,</span> <span class=n>system_metrics</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 使用RL策略选择下一个任务</span>
</span></span><span class=line><span class=cl>            <span class=n>action</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>rl_scheduler</span><span class=o>.</span><span class=n>select_action</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>pending_tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>selected_task</span> <span class=o>=</span> <span class=n>pending_tasks</span><span class=p>[</span><span class=n>action</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 执行任务</span>
</span></span><span class=line><span class=cl>            <span class=n>task_start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>process_task</span><span class=p>(</span><span class=n>selected_task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>task_completion_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>task_start_time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 计算奖励（负完成时间，鼓励快速完成）</span>
</span></span><span class=line><span class=cl>            <span class=n>reward</span> <span class=o>=</span> <span class=o>-</span><span class=n>task_completion_time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 移除已完成任务</span>
</span></span><span class=line><span class=cl>            <span class=n>pending_tasks</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>completed_count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 编码下一个状态</span>
</span></span><span class=line><span class=cl>            <span class=n>next_system_metrics</span> <span class=o>=</span> <span class=n>system_metrics</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=n>next_system_metrics</span><span class=p>[</span><span class=s1>&#39;avg_completion_time&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=n>task_completion_time</span>
</span></span><span class=line><span class=cl>            <span class=n>next_state</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>state_encoder</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>scheduler</span><span class=p>,</span> <span class=n>next_system_metrics</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 存储经验</span>
</span></span><span class=line><span class=cl>            <span class=n>done</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>pending_tasks</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>rl_scheduler</span><span class=o>.</span><span class=n>store_experience</span><span class=p>(</span><span class=n>state</span><span class=p>,</span> <span class=n>action</span><span class=p>,</span> <span class=n>reward</span><span class=p>,</span> <span class=n>next_state</span><span class=p>,</span> <span class=n>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 训练RL模型</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>completed_count</span> <span class=o>%</span> <span class=mi>10</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>loss</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>rl_scheduler</span><span class=o>.</span><span class=n>train_step</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>loss</span> <span class=ow>is</span> <span class=ow>not</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Training loss: </span><span class=si>{</span><span class=n>loss</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2>, epsilon: </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>rl_scheduler</span><span class=o>.</span><span class=n>epsilon</span><span class=si>:</span><span class=s2>.3f</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># 定期更新目标网络</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>completed_count</span> <span class=o>%</span> <span class=mi>100</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=bp>self</span><span class=o>.</span><span class=n>rl_scheduler</span><span class=o>.</span><span class=n>update_target_network</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>episode_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>episode_start_time</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>episode_completion_times</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>episode_time</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;completed_tasks&#39;</span><span class=p>:</span> <span class=n>completed_count</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;total_time&#39;</span><span class=p>:</span> <span class=n>episode_time</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;avg_time_per_task&#39;</span><span class=p>:</span> <span class=n>episode_time</span> <span class=o>/</span> <span class=n>completed_count</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><h3 id=强化学习带来的性能提升>强化学习带来的性能提升</h3><p>在实际测试中，经过1000个episode的训练后，RL调度器相比随机调度器的性能提升：</p><table><thead><tr><th>指标</th><th>随机调度</th><th>RL调度</th><th>提升</th></tr></thead><tbody><tr><td>平均完成时间</td><td>12.5s</td><td>8.3s</td><td><strong>33.6%</strong></td></tr><tr><td>P95完成时间</td><td>18.2s</td><td>11.4s</td><td><strong>37.4%</strong></td></tr><tr><td>资源利用率</td><td>68%</td><td>87%</td><td><strong>27.9%</strong></td></tr></tbody></table><p><strong>关键洞察</strong>：</p><ul><li>RL模型学会了优先处理"解锁"更多依赖任务的关键任务</li><li>在高负载场景下，学习到了动态调整并发度以避免OOM</li><li>通过经验回放，快速适应了不同类型任务的耗时分布</li></ul><h2 id=实践4分布式agent集群>实践4：分布式Agent集群</h2><p>当单机并发无法满足需求时，我们需要将Agent扩展到分布式集群。以下是基于Ray框架的实现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>ray</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>ray</span> <span class=kn>import</span> <span class=n>serve</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>typing</span> <span class=kn>import</span> <span class=n>List</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 初始化Ray集群</span>
</span></span><span class=line><span class=cl><span class=n>ray</span><span class=o>.</span><span class=n>init</span><span class=p>(</span><span class=n>address</span><span class=o>=</span><span class=s1>&#39;auto&#39;</span><span class=p>)</span>  <span class=c1># 连接到已有集群，或者启动本地集群</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@ray.remote</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DistributedAgentWorker</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    分布式Agent Worker
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>    每个Worker运行在独立的进程/机器上，
</span></span></span><span class=line><span class=cl><span class=s2>    可以处理CPU密集型或I/O密集型任务
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>worker_id</span><span class=p>:</span> <span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>worker_id</span> <span class=o>=</span> <span class=n>worker_id</span>
</span></span><span class=line><span class=cl>        <span class=c1># 每个worker有独立的模型实例（避免序列化开销）</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>local_model</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_load_model</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_load_model</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;加载本地模型（可以是LLM、工具等）&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 实际应用中，这里会加载真实的模型</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span><span class=s2>&#34;model&#34;</span><span class=p>:</span> <span class=s2>&#34;gpt-4&#34;</span><span class=p>,</span> <span class=s2>&#34;worker_id&#34;</span><span class=p>:</span> <span class=bp>self</span><span class=o>.</span><span class=n>worker_id</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        处理单个任务
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        注意：这是同步方法，Ray会自动处理并发
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>        <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>  <span class=c1># 模拟处理时间</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;task_id&#39;</span><span class=p>:</span> <span class=n>task</span><span class=o>.</span><span class=n>task_id</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;result&#39;</span><span class=p>:</span> <span class=sa>f</span><span class=s2>&#34;Processed by worker </span><span class=si>{</span><span class=bp>self</span><span class=o>.</span><span class=n>worker_id</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s1>&#39;worker_id&#39;</span><span class=p>:</span> <span class=bp>self</span><span class=o>.</span><span class=n>worker_id</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>DistributedAgentCluster</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;分布式Agent集群管理器&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>num_workers</span><span class=p>:</span> <span class=nb>int</span> <span class=o>=</span> <span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 创建分布式worker池</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>workers</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>            <span class=n>DistributedAgentWorker</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=n>worker_id</span><span class=o>=</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>num_workers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_tasks_batch</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>AgentTask</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        批量处理任务，自动分配到不同workers
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        Ray会自动：
</span></span></span><span class=line><span class=cl><span class=s2>        1. 负载均衡到不同机器
</span></span></span><span class=line><span class=cl><span class=s2>        2. 容错处理（worker崩溃时重试）
</span></span></span><span class=line><span class=cl><span class=s2>        3. 结果收集和聚合
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1># 将任务分配给workers（轮询策略）</span>
</span></span><span class=line><span class=cl>        <span class=n>futures</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>task</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>tasks</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>worker</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>workers</span><span class=p>[</span><span class=n>i</span> <span class=o>%</span> <span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>workers</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>            <span class=n>future</span> <span class=o>=</span> <span class=n>worker</span><span class=o>.</span><span class=n>process_task</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>futures</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>future</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 等待所有任务完成（并行执行）</span>
</span></span><span class=line><span class=cl>        <span class=n>results</span> <span class=o>=</span> <span class=n>ray</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>futures</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>results</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>process_tasks_dynamic</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>tasks</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>AgentTask</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=n>Dict</span><span class=p>[</span><span class=nb>str</span><span class=p>,</span> <span class=n>Any</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>        动态任务分配：worker完成任务后立即分配新任务
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>        这种方式在任务耗时差异大时效率更高
</span></span></span><span class=line><span class=cl><span class=s2>        &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>results</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=n>remaining_tasks</span> <span class=o>=</span> <span class=n>tasks</span><span class=o>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 初始分配：每个worker一个任务</span>
</span></span><span class=line><span class=cl>        <span class=n>active_futures</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>worker</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>workers</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>remaining_tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span> <span class=o>=</span> <span class=n>remaining_tasks</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>future</span> <span class=o>=</span> <span class=n>worker</span><span class=o>.</span><span class=n>process_task</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>active_futures</span><span class=p>[</span><span class=n>future</span><span class=p>]</span> <span class=o>=</span> <span class=n>worker</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># 动态调度：完成一个，分配一个</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>active_futures</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 等待任何一个任务完成</span>
</span></span><span class=line><span class=cl>            <span class=n>done_futures</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>ray</span><span class=o>.</span><span class=n>wait</span><span class=p>(</span><span class=nb>list</span><span class=p>(</span><span class=n>active_futures</span><span class=o>.</span><span class=n>keys</span><span class=p>()),</span> <span class=n>num_returns</span><span class=o>=</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>future</span> <span class=ow>in</span> <span class=n>done_futures</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span> <span class=o>=</span> <span class=n>ray</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>future</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>results</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>worker</span> <span class=o>=</span> <span class=n>active_futures</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>future</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># 如果还有待处理任务，分配给刚完成的worker</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>remaining_tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>next_task</span> <span class=o>=</span> <span class=n>remaining_tasks</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>new_future</span> <span class=o>=</span> <span class=n>worker</span><span class=o>.</span><span class=n>process_task</span><span class=o>.</span><span class=n>remote</span><span class=p>(</span><span class=n>next_task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>active_futures</span><span class=p>[</span><span class=n>new_future</span><span class=p>]</span> <span class=o>=</span> <span class=n>worker</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>results</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 使用示例</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>run_distributed_example</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 创建包含10个worker的集群</span>
</span></span><span class=line><span class=cl>    <span class=n>cluster</span> <span class=o>=</span> <span class=n>DistributedAgentCluster</span><span class=p>(</span><span class=n>num_workers</span><span class=o>=</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 准备100个任务</span>
</span></span><span class=line><span class=cl>    <span class=n>tasks</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=n>AgentTask</span><span class=p>(</span><span class=n>task_id</span><span class=o>=</span><span class=sa>f</span><span class=s2>&#34;task_</span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>prompt</span><span class=o>=</span><span class=sa>f</span><span class=s2>&#34;Task </span><span class=si>{</span><span class=n>i</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 动态调度执行</span>
</span></span><span class=line><span class=cl>    <span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>    <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span> <span class=o>=</span> <span class=n>cluster</span><span class=o>.</span><span class=n>process_tasks_dynamic</span><span class=p>(</span><span class=n>tasks</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>elapsed_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Processed </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>results</span><span class=p>)</span><span class=si>}</span><span class=s2> tasks in </span><span class=si>{</span><span class=n>elapsed_time</span><span class=si>:</span><span class=s2>.2f</span><span class=si>}</span><span class=s2>s&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Throughput: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>results</span><span class=p>)</span><span class=o>/</span><span class=n>elapsed_time</span><span class=si>:</span><span class=s2>.1f</span><span class=si>}</span><span class=s2> tasks/sec&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ray.shutdown()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><p><strong>分布式集群的关键优势</strong>：</p><ol><li><strong>弹性扩展</strong>：根据负载动态增减worker数量</li><li><strong>容错能力</strong>：单个worker故障不影响整体系统</li><li><strong>资源隔离</strong>：不同任务可以使用不同的资源配置（CPU、GPU、内存）</li><li><strong>跨地域部署</strong>：可以在多个数据中心部署workers，降低延迟</li></ol><h2 id=性能优化技巧总结>性能优化技巧总结</h2><h3 id=1-批处理batching>1. 批处理（Batching）</h3><p>将多个小任务合并为一个批次发送给LLM，减少网络往返次数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 不佳：串行调用10次</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>task</span> <span class=ow>in</span> <span class=n>tasks</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=k>await</span> <span class=n>llm_client</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>prompt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 优化：批量调用1次</span>
</span></span><span class=line><span class=cl><span class=n>prompts</span> <span class=o>=</span> <span class=p>[</span><span class=n>task</span><span class=o>.</span><span class=n>prompt</span> <span class=k>for</span> <span class=n>task</span> <span class=ow>in</span> <span class=n>tasks</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>results</span> <span class=o>=</span> <span class=k>await</span> <span class=n>llm_client</span><span class=o>.</span><span class=n>generate_batch</span><span class=p>(</span><span class=n>prompts</span><span class=p>,</span> <span class=n>batch_size</span><span class=o>=</span><span class=mi>10</span><span class=p>)</span>
</span></span></code></pre></div><p><strong>性能提升</strong>：吞吐量提高5-10倍（取决于批次大小和网络延迟）</p><h3 id=2-缓存caching>2. 缓存（Caching）</h3><p>对重复或相似的任务使用缓存结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>lru_cache</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>hashlib</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>CachedAgent</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>_compute_cache_key</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>prompt</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>context</span><span class=p>:</span> <span class=n>Dict</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;&#34;&#34;计算缓存键（考虑prompt和context）&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>cache_input</span> <span class=o>=</span> <span class=sa>f</span><span class=s2>&#34;</span><span class=si>{</span><span class=n>prompt</span><span class=si>}</span><span class=s2>:</span><span class=si>{</span><span class=nb>sorted</span><span class=p>(</span><span class=n>context</span><span class=o>.</span><span class=n>items</span><span class=p>())</span><span class=si>}</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>hashlib</span><span class=o>.</span><span class=n>md5</span><span class=p>(</span><span class=n>cache_input</span><span class=o>.</span><span class=n>encode</span><span class=p>())</span><span class=o>.</span><span class=n>hexdigest</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>process_with_cache</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Any</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>cache_key</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_compute_cache_key</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>prompt</span><span class=p>,</span> <span class=n>task</span><span class=o>.</span><span class=n>context</span> <span class=ow>or</span> <span class=p>{})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>cache_key</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>cache_key</span><span class=p>]</span>  <span class=c1># 缓存命中</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=k>await</span> <span class=bp>self</span><span class=o>.</span><span class=n>process_task</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>cache</span><span class=p>[</span><span class=n>cache_key</span><span class=p>]</span> <span class=o>=</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><p><strong>适用场景</strong>：</p><ul><li>代码审查Agent：相同文件的重复审查</li><li>文档问答Agent：高频问题</li><li>数据分析Agent：相同数据集的统计查询</li></ul><h3 id=3-推测执行speculative-execution>3. 推测执行（Speculative Execution）</h3><p>在等待LLM响应时，预测性地准备后续可能需要的资源：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>speculative_execution</span><span class=p>(</span><span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 主任务：LLM推理</span>
</span></span><span class=line><span class=cl>    <span class=n>llm_future</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>llm_client</span><span class=o>.</span><span class=n>generate</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>prompt</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 推测任务：预加载可能需要的文件</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s1>&#39;file_path&#39;</span> <span class=ow>in</span> <span class=n>task</span><span class=o>.</span><span class=n>context</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>file_future</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>load_file</span><span class=p>(</span><span class=n>task</span><span class=o>.</span><span class=n>context</span><span class=p>[</span><span class=s1>&#39;file_path&#39;</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 等待主任务</span>
</span></span><span class=line><span class=cl>    <span class=n>result</span> <span class=o>=</span> <span class=k>await</span> <span class=n>llm_future</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 如果推测正确，文件已经加载好了</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=s1>&#39;load_file&#39;</span> <span class=ow>in</span> <span class=n>result</span><span class=o>.</span><span class=n>actions</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>file_content</span> <span class=o>=</span> <span class=k>await</span> <span class=n>file_future</span>  <span class=c1># 立即可用</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>process_with_file</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>file_content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><h3 id=4-模型选择策略>4. 模型选择策略</h3><p>不是所有任务都需要最强大的模型：</p><table><thead><tr><th>任务类型</th><th>推荐模型</th><th>延迟</th><th>成本</th></tr></thead><tbody><tr><td>简单分类/提取</td><td>GPT-3.5-turbo</td><td>0.5s</td><td>$</td></tr><tr><td>代码生成</td><td>GPT-4</td><td>2s</td><td>$$$</td></tr><tr><td>复杂推理</td><td>GPT-4</td><td>3s</td><td>$$$$</td></tr><tr><td>批量标注</td><td>本地小模型</td><td>0.1s</td><td>Free</td></tr></tbody></table><p>实现动态模型选择：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>AdaptiveModelSelector</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;根据任务特征自动选择最合适的模型&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>select_model</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>str</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 基于任务复杂度、延迟要求、成本预算选择模型</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>task</span><span class=o>.</span><span class=n>context</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;urgent&#39;</span><span class=p>,</span> <span class=kc>False</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;gpt-3.5-turbo&#39;</span>  <span class=c1># 低延迟</span>
</span></span><span class=line><span class=cl>        <span class=k>elif</span> <span class=n>task</span><span class=o>.</span><span class=n>context</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;complexity&#39;</span><span class=p>)</span> <span class=o>==</span> <span class=s1>&#39;high&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;gpt-4&#39;</span>  <span class=c1># 高质量</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s1>&#39;local-model&#39;</span>  <span class=c1># 低成本</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><h2 id=监控与调试>监控与调试</h2><p>并行Agent系统的监控至关重要。推荐监控以下指标：</p><ol><li><p><strong>吞吐量指标</strong></p><ul><li>每秒处理任务数（TPS）</li><li>并发度利用率</li><li>队列积压深度</li></ul></li><li><p><strong>延迟指标</strong></p><ul><li>P50/P95/P99 完成时间</li><li>任务等待时间 vs 执行时间</li><li>端到端延迟</li></ul></li><li><p><strong>质量指标</strong></p><ul><li>任务成功率</li><li>重试次数</li><li>用户满意度评分（用于RL训练）</li></ul></li><li><p><strong>资源指标</strong></p><ul><li>CPU/内存/GPU使用率</li><li>API调用次数和成本</li><li>网络带宽</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>prometheus_client</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>prometheus_client</span> <span class=kn>import</span> <span class=n>Counter</span><span class=p>,</span> <span class=n>Histogram</span><span class=p>,</span> <span class=n>Gauge</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 定义Prometheus指标</span>
</span></span><span class=line><span class=cl><span class=n>task_counter</span> <span class=o>=</span> <span class=n>Counter</span><span class=p>(</span><span class=s1>&#39;agent_tasks_total&#39;</span><span class=p>,</span> <span class=s1>&#39;Total tasks processed&#39;</span><span class=p>,</span> <span class=p>[</span><span class=s1>&#39;status&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=n>task_duration</span> <span class=o>=</span> <span class=n>Histogram</span><span class=p>(</span><span class=s1>&#39;agent_task_duration_seconds&#39;</span><span class=p>,</span> <span class=s1>&#39;Task processing duration&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>queue_depth</span> <span class=o>=</span> <span class=n>Gauge</span><span class=p>(</span><span class=s1>&#39;agent_queue_depth&#39;</span><span class=p>,</span> <span class=s1>&#39;Number of tasks in queue&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>concurrency</span> <span class=o>=</span> <span class=n>Gauge</span><span class=p>(</span><span class=s1>&#39;agent_active_workers&#39;</span><span class=p>,</span> <span class=s1>&#39;Number of active workers&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MonitoredAgent</span><span class=p>(</span><span class=n>ParallelAgent</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;带监控的Agent实现&#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>process_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>Any</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>queue_depth</span><span class=o>.</span><span class=n>dec</span><span class=p>()</span>  <span class=c1># 从队列移除</span>
</span></span><span class=line><span class=cl>        <span class=n>concurrency</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>  <span class=c1># 开始处理</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>=</span> <span class=k>await</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>process_task</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>task_counter</span><span class=o>.</span><span class=n>labels</span><span class=p>(</span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;success&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>task_counter</span><span class=o>.</span><span class=n>labels</span><span class=p>(</span><span class=n>status</span><span class=o>=</span><span class=s1>&#39;failed&#39;</span><span class=p>)</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=k>raise</span>
</span></span><span class=line><span class=cl>        <span class=k>finally</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>duration</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>            <span class=n>task_duration</span><span class=o>.</span><span class=n>observe</span><span class=p>(</span><span class=n>duration</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>concurrency</span><span class=o>.</span><span class=n>dec</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>async</span> <span class=k>def</span> <span class=nf>submit_task</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>task</span><span class=p>:</span> <span class=n>AgentTask</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>queue_depth</span><span class=o>.</span><span class=n>inc</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>submit_task</span><span class=p>(</span><span class=n>task</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动Prometheus HTTP服务器</span>
</span></span><span class=line><span class=cl><span class=n>prometheus_client</span><span class=o>.</span><span class=n>start_http_server</span><span class=p>(</span><span class=mi>8000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># generated by AI</span>
</span></span></code></pre></div><h2 id=未来展望>未来展望</h2><p>Agent强化学习和并行处理技术仍在快速发展，以下是2026年值得关注的方向：</p><ol><li><strong>异构Agent协作</strong>：不同能力的Agent（代码、图像、语音）协同完成复杂任务</li><li><strong>联邦学习</strong>：多个Agent分布式学习，共享经验而不共享原始数据</li><li><strong>神经架构搜索</strong>：自动发现最优的Agent网络结构</li><li><strong>因果推理集成</strong>：让Agent理解"为什么"而不仅仅是"是什么"</li><li><strong>人机协作RL</strong>：结合人类反馈（RLHF）和自动化探索</li></ol><h2 id=总结>总结</h2><p>构建高性能的并行Agent系统需要在多个层面进行优化：</p><ol><li><strong>架构层面</strong>：采用异步I/O、任务队列、worker池等并行模式</li><li><strong>调度层面</strong>：智能任务调度、优先级管理、依赖解析</li><li><strong>学习层面</strong>：使用强化学习在线优化调度策略</li><li><strong>分布式层面</strong>：扩展到多机集群，提高整体吞吐量</li><li><strong>工程层面</strong>：批处理、缓存、推测执行等优化技巧</li></ol><p>通过本文介绍的实践，你可以构建一个从串行到并行、从固定策略到自适应学习、从单机到分布式的完整Agent系统演进路径。</p><p><strong>关键要点</strong>：</p><ul><li>并行化是提升Agent性能的最直接手段，可带来5-10倍性能提升</li><li>强化学习能让Agent自动发现最优调度策略，适应不同工作负载</li><li>监控和可观测性是保证系统可靠性的基础</li><li>优化是一个持续迭代的过程，需要根据实际业务特点调整</li></ul><p>现在就开始优化你的Agent系统，让它在2026年的AI应用竞争中脱颖而出！</p><hr><p><em>本文代码示例已开源：<a href=https://github.com/hugozhu/agent-rl-examples>github.com/hugozhu/agent-rl-examples</a></em>（注：示例链接）</p><p><em>欢迎在评论区分享你的Agent并行化实践经验！</em></p><div class=blog-tags><a href=https://hugozhu.site/tags/ai/>AI</a>&nbsp;
<a href=https://hugozhu.site/tags/reinforcement-learning/>reinforcement-learning</a>&nbsp;
<a href=https://hugozhu.site/tags/ai-agents/>AI-agents</a>&nbsp;
<a href=https://hugozhu.site/tags/machine-learning/>machine-learning</a>&nbsp;
<a href=https://hugozhu.site/tags/performance-optimization/>performance-optimization</a>&nbsp;
<a href=https://hugozhu.site/tags/parallel-processing/>parallel-processing</a>&nbsp;
<a href=https://hugozhu.site/tags/python/>python</a>&nbsp;</div><hr><section id=social-share><div class="list-inline footer-links"><div class=share-box aria-hidden=true><ul class=share><li><a href="//twitter.com/share?url=https%3a%2f%2fhugozhu.site%2fpost%2f2026%2f91-agent-reinforcement-learning-best-practices%2f&amp;text=Agent%e5%bc%ba%e5%8c%96%e5%ad%a6%e4%b9%a0%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%ef%bc%9a%e5%b9%b6%e8%a1%8c%e4%bb%bb%e5%8a%a1%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&amp;via=" target=_blank title="Share on Twitter"><i class="fab fa-twitter"></i></a></li><li><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fhugozhu.site%2fpost%2f2026%2f91-agent-reinforcement-learning-best-practices%2f" target=_blank title="Share on Facebook"><i class="fab fa-facebook"></i></a></li><li><a href="//reddit.com/submit?url=https%3a%2f%2fhugozhu.site%2fpost%2f2026%2f91-agent-reinforcement-learning-best-practices%2f&amp;title=Agent%e5%bc%ba%e5%8c%96%e5%ad%a6%e4%b9%a0%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%ef%bc%9a%e5%b9%b6%e8%a1%8c%e4%bb%bb%e5%8a%a1%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" target=_blank title="Share on Reddit"><i class="fab fa-reddit"></i></a></li><li><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fhugozhu.site%2fpost%2f2026%2f91-agent-reinforcement-learning-best-practices%2f&amp;title=Agent%e5%bc%ba%e5%8c%96%e5%ad%a6%e4%b9%a0%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%ef%bc%9a%e5%b9%b6%e8%a1%8c%e4%bb%bb%e5%8a%a1%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" target=_blank title="Share on LinkedIn"><i class="fab fa-linkedin"></i></a></li><li><a href="//www.stumbleupon.com/submit?url=https%3a%2f%2fhugozhu.site%2fpost%2f2026%2f91-agent-reinforcement-learning-best-practices%2f&amp;title=Agent%e5%bc%ba%e5%8c%96%e5%ad%a6%e4%b9%a0%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%ef%bc%9a%e5%b9%b6%e8%a1%8c%e4%bb%bb%e5%8a%a1%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" target=_blank title="Share on StumbleUpon"><i class="fab fa-stumbleupon"></i></a></li><li><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fhugozhu.site%2fpost%2f2026%2f91-agent-reinforcement-learning-best-practices%2f&amp;description=Agent%e5%bc%ba%e5%8c%96%e5%ad%a6%e4%b9%a0%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%ef%bc%9a%e5%b9%b6%e8%a1%8c%e4%bb%bb%e5%8a%a1%e5%a4%84%e7%90%86%e4%b8%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" target=_blank title="Share on Pinterest"><i class="fab fa-pinterest"></i></a></li></ul></div></div></section><h4 class=see-also>See also</h4><ul><li><a href=/post/2025/113-claude-code-auto-correction-agent-loop/>Claude Code自动修正生成代码的原理解析：Agent Loop最佳实践</a></li><li><a href=/post/2025/112-ai-powered-google-resume-from-personal-website/>如何用 AI 将个人网站转化为专业的 Google 求职简历</a></li><li><a href=/post/2025/101-multimodal-ai-b2b-order-normalization/>多模态AI驱动的B2B订单归一化：从非标准文档到MES系统的智能工作流</a></li><li><a href=/post/2025/110-ai-exam-grading-agent-best-practices/>小学标准化试卷AI批改Agent最佳工程实践</a></li><li><a href=/post/2025/111-order-document-classifier-agent-routing/>构建高质量订单文档分类器：智能导流到专业Agent</a></li></ul></article><ul class="pager blog-pager"><li class=previous><a href=https://hugozhu.site/post/2025/113-claude-code-auto-correction-agent-loop/ data-toggle=tooltip data-placement=top title="Claude Code自动修正生成代码的原理解析：Agent Loop最佳实践">&larr; Previous Post</a></li></ul><div class=disqus-comments><button id=show-comments class="btn btn-default" type=button>Show <span class=disqus-comment-count data-disqus-url=https://hugozhu.site/post/2026/91-agent-reinforcement-learning-best-practices>comments</span></button><div id=disqus_thread></div><script type=text/javascript>var disqus_config=function(){this.page.url="https://hugozhu.site/post/2026/91-agent-reinforcement-learning-best-practices"}</script></div></div></div></div><footer><div class=container><div class=row><div class=disclaimer><b>Disclaimer:</b> The opinions expressed herein are my own personal opinions and do not represent my company’s view in any way.</div></div><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"></ul><p class="credits copyright text-muted">&nbsp;&bull;&nbsp;&copy;
2026
&nbsp;&bull;&nbsp;
<a href=https://hugozhu.site/>All about Raspberry Pi</a></p><p class="credits theme-by text-muted"><a href=https://gohugo.io>Hugo v0.145.0</a> powered &nbsp;&bull;&nbsp; Theme <a href=https://github.com/halogenica/beautifulhugo>Beautiful Hugo</a> adapted from <a href=https://deanattali.com/beautiful-jekyll/>Beautiful Jekyll</a></p></div></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload=renderMathInElement(document.body)></script><script src=https://code.jquery.com/jquery-3.7.0.slim.min.js integrity=sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js integrity=sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd crossorigin=anonymous></script><script src=https://hugozhu.site/js/main.js></script><script src=https://hugozhu.site/js/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><script>$(document).ready(function(){$("pre.chroma").css("padding","0")})</script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js integrity=sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js integrity=sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q crossorigin=anonymous></script><script src=https://hugozhu.site/js/load-photoswipe.js></script><script>(function(){var t,n="617d351a633194d48",e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="https://cse.google.com/cse.js?cx="+n,t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>$(function(){$("#show-comments").on("click",function(){var e="hugozhu";(function(){var t=document.createElement("script");t.type="text/javascript",t.async=!0,t.src="//"+e+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(t)})(),$(this).hide()})})</script><script id=dsq-count-scr src=//hugozhu.disqus.com/count.js async></script></body></html>