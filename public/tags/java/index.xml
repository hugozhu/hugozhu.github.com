<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on All about Raspberry Pi</title><link>/tags/java/</link><description>Recent content in Java on All about Raspberry Pi</description><generator>Hugo</generator><language>en</language><managingEditor>hugozhu@gmail.com (Hugo Zhu)</managingEditor><webMaster>hugozhu@gmail.com (Hugo Zhu)</webMaster><lastBuildDate>Thu, 28 Mar 2013 00:00:00 +0000</lastBuildDate><atom:link href="/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>并发编程之内存屏障</title><link>/post/2013/22-memory-barriers-or-fences/</link><pubDate>Thu, 28 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/22-memory-barriers-or-fences/</guid><description>原文地址：http://mechanical-sympathy.blogspot.com/2011/07/memory-barriersfences.html 或 http://ifeve.com/memory-barriersfences/
关键词：Load Barrier, Store Barrier, Full Barrier
本文我将和大家讨论并发编程中最基础的一项技术：内存屏障或内存栅栏，也就是让一个CPU处理单元中的内存状态对其它处理单元可见的一项技术。
CPU使用了很多优化技术来达成一个事实：CPU执行单元的速度要远超主存访问速度。在我上一篇文章 &amp;ldquo;Write Combing - 合并写&amp;quot;中我已经介绍了其中的一项技术。CPU避免内存访问延迟最常见的技术是将指令管道化，然后尽量重排这些管道的执行以最大利用缓存而把因为缓存未命中引起的延迟降到最小。
当一个程序执行时指令是否被重排并不重要，只要最终的结果是一样的。例如，在一个循环里，如果循环体内没用到这个计数器，循环的计数器什么时候更新（在循环开始，中间还是最后）并不重要。编译器和CPU可以自由的重排指令以最佳的利用CPU，只要下一次循环前更新该计数器即可。并且在循环执行中，这个变量可能一直存在寄存器上，并没有被推到缓存或主存，这样这个变量对其他CPU来说一直都是不可见的。
CPU核内部包含了多个执行单元。例如，现代Intel CPU包含了6个执行单元，可以组合进行算术运算，逻辑条件判断及内存操作。每个执行单元可以执行上述任务的某种组合。这些执行单元是并行执行的，这样指令也就是在并行执行。但如果站在另一个CPU角度看，这也就产生了程序顺序的另一种不确定性。
最后，当一个缓存失效发生时，现代CPU可以先假设一个内存载入的值并根据这个假设值继续执行，直到内存载入返回确切的值。
CPU核 | V 寄存器 | V 执行单元 -&amp;gt; Load/Store缓冲区-&amp;gt;L1 Cache ---&amp;gt;L3 Cache--&amp;gt;内存控制器--&amp;gt;主存 | | +-&amp;gt; Write Combine缓冲区-&amp;gt;L2 Cache ---+ 代码顺序并不是真正的执行顺序，CPU和编译器可以各种优化只要有空间提高性能。缓存和主存的读取会利用load, store和write-combining缓冲区来缓冲和重排。这些缓冲区是查找速度很快的关联队列，当一个后来发生的load需要读取上一个store的值，而该值还没有到达缓存，查找是必需的，上图描绘的是一个简化的现代多核CPU，从上图可以看出执行单元可以利用本地寄存器和缓冲区来管理和缓存子系统的交互。
在多线程环境里需要使用技术来使得程序结果尽快可见。这篇文章里我不会涉及到 Cache Conherence 的概念。请先假定一个事实：一旦内存数据被推送到缓存，就会有消息协议来确保所有的缓存会对所有的共享数据同步并保持一致。这个使内存数据对CPU核可见的技术被称为内存屏障或内存栅栏。
内存屏障提供了两个功能。首先，它们通过确保从另一个CPU来看屏障的两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性；其次它们可以实现内存数据可见性，确保内存数据会同步到CPU缓存子系统。
大多数的内存屏障都是复杂的话题。在不同的CPU架构上内存屏障的实现非常不一样。相对来说Intel CPU的强内存模型比DEC Alpha的弱复杂内存模型（缓存不仅分层了，还分区了）更简单。因为x86处理器是在多线程编程中最常见的，下面我尽量用x86的架构来阐述。
Store Barrier Store屏障，是x86的&amp;rdquo;sfence&amp;ldquo;指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。一个实际的好例子是Disruptor中的BatchEventProcessor。当序列Sequence被一个消费者更新时，其它消费者(Consumers)和生产者（Producers）知道该消费者的进度，因此可以采取合适的动作。所以屏障之前发生的内存更新都可见了。
private volatile long sequence = RingBuffer.INITIAL_CURSOR_VALUE; // from inside the run() method T event = null; long nextSequence = sequence.</description></item><item><title>Java并发包中的同步队列SynchronousQueue实现原理</title><link>/post/2013/java-synchronousqueue-notes/</link><pubDate>Tue, 05 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/java-synchronousqueue-notes/</guid><description>介绍 Java 6的并发编程包中的SynchronousQueue是一个没有数据缓冲的BlockingQueue，生产者线程对其的插入操作put必须等待消费者的移除操作take，反过来也一样。
不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。
SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。
实现原理 同步队列的实现方法有许多：
阻塞算法实现 阻塞算法实现通常在内部采用一个锁来保证多个线程中的put()和take()方法是串行执行的。采用锁的开销是比较大的，还会存在一种情况是线程A持有线程B需要的锁，B必须一直等待A释放锁，即使A可能一段时间内因为B的优先级比较高而得不到时间片运行。所以在高性能的应用中我们常常希望规避锁的使用。
public class NativeSynchronousQueue&amp;lt;E&amp;gt; { boolean putting = false; E item = null; public synchronized E take() throws InterruptedException { while (item == null) wait(); E e = item; item = null; notifyAll(); return e; } public synchronized void put(E e) throws InterruptedException { if (e==null) return; while (putting) wait(); putting = true; item = e; notifyAll(); while (item!=null) wait(); putting = false; notifyAll(); } } 信号量实现 经典同步队列实现采用了三个信号量，代码很简单，比较容易理解：</description></item><item><title>Java的资源管理</title><link>/post/2013/resource-management-in-java/</link><pubDate>Fri, 01 Mar 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/resource-management-in-java/</guid><description>Overview Java程序中的常见的资源有：文件，Socket，数据库连接。在使用这些资源时候要分外小心，因为操作系统可同时操作的资源是有限的，比如默认情况下系统允许同时打开的文件数为1024个，Mysql服务器默认允许的最大连接数是100，所以操作这些资源时候要注意即使在遇到错误时也要让系统能正确回收资源。如果发生错误时候，打开的文件描述符没关闭或数据库连接没关闭，积累到一定程度后，应用将会变得不可用，只能重启。
try-catch-finally Java提供了try-catch-finally来保证程序遇到异常时总是有机会可以处理资源的关闭 &amp;ndash; 调用资源对象的close()方法。但经验不足的Java程序员还是会错误的管理资源，而造成资源的泄露，静态代码分析工具，如FindBugs可以帮助发现此类问题。
首先我们来看一段文件操作代码：
private void copy(String from, String to) throws IOException { FileInputStream in = null; FileOutputStream out = null; in = new FileInputStream(from); out = new FileOutputStream(to); int c; while ((c = in.read()) != -1) out.write(c); in.close(); out.close(); } 一眼看上去，代码挺整齐的，逻辑也容易理解。但其中有一个很大的问题是，如果out.write调用失败（比如磁盘空间满了）方法异常退出，in.close()和out.close()就不会被调用，而in和out对象内部都引用了系统资源-文件描述符，这样会导致文件描述符没有关闭，不能被重新使用而直到整个Java进程退出。
File descriptor Linux的每个进程（如：Java进程）都有一个文件描述符表管理当前进程访问的所有的文件，文件描述符关联了系统文件表中的file entry，系统能容纳多少file entry是有限制的，如果超过限制系统会拒绝访问，抛出Too many opened files错误。
较为正确的代码应该是：
private void copy(String src, String dest) throws IOException { FileInputStream in = null; FileOutputStream out = null; try { in = new FileInputStream(src); out = new FileOutputStream(dest); int c; while ((c = in.</description></item><item><title>Java程序的日志</title><link>/post/2013/logging-in-java/</link><pubDate>Thu, 28 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/logging-in-java/</guid><description>Overview 一个在生产环境里运行的程序如果没有日志是很让维护者提心吊胆的，有太多杂乱又无意义的日志也是令人伤神。程序出现问题时候，从日志里如果发现不了问题可能的原因是很令人受挫的。本文想讨论的是如何在Java程序里写好日志。大多数的Web服务器（如Apache，Nginx）都有access日志和error日志，分别记录在不同的文件内；我们使用的服务器操作系统Linux有Syslog日志, /var/log目录下也有很多基础应用和服务的日志文件；桌面Windows有事件查看器, Mac有Console应用可以查看和管理日志；这些成熟的系统及工具方法都值得我们学习并在自己的项目中应用。
一般来说日志分为两种：业务日志和异常日志。使用日志我们希望能达到以下目标：
对程序运行情况的记录和监控； 在必要时可详细了解程序内部的运行状态； 对系统性能的影响尽量小； 日志规范 程序框架应该提供统一的日志记录接口，日志格式也需要有一定的规范，方便利用日志工具来分析日志。 首先我们有必要了解一下Linux普遍使用的Syslog标准协议，协议规定日志中应包含产生日志的模块(Facility)，严重性（Severity Level），时间，主机名或IP，进程名，进程ID和日志内容，根据模块和严重性可以配置相应的动作：是否需要记录，日志存储路径（文件或网络）。
下面是部分常见的Syslog模块类型：
模块ID 关键词 描述 0 kern 内核消息 1 user 用户级别消息 2 mail 邮件系统 3 daemon 系统后台守护程序 4 auth 安全/鉴权消息 5 syslog syslogd内部产生的日志消息 … 以及Syslog严重程度划分：
代码 严重程度 关键词 描述 0 Emergency emerg(panic) 紧急，系统已经不稳定了 1 Alert alert 需要立刻采取措施 2 Critical crit 严重情况 3 Error err (error) 系统出错 4 Warning warning(warn) 系统警告 5 Notice notice 系统仍然正常，但值得注意 6 Informational info 正常系统通告 7 Debug debug 系统调试信息 在你的Java程序里日志也可以参考Syslog的设计，根据业务对程序的模块和日志级别做一定的规划和设计。</description></item><item><title>将Java的Properties文件转换成环境变量</title><link>/post/2013/java-properties-to-enviorment-variables/</link><pubDate>Mon, 25 Feb 2013 00:00:00 +0000</pubDate><author>hugozhu@gmail.com (Hugo Zhu)</author><guid>/post/2013/java-properties-to-enviorment-variables/</guid><description>Overview 在Java程序中使用properties文件很方便，但有时候需要和脚本配合使用时，需要把properties文件内的多个变量转换成环境变量，本文提供一个转换脚本示范：
比如env.properties如下（=附近可以有空格，也可以有空行）
MYSQL_URL = jdbc:mysql://localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk MYSQL_USER = root MYSQL_PASS = 执行下面的脚本后就相当于
export MYSQL_URL=&amp;quot;//localhost:3306/test?autoReconnect=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=gbk&amp;quot; export MYSQL_USER=&amp;quot;root&amp;quot; export MYSQL_PASS=&amp;quot;&amp;quot; env.sh脚本代码
#!/bin/bash property_file=env.properties get_prop(){ propfile=$1 key=$2 grep &amp;quot;^${2}=&amp;quot; ${1}| sed &amp;quot;s%${2}=\(.*\)%\1%&amp;quot; } trim() { trimmed=$1 trimmed=${trimmed%% } trimmed=${trimmed## } echo &amp;quot;$trimmed&amp;quot; } `grep -v &amp;quot;^#&amp;quot; $property_file | sed -e '/^$/d' | while read line do key=$(echo $line | awk -F &amp;quot;=&amp;quot; '{print $1}') trimmed_key=$(trim $key) trimmed_val=$(trim $(get_prop $property_file &amp;quot;$key&amp;quot;) echo &amp;quot;export $trimmed_key=\&amp;quot;$trimmed_val\&amp;quot;)&amp;quot; done`</description></item></channel></rss>